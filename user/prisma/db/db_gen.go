// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"","value":"postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"},"config":null}]`

const schema = `datasource db {
  // could be postgresql or mysql
  provider = "postgresql"
  url      = "postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}

model User {
  id                Int   @id @default(autoincrement())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  username          String
  supabaseId        String @default("")
  UserPaymentTypes  UserPaymentTypes[]
  Deposit           Deposit[]
  Transaction       Transaction[]
  WithDraw          WithDraw[]
}


model MasterPaymentType {
  id                Int   @id @default(autoincrement())
  name              String
  userPaymentTypes  UserPaymentTypes[]
}

model UserPaymentTypes {
  id                      Int                @id @default(autoincrement())
  user                    User               @relation(fields: [userId], references: [id])
  userId                  Int
  masterPaymentType       MasterPaymentType  @relation(fields: [masterPaymentTypeId], references: [id])
  masterPaymentTypeId     Int
}

model Transaction {
    id                     Int                @id @default(autoincrement())
    user                   User               @relation(fields: [userId], references: [id])
    userId                Int
    toAddress              String
    fromAddress           String
    currency              String
    TransactionHistory    TransactionHistory[]
}


model TransactionHistory {
  id                Int   @id @default(autoincrement())
  transaction       Transaction @relation(fields: [transactionId], references: [id])
  transactionId     Int
  status            String
}

model Deposit {
  id        Int                @id @default(autoincrement())
  user      User               @relation(fields: [userId], references: [id])
  userId    Int
  amount    Int
  WithDraw WithDraw[]
  DepositTransaction DepositTransaction[]
}

model WithDraw {
    id        Int                @id @default(autoincrement())
    charge  Int
    user      User               @relation(fields: [userId], references: [id])
    userId    Int
    deposit   Deposit               @relation(fields: [depositId], references: [id])
    depositId    Int
}

model DepositTransaction {
     id        Int                @id @default(autoincrement())
     amount    Int
     deposit   Deposit               @relation(fields: [depositId], references: [id])
    depositId    Int
}




`
const schemaDatasourceURL = "postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"
const schemaEnvVarName = ""

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set" + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.MasterPaymentType = masterPaymentTypeActions{client: c}
	c.UserPaymentTypes = userPaymentTypesActions{client: c}
	c.Transaction = transactionActions{client: c}
	c.TransactionHistory = transactionHistoryActions{client: c}
	c.Deposit = depositActions{client: c}
	c.WithDraw = withDrawActions{client: c}
	c.DepositTransaction = depositTransactionActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// MasterPaymentType provides access to CRUD methods.
	MasterPaymentType masterPaymentTypeActions
	// UserPaymentTypes provides access to CRUD methods.
	UserPaymentTypes userPaymentTypesActions
	// Transaction provides access to CRUD methods.
	Transaction transactionActions
	// TransactionHistory provides access to CRUD methods.
	TransactionHistory transactionHistoryActions
	// Deposit provides access to CRUD methods.
	Deposit depositActions
	// WithDraw provides access to CRUD methods.
	WithDraw withDrawActions
	// DepositTransaction provides access to CRUD methods.
	DepositTransaction depositTransactionActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID         UserScalarFieldEnum = "id"
	UserScalarFieldEnumCreatedAt  UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt  UserScalarFieldEnum = "updatedAt"
	UserScalarFieldEnumUsername   UserScalarFieldEnum = "username"
	UserScalarFieldEnumSupabaseID UserScalarFieldEnum = "supabaseId"
)

type MasterPaymentTypeScalarFieldEnum string

const (
	MasterPaymentTypeScalarFieldEnumID   MasterPaymentTypeScalarFieldEnum = "id"
	MasterPaymentTypeScalarFieldEnumName MasterPaymentTypeScalarFieldEnum = "name"
)

type UserPaymentTypesScalarFieldEnum string

const (
	UserPaymentTypesScalarFieldEnumID                  UserPaymentTypesScalarFieldEnum = "id"
	UserPaymentTypesScalarFieldEnumUserID              UserPaymentTypesScalarFieldEnum = "userId"
	UserPaymentTypesScalarFieldEnumMasterPaymentTypeID UserPaymentTypesScalarFieldEnum = "masterPaymentTypeId"
)

type TransactionScalarFieldEnum string

const (
	TransactionScalarFieldEnumID          TransactionScalarFieldEnum = "id"
	TransactionScalarFieldEnumUserID      TransactionScalarFieldEnum = "userId"
	TransactionScalarFieldEnumToAddress   TransactionScalarFieldEnum = "toAddress"
	TransactionScalarFieldEnumFromAddress TransactionScalarFieldEnum = "fromAddress"
	TransactionScalarFieldEnumCurrency    TransactionScalarFieldEnum = "currency"
)

type TransactionHistoryScalarFieldEnum string

const (
	TransactionHistoryScalarFieldEnumID            TransactionHistoryScalarFieldEnum = "id"
	TransactionHistoryScalarFieldEnumTransactionID TransactionHistoryScalarFieldEnum = "transactionId"
	TransactionHistoryScalarFieldEnumStatus        TransactionHistoryScalarFieldEnum = "status"
)

type DepositScalarFieldEnum string

const (
	DepositScalarFieldEnumID     DepositScalarFieldEnum = "id"
	DepositScalarFieldEnumUserID DepositScalarFieldEnum = "userId"
	DepositScalarFieldEnumAmount DepositScalarFieldEnum = "amount"
)

type WithDrawScalarFieldEnum string

const (
	WithDrawScalarFieldEnumID        WithDrawScalarFieldEnum = "id"
	WithDrawScalarFieldEnumCharge    WithDrawScalarFieldEnum = "charge"
	WithDrawScalarFieldEnumUserID    WithDrawScalarFieldEnum = "userId"
	WithDrawScalarFieldEnumDepositID WithDrawScalarFieldEnum = "depositId"
)

type DepositTransactionScalarFieldEnum string

const (
	DepositTransactionScalarFieldEnumID        DepositTransactionScalarFieldEnum = "id"
	DepositTransactionScalarFieldEnumAmount    DepositTransactionScalarFieldEnum = "amount"
	DepositTransactionScalarFieldEnumDepositID DepositTransactionScalarFieldEnum = "depositId"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldID userPrismaFields = "id"

const userFieldCreatedAt userPrismaFields = "createdAt"

const userFieldUpdatedAt userPrismaFields = "updatedAt"

const userFieldUsername userPrismaFields = "username"

const userFieldSupabaseID userPrismaFields = "supabaseId"

const userFieldUserPaymentTypes userPrismaFields = "UserPaymentTypes"

const userFieldDeposit userPrismaFields = "Deposit"

const userFieldTransaction userPrismaFields = "Transaction"

const userFieldWithDraw userPrismaFields = "WithDraw"

type masterPaymentTypePrismaFields = prismaFields

const masterPaymentTypeFieldID masterPaymentTypePrismaFields = "id"

const masterPaymentTypeFieldName masterPaymentTypePrismaFields = "name"

const masterPaymentTypeFieldUserPaymentTypes masterPaymentTypePrismaFields = "userPaymentTypes"

type userPaymentTypesPrismaFields = prismaFields

const userPaymentTypesFieldID userPaymentTypesPrismaFields = "id"

const userPaymentTypesFieldUser userPaymentTypesPrismaFields = "user"

const userPaymentTypesFieldUserID userPaymentTypesPrismaFields = "userId"

const userPaymentTypesFieldMasterPaymentType userPaymentTypesPrismaFields = "masterPaymentType"

const userPaymentTypesFieldMasterPaymentTypeID userPaymentTypesPrismaFields = "masterPaymentTypeId"

type transactionPrismaFields = prismaFields

const transactionFieldID transactionPrismaFields = "id"

const transactionFieldUser transactionPrismaFields = "user"

const transactionFieldUserID transactionPrismaFields = "userId"

const transactionFieldToAddress transactionPrismaFields = "toAddress"

const transactionFieldFromAddress transactionPrismaFields = "fromAddress"

const transactionFieldCurrency transactionPrismaFields = "currency"

const transactionFieldTransactionHistory transactionPrismaFields = "TransactionHistory"

type transactionHistoryPrismaFields = prismaFields

const transactionHistoryFieldID transactionHistoryPrismaFields = "id"

const transactionHistoryFieldTransaction transactionHistoryPrismaFields = "transaction"

const transactionHistoryFieldTransactionID transactionHistoryPrismaFields = "transactionId"

const transactionHistoryFieldStatus transactionHistoryPrismaFields = "status"

type depositPrismaFields = prismaFields

const depositFieldID depositPrismaFields = "id"

const depositFieldUser depositPrismaFields = "user"

const depositFieldUserID depositPrismaFields = "userId"

const depositFieldAmount depositPrismaFields = "amount"

const depositFieldWithDraw depositPrismaFields = "WithDraw"

const depositFieldDepositTransaction depositPrismaFields = "DepositTransaction"

type withDrawPrismaFields = prismaFields

const withDrawFieldID withDrawPrismaFields = "id"

const withDrawFieldCharge withDrawPrismaFields = "charge"

const withDrawFieldUser withDrawPrismaFields = "user"

const withDrawFieldUserID withDrawPrismaFields = "userId"

const withDrawFieldDeposit withDrawPrismaFields = "deposit"

const withDrawFieldDepositID withDrawPrismaFields = "depositId"

type depositTransactionPrismaFields = prismaFields

const depositTransactionFieldID depositTransactionPrismaFields = "id"

const depositTransactionFieldAmount depositTransactionPrismaFields = "amount"

const depositTransactionFieldDeposit depositTransactionPrismaFields = "deposit"

const depositTransactionFieldDepositID depositTransactionPrismaFields = "depositId"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.MasterPaymentType = masterPaymentTypeMock{
		mock: m,
	}

	m.UserPaymentTypes = userPaymentTypesMock{
		mock: m,
	}

	m.Transaction = transactionMock{
		mock: m,
	}

	m.TransactionHistory = transactionHistoryMock{
		mock: m,
	}

	m.Deposit = depositMock{
		mock: m,
	}

	m.WithDraw = withDrawMock{
		mock: m,
	}

	m.DepositTransaction = depositTransactionMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	MasterPaymentType masterPaymentTypeMock

	UserPaymentTypes userPaymentTypesMock

	Transaction transactionMock

	TransactionHistory transactionHistoryMock

	Deposit depositMock

	WithDraw withDrawMock

	DepositTransaction depositTransactionMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type masterPaymentTypeMock struct {
	mock *Mock
}

type MasterPaymentTypeMockExpectParam interface {
	ExtractQuery() builder.Query
	masterPaymentTypeModel()
}

func (m *masterPaymentTypeMock) Expect(query MasterPaymentTypeMockExpectParam) *masterPaymentTypeMockExec {
	return &masterPaymentTypeMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type masterPaymentTypeMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *masterPaymentTypeMockExec) Returns(v MasterPaymentTypeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *masterPaymentTypeMockExec) ReturnsMany(v []MasterPaymentTypeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *masterPaymentTypeMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type userPaymentTypesMock struct {
	mock *Mock
}

type UserPaymentTypesMockExpectParam interface {
	ExtractQuery() builder.Query
	userPaymentTypesModel()
}

func (m *userPaymentTypesMock) Expect(query UserPaymentTypesMockExpectParam) *userPaymentTypesMockExec {
	return &userPaymentTypesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userPaymentTypesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userPaymentTypesMockExec) Returns(v UserPaymentTypesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userPaymentTypesMockExec) ReturnsMany(v []UserPaymentTypesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userPaymentTypesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type transactionMock struct {
	mock *Mock
}

type TransactionMockExpectParam interface {
	ExtractQuery() builder.Query
	transactionModel()
}

func (m *transactionMock) Expect(query TransactionMockExpectParam) *transactionMockExec {
	return &transactionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transactionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transactionMockExec) Returns(v TransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionMockExec) ReturnsMany(v []TransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type transactionHistoryMock struct {
	mock *Mock
}

type TransactionHistoryMockExpectParam interface {
	ExtractQuery() builder.Query
	transactionHistoryModel()
}

func (m *transactionHistoryMock) Expect(query TransactionHistoryMockExpectParam) *transactionHistoryMockExec {
	return &transactionHistoryMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transactionHistoryMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transactionHistoryMockExec) Returns(v TransactionHistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionHistoryMockExec) ReturnsMany(v []TransactionHistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionHistoryMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type depositMock struct {
	mock *Mock
}

type DepositMockExpectParam interface {
	ExtractQuery() builder.Query
	depositModel()
}

func (m *depositMock) Expect(query DepositMockExpectParam) *depositMockExec {
	return &depositMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type depositMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *depositMockExec) Returns(v DepositModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositMockExec) ReturnsMany(v []DepositModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type withDrawMock struct {
	mock *Mock
}

type WithDrawMockExpectParam interface {
	ExtractQuery() builder.Query
	withDrawModel()
}

func (m *withDrawMock) Expect(query WithDrawMockExpectParam) *withDrawMockExec {
	return &withDrawMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type withDrawMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *withDrawMockExec) Returns(v WithDrawModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *withDrawMockExec) ReturnsMany(v []WithDrawModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *withDrawMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type depositTransactionMock struct {
	mock *Mock
}

type DepositTransactionMockExpectParam interface {
	ExtractQuery() builder.Query
	depositTransactionModel()
}

func (m *depositTransactionMock) Expect(query DepositTransactionMockExpectParam) *depositTransactionMockExec {
	return &depositTransactionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type depositTransactionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *depositTransactionMockExec) Returns(v DepositTransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositTransactionMockExec) ReturnsMany(v []DepositTransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositTransactionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID         int      `json:"id"`
	CreatedAt  DateTime `json:"createdAt"`
	UpdatedAt  DateTime `json:"updatedAt"`
	Username   string   `json:"username"`
	SupabaseID string   `json:"supabaseId"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID         RawInt      `json:"id"`
	CreatedAt  RawDateTime `json:"createdAt"`
	UpdatedAt  RawDateTime `json:"updatedAt"`
	Username   RawString   `json:"username"`
	SupabaseID RawString   `json:"supabaseId"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	UserPaymentTypes []UserPaymentTypesModel `json:"UserPaymentTypes,omitempty"`
	Deposit          []DepositModel          `json:"Deposit,omitempty"`
	Transaction      []TransactionModel      `json:"Transaction,omitempty"`
	WithDraw         []WithDrawModel         `json:"WithDraw,omitempty"`
}

func (r UserModel) UserPaymentTypes() (value []UserPaymentTypesModel) {
	if r.RelationsUser.UserPaymentTypes == nil {
		panic("attempted to access userPaymentTypes but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.UserPaymentTypes
}

func (r UserModel) Deposit() (value []DepositModel) {
	if r.RelationsUser.Deposit == nil {
		panic("attempted to access deposit but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Deposit
}

func (r UserModel) Transaction() (value []TransactionModel) {
	if r.RelationsUser.Transaction == nil {
		panic("attempted to access transaction but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Transaction
}

func (r UserModel) WithDraw() (value []WithDrawModel) {
	if r.RelationsUser.WithDraw == nil {
		panic("attempted to access withDraw but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.WithDraw
}

// MasterPaymentTypeModel represents the MasterPaymentType model and is a wrapper for accessing fields and methods
type MasterPaymentTypeModel struct {
	InnerMasterPaymentType
	RelationsMasterPaymentType
}

// InnerMasterPaymentType holds the actual data
type InnerMasterPaymentType struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// RawMasterPaymentTypeModel is a struct for MasterPaymentType when used in raw queries
type RawMasterPaymentTypeModel struct {
	ID   RawInt    `json:"id"`
	Name RawString `json:"name"`
}

// RelationsMasterPaymentType holds the relation data separately
type RelationsMasterPaymentType struct {
	UserPaymentTypes []UserPaymentTypesModel `json:"userPaymentTypes,omitempty"`
}

func (r MasterPaymentTypeModel) UserPaymentTypes() (value []UserPaymentTypesModel) {
	if r.RelationsMasterPaymentType.UserPaymentTypes == nil {
		panic("attempted to access userPaymentTypes but did not fetch it using the .With() syntax")
	}
	return r.RelationsMasterPaymentType.UserPaymentTypes
}

// UserPaymentTypesModel represents the UserPaymentTypes model and is a wrapper for accessing fields and methods
type UserPaymentTypesModel struct {
	InnerUserPaymentTypes
	RelationsUserPaymentTypes
}

// InnerUserPaymentTypes holds the actual data
type InnerUserPaymentTypes struct {
	ID                  int `json:"id"`
	UserID              int `json:"userId"`
	MasterPaymentTypeID int `json:"masterPaymentTypeId"`
}

// RawUserPaymentTypesModel is a struct for UserPaymentTypes when used in raw queries
type RawUserPaymentTypesModel struct {
	ID                  RawInt `json:"id"`
	UserID              RawInt `json:"userId"`
	MasterPaymentTypeID RawInt `json:"masterPaymentTypeId"`
}

// RelationsUserPaymentTypes holds the relation data separately
type RelationsUserPaymentTypes struct {
	User              *UserModel              `json:"user,omitempty"`
	MasterPaymentType *MasterPaymentTypeModel `json:"masterPaymentType,omitempty"`
}

func (r UserPaymentTypesModel) User() (value *UserModel) {
	if r.RelationsUserPaymentTypes.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsUserPaymentTypes.User
}

func (r UserPaymentTypesModel) MasterPaymentType() (value *MasterPaymentTypeModel) {
	if r.RelationsUserPaymentTypes.MasterPaymentType == nil {
		panic("attempted to access masterPaymentType but did not fetch it using the .With() syntax")
	}
	return r.RelationsUserPaymentTypes.MasterPaymentType
}

// TransactionModel represents the Transaction model and is a wrapper for accessing fields and methods
type TransactionModel struct {
	InnerTransaction
	RelationsTransaction
}

// InnerTransaction holds the actual data
type InnerTransaction struct {
	ID          int    `json:"id"`
	UserID      int    `json:"userId"`
	ToAddress   string `json:"toAddress"`
	FromAddress string `json:"fromAddress"`
	Currency    string `json:"currency"`
}

// RawTransactionModel is a struct for Transaction when used in raw queries
type RawTransactionModel struct {
	ID          RawInt    `json:"id"`
	UserID      RawInt    `json:"userId"`
	ToAddress   RawString `json:"toAddress"`
	FromAddress RawString `json:"fromAddress"`
	Currency    RawString `json:"currency"`
}

// RelationsTransaction holds the relation data separately
type RelationsTransaction struct {
	User               *UserModel                `json:"user,omitempty"`
	TransactionHistory []TransactionHistoryModel `json:"TransactionHistory,omitempty"`
}

func (r TransactionModel) User() (value *UserModel) {
	if r.RelationsTransaction.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransaction.User
}

func (r TransactionModel) TransactionHistory() (value []TransactionHistoryModel) {
	if r.RelationsTransaction.TransactionHistory == nil {
		panic("attempted to access transactionHistory but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransaction.TransactionHistory
}

// TransactionHistoryModel represents the TransactionHistory model and is a wrapper for accessing fields and methods
type TransactionHistoryModel struct {
	InnerTransactionHistory
	RelationsTransactionHistory
}

// InnerTransactionHistory holds the actual data
type InnerTransactionHistory struct {
	ID            int    `json:"id"`
	TransactionID int    `json:"transactionId"`
	Status        string `json:"status"`
}

// RawTransactionHistoryModel is a struct for TransactionHistory when used in raw queries
type RawTransactionHistoryModel struct {
	ID            RawInt    `json:"id"`
	TransactionID RawInt    `json:"transactionId"`
	Status        RawString `json:"status"`
}

// RelationsTransactionHistory holds the relation data separately
type RelationsTransactionHistory struct {
	Transaction *TransactionModel `json:"transaction,omitempty"`
}

func (r TransactionHistoryModel) Transaction() (value *TransactionModel) {
	if r.RelationsTransactionHistory.Transaction == nil {
		panic("attempted to access transaction but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransactionHistory.Transaction
}

// DepositModel represents the Deposit model and is a wrapper for accessing fields and methods
type DepositModel struct {
	InnerDeposit
	RelationsDeposit
}

// InnerDeposit holds the actual data
type InnerDeposit struct {
	ID     int `json:"id"`
	UserID int `json:"userId"`
	Amount int `json:"amount"`
}

// RawDepositModel is a struct for Deposit when used in raw queries
type RawDepositModel struct {
	ID     RawInt `json:"id"`
	UserID RawInt `json:"userId"`
	Amount RawInt `json:"amount"`
}

// RelationsDeposit holds the relation data separately
type RelationsDeposit struct {
	User               *UserModel                `json:"user,omitempty"`
	WithDraw           []WithDrawModel           `json:"WithDraw,omitempty"`
	DepositTransaction []DepositTransactionModel `json:"DepositTransaction,omitempty"`
}

func (r DepositModel) User() (value *UserModel) {
	if r.RelationsDeposit.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsDeposit.User
}

func (r DepositModel) WithDraw() (value []WithDrawModel) {
	if r.RelationsDeposit.WithDraw == nil {
		panic("attempted to access withDraw but did not fetch it using the .With() syntax")
	}
	return r.RelationsDeposit.WithDraw
}

func (r DepositModel) DepositTransaction() (value []DepositTransactionModel) {
	if r.RelationsDeposit.DepositTransaction == nil {
		panic("attempted to access depositTransaction but did not fetch it using the .With() syntax")
	}
	return r.RelationsDeposit.DepositTransaction
}

// WithDrawModel represents the WithDraw model and is a wrapper for accessing fields and methods
type WithDrawModel struct {
	InnerWithDraw
	RelationsWithDraw
}

// InnerWithDraw holds the actual data
type InnerWithDraw struct {
	ID        int `json:"id"`
	Charge    int `json:"charge"`
	UserID    int `json:"userId"`
	DepositID int `json:"depositId"`
}

// RawWithDrawModel is a struct for WithDraw when used in raw queries
type RawWithDrawModel struct {
	ID        RawInt `json:"id"`
	Charge    RawInt `json:"charge"`
	UserID    RawInt `json:"userId"`
	DepositID RawInt `json:"depositId"`
}

// RelationsWithDraw holds the relation data separately
type RelationsWithDraw struct {
	User    *UserModel    `json:"user,omitempty"`
	Deposit *DepositModel `json:"deposit,omitempty"`
}

func (r WithDrawModel) User() (value *UserModel) {
	if r.RelationsWithDraw.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsWithDraw.User
}

func (r WithDrawModel) Deposit() (value *DepositModel) {
	if r.RelationsWithDraw.Deposit == nil {
		panic("attempted to access deposit but did not fetch it using the .With() syntax")
	}
	return r.RelationsWithDraw.Deposit
}

// DepositTransactionModel represents the DepositTransaction model and is a wrapper for accessing fields and methods
type DepositTransactionModel struct {
	InnerDepositTransaction
	RelationsDepositTransaction
}

// InnerDepositTransaction holds the actual data
type InnerDepositTransaction struct {
	ID        int `json:"id"`
	Amount    int `json:"amount"`
	DepositID int `json:"depositId"`
}

// RawDepositTransactionModel is a struct for DepositTransaction when used in raw queries
type RawDepositTransactionModel struct {
	ID        RawInt `json:"id"`
	Amount    RawInt `json:"amount"`
	DepositID RawInt `json:"depositId"`
}

// RelationsDepositTransaction holds the relation data separately
type RelationsDepositTransaction struct {
	Deposit *DepositModel `json:"deposit,omitempty"`
}

func (r DepositTransactionModel) Deposit() (value *DepositModel) {
	if r.RelationsDepositTransaction.Deposit == nil {
		panic("attempted to access deposit but did not fetch it using the .With() syntax")
	}
	return r.RelationsDepositTransaction.Deposit
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDInt

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	// Username
	//
	// @required
	Username userQueryUsernameString

	// SupabaseID
	//
	// @required
	SupabaseID userQuerySupabaseIDString

	UserPaymentTypes userQueryUserPaymentTypesRelations

	Deposit userQueryDepositRelations

	Transaction userQueryTransactionRelations

	WithDraw userQueryWithDrawRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDInt struct{}

// Set the required value of ID
func (r userQueryIDInt) Set(value int) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDInt) SetIfPresent(value *Int) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r userQueryIDInt) Increment(value int) userSetParam {
	return userSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) IncrementIfPresent(value *int) userSetParam {
	if value == nil {
		return userSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r userQueryIDInt) Decrement(value int) userSetParam {
	return userSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) DecrementIfPresent(value *int) userSetParam {
	if value == nil {
		return userSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r userQueryIDInt) Multiply(value int) userSetParam {
	return userSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) MultiplyIfPresent(value *int) userSetParam {
	if value == nil {
		return userSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r userQueryIDInt) Divide(value int) userSetParam {
	return userSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) DivideIfPresent(value *int) userSetParam {
	if value == nil {
		return userSetParam{}
	}
	return r.Divide(*value)
}

func (r userQueryIDInt) Equals(value int) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) EqualsIfPresent(value *int) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDInt) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDInt) Cursor(cursor int) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDInt) In(value []int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) InIfPresent(value []int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDInt) NotIn(value []int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) NotInIfPresent(value []int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDInt) Lt(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) LtIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDInt) Lte(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) LteIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDInt) Gt(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) GtIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDInt) Gte(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) GteIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDInt) Not(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDInt) NotIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryIDInt) LT(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryIDInt) LTIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userQueryIDInt) LTE(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryIDInt) LTEIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userQueryIDInt) GT(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryIDInt) GTIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userQueryIDInt) GTE(value int) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryIDInt) GTEIfPresent(value *int) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.GTE(*value)
}

func (r userQueryIDInt) Field() userPrismaFields {
	return userFieldID
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryCreatedAtDateTime) Field() userPrismaFields {
	return userFieldCreatedAt
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryUpdatedAtDateTime) Field() userPrismaFields {
	return userFieldUpdatedAt
}

// base struct
type userQueryUsernameString struct{}

// Set the required value of Username
func (r userQueryUsernameString) Set(value string) userWithPrismaUsernameSetParam {

	return userWithPrismaUsernameSetParam{
		data: builder.Field{
			Name:  "username",
			Value: value,
		},
	}

}

// Set the optional value of Username dynamically
func (r userQueryUsernameString) SetIfPresent(value *String) userWithPrismaUsernameSetParam {
	if value == nil {
		return userWithPrismaUsernameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUsernameString) Equals(value string) userWithPrismaUsernameEqualsParam {

	return userWithPrismaUsernameEqualsParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EqualsIfPresent(value *string) userWithPrismaUsernameEqualsParam {
	if value == nil {
		return userWithPrismaUsernameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUsernameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "username",
			Value: direction,
		},
	}
}

func (r userQueryUsernameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "username",
			Value: cursor,
		},
	}
}

func (r userQueryUsernameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUsernameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUsernameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUsernameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUsernameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUsernameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUsernameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryUsernameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryUsernameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryUsernameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryUsernameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUsernameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryUsernameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryUsernameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryUsernameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "username",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryUsernameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryUsernameString) Field() userPrismaFields {
	return userFieldUsername
}

// base struct
type userQuerySupabaseIDString struct{}

// Set the required value of SupabaseID
func (r userQuerySupabaseIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "supabaseId",
			Value: value,
		},
	}

}

// Set the optional value of SupabaseID dynamically
func (r userQuerySupabaseIDString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQuerySupabaseIDString) Equals(value string) userWithPrismaSupabaseIDEqualsParam {

	return userWithPrismaSupabaseIDEqualsParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) EqualsIfPresent(value *string) userWithPrismaSupabaseIDEqualsParam {
	if value == nil {
		return userWithPrismaSupabaseIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQuerySupabaseIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "supabaseId",
			Value: direction,
		},
	}
}

func (r userQuerySupabaseIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "supabaseId",
			Value: cursor,
		},
	}
}

func (r userQuerySupabaseIDString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQuerySupabaseIDString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQuerySupabaseIDString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQuerySupabaseIDString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQuerySupabaseIDString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQuerySupabaseIDString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQuerySupabaseIDString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQuerySupabaseIDString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQuerySupabaseIDString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQuerySupabaseIDString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQuerySupabaseIDString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQuerySupabaseIDString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQuerySupabaseIDString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQuerySupabaseIDString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQuerySupabaseIDString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "supabaseId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQuerySupabaseIDString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQuerySupabaseIDString) Field() userPrismaFields {
	return userFieldSupabaseID
}

// base struct
type userQueryUserPaymentTypesUserPaymentTypes struct{}

type userQueryUserPaymentTypesRelations struct{}

// User -> UserPaymentTypes
//
// @relation
// @required
func (userQueryUserPaymentTypesRelations) Some(
	params ...UserPaymentTypesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "UserPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> UserPaymentTypes
//
// @relation
// @required
func (userQueryUserPaymentTypesRelations) Every(
	params ...UserPaymentTypesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "UserPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> UserPaymentTypes
//
// @relation
// @required
func (userQueryUserPaymentTypesRelations) None(
	params ...UserPaymentTypesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "UserPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryUserPaymentTypesRelations) Fetch(

	params ...UserPaymentTypesWhereParam,

) userToUserPaymentTypesFindMany {
	var v userToUserPaymentTypesFindMany

	v.query.Operation = "query"
	v.query.Method = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryUserPaymentTypesRelations) Link(
	params ...UserPaymentTypesWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "UserPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryUserPaymentTypesRelations) Unlink(
	params ...UserPaymentTypesWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "UserPaymentTypes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryUserPaymentTypesUserPaymentTypes) Field() userPrismaFields {
	return userFieldUserPaymentTypes
}

// base struct
type userQueryDepositDeposit struct{}

type userQueryDepositRelations struct{}

// User -> Deposit
//
// @relation
// @required
func (userQueryDepositRelations) Some(
	params ...DepositWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Deposit",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Deposit
//
// @relation
// @required
func (userQueryDepositRelations) Every(
	params ...DepositWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Deposit",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Deposit
//
// @relation
// @required
func (userQueryDepositRelations) None(
	params ...DepositWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Deposit",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryDepositRelations) Fetch(

	params ...DepositWhereParam,

) userToDepositFindMany {
	var v userToDepositFindMany

	v.query.Operation = "query"
	v.query.Method = "Deposit"
	v.query.Outputs = depositOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryDepositRelations) Link(
	params ...DepositWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Deposit",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryDepositRelations) Unlink(
	params ...DepositWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Deposit",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryDepositDeposit) Field() userPrismaFields {
	return userFieldDeposit
}

// base struct
type userQueryTransactionTransaction struct{}

type userQueryTransactionRelations struct{}

// User -> Transaction
//
// @relation
// @required
func (userQueryTransactionRelations) Some(
	params ...TransactionWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Transaction",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Transaction
//
// @relation
// @required
func (userQueryTransactionRelations) Every(
	params ...TransactionWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Transaction",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Transaction
//
// @relation
// @required
func (userQueryTransactionRelations) None(
	params ...TransactionWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "Transaction",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryTransactionRelations) Fetch(

	params ...TransactionWhereParam,

) userToTransactionFindMany {
	var v userToTransactionFindMany

	v.query.Operation = "query"
	v.query.Method = "Transaction"
	v.query.Outputs = transactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryTransactionRelations) Link(
	params ...TransactionWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "Transaction",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryTransactionRelations) Unlink(
	params ...TransactionWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "Transaction",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryTransactionTransaction) Field() userPrismaFields {
	return userFieldTransaction
}

// base struct
type userQueryWithDrawWithDraw struct{}

type userQueryWithDrawRelations struct{}

// User -> WithDraw
//
// @relation
// @required
func (userQueryWithDrawRelations) Some(
	params ...WithDrawWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> WithDraw
//
// @relation
// @required
func (userQueryWithDrawRelations) Every(
	params ...WithDrawWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> WithDraw
//
// @relation
// @required
func (userQueryWithDrawRelations) None(
	params ...WithDrawWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryWithDrawRelations) Fetch(

	params ...WithDrawWhereParam,

) userToWithDrawFindMany {
	var v userToWithDrawFindMany

	v.query.Operation = "query"
	v.query.Method = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryWithDrawRelations) Link(
	params ...WithDrawWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryWithDrawRelations) Unlink(
	params ...WithDrawWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryWithDrawWithDraw) Field() userPrismaFields {
	return userFieldWithDraw
}

// MasterPaymentType acts as a namespaces to access query methods for the MasterPaymentType model
var MasterPaymentType = masterPaymentTypeQuery{}

// masterPaymentTypeQuery exposes query functions for the masterPaymentType model
type masterPaymentTypeQuery struct {

	// ID
	//
	// @required
	ID masterPaymentTypeQueryIDInt

	// Name
	//
	// @required
	Name masterPaymentTypeQueryNameString

	UserPaymentTypes masterPaymentTypeQueryUserPaymentTypesRelations
}

func (masterPaymentTypeQuery) Not(params ...MasterPaymentTypeWhereParam) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (masterPaymentTypeQuery) Or(params ...MasterPaymentTypeWhereParam) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (masterPaymentTypeQuery) And(params ...MasterPaymentTypeWhereParam) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type masterPaymentTypeQueryIDInt struct{}

// Set the required value of ID
func (r masterPaymentTypeQueryIDInt) Set(value int) masterPaymentTypeSetParam {

	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r masterPaymentTypeQueryIDInt) SetIfPresent(value *Int) masterPaymentTypeSetParam {
	if value == nil {
		return masterPaymentTypeSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r masterPaymentTypeQueryIDInt) Increment(value int) masterPaymentTypeSetParam {
	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) IncrementIfPresent(value *int) masterPaymentTypeSetParam {
	if value == nil {
		return masterPaymentTypeSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r masterPaymentTypeQueryIDInt) Decrement(value int) masterPaymentTypeSetParam {
	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) DecrementIfPresent(value *int) masterPaymentTypeSetParam {
	if value == nil {
		return masterPaymentTypeSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r masterPaymentTypeQueryIDInt) Multiply(value int) masterPaymentTypeSetParam {
	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) MultiplyIfPresent(value *int) masterPaymentTypeSetParam {
	if value == nil {
		return masterPaymentTypeSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r masterPaymentTypeQueryIDInt) Divide(value int) masterPaymentTypeSetParam {
	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) DivideIfPresent(value *int) masterPaymentTypeSetParam {
	if value == nil {
		return masterPaymentTypeSetParam{}
	}
	return r.Divide(*value)
}

func (r masterPaymentTypeQueryIDInt) Equals(value int) masterPaymentTypeWithPrismaIDEqualsUniqueParam {

	return masterPaymentTypeWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) EqualsIfPresent(value *int) masterPaymentTypeWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return masterPaymentTypeWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r masterPaymentTypeQueryIDInt) Order(direction SortOrder) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r masterPaymentTypeQueryIDInt) Cursor(cursor int) masterPaymentTypeCursorParam {
	return masterPaymentTypeCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r masterPaymentTypeQueryIDInt) In(value []int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) InIfPresent(value []int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.In(value)
}

func (r masterPaymentTypeQueryIDInt) NotIn(value []int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) NotInIfPresent(value []int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.NotIn(value)
}

func (r masterPaymentTypeQueryIDInt) Lt(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) LtIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.Lt(*value)
}

func (r masterPaymentTypeQueryIDInt) Lte(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) LteIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.Lte(*value)
}

func (r masterPaymentTypeQueryIDInt) Gt(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) GtIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.Gt(*value)
}

func (r masterPaymentTypeQueryIDInt) Gte(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) GteIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.Gte(*value)
}

func (r masterPaymentTypeQueryIDInt) Not(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryIDInt) NotIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r masterPaymentTypeQueryIDInt) LT(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r masterPaymentTypeQueryIDInt) LTIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r masterPaymentTypeQueryIDInt) LTE(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r masterPaymentTypeQueryIDInt) LTEIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r masterPaymentTypeQueryIDInt) GT(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r masterPaymentTypeQueryIDInt) GTIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r masterPaymentTypeQueryIDInt) GTE(value int) masterPaymentTypeParamUnique {
	return masterPaymentTypeParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r masterPaymentTypeQueryIDInt) GTEIfPresent(value *int) masterPaymentTypeParamUnique {
	if value == nil {
		return masterPaymentTypeParamUnique{}
	}
	return r.GTE(*value)
}

func (r masterPaymentTypeQueryIDInt) Field() masterPaymentTypePrismaFields {
	return masterPaymentTypeFieldID
}

// base struct
type masterPaymentTypeQueryNameString struct{}

// Set the required value of Name
func (r masterPaymentTypeQueryNameString) Set(value string) masterPaymentTypeWithPrismaNameSetParam {

	return masterPaymentTypeWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r masterPaymentTypeQueryNameString) SetIfPresent(value *String) masterPaymentTypeWithPrismaNameSetParam {
	if value == nil {
		return masterPaymentTypeWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r masterPaymentTypeQueryNameString) Equals(value string) masterPaymentTypeWithPrismaNameEqualsParam {

	return masterPaymentTypeWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) EqualsIfPresent(value *string) masterPaymentTypeWithPrismaNameEqualsParam {
	if value == nil {
		return masterPaymentTypeWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r masterPaymentTypeQueryNameString) Order(direction SortOrder) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r masterPaymentTypeQueryNameString) Cursor(cursor string) masterPaymentTypeCursorParam {
	return masterPaymentTypeCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r masterPaymentTypeQueryNameString) In(value []string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) InIfPresent(value []string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.In(value)
}

func (r masterPaymentTypeQueryNameString) NotIn(value []string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) NotInIfPresent(value []string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r masterPaymentTypeQueryNameString) Lt(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) LtIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r masterPaymentTypeQueryNameString) Lte(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) LteIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r masterPaymentTypeQueryNameString) Gt(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) GtIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r masterPaymentTypeQueryNameString) Gte(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) GteIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r masterPaymentTypeQueryNameString) Contains(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) ContainsIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r masterPaymentTypeQueryNameString) StartsWith(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) StartsWithIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r masterPaymentTypeQueryNameString) EndsWith(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) EndsWithIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r masterPaymentTypeQueryNameString) Mode(value QueryMode) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) ModeIfPresent(value *QueryMode) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r masterPaymentTypeQueryNameString) Not(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryNameString) NotIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r masterPaymentTypeQueryNameString) HasPrefix(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r masterPaymentTypeQueryNameString) HasPrefixIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r masterPaymentTypeQueryNameString) HasSuffix(value string) masterPaymentTypeDefaultParam {
	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r masterPaymentTypeQueryNameString) HasSuffixIfPresent(value *string) masterPaymentTypeDefaultParam {
	if value == nil {
		return masterPaymentTypeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r masterPaymentTypeQueryNameString) Field() masterPaymentTypePrismaFields {
	return masterPaymentTypeFieldName
}

// base struct
type masterPaymentTypeQueryUserPaymentTypesUserPaymentTypes struct{}

type masterPaymentTypeQueryUserPaymentTypesRelations struct{}

// MasterPaymentType -> UserPaymentTypes
//
// @relation
// @required
func (masterPaymentTypeQueryUserPaymentTypesRelations) Some(
	params ...UserPaymentTypesWhereParam,
) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "userPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// MasterPaymentType -> UserPaymentTypes
//
// @relation
// @required
func (masterPaymentTypeQueryUserPaymentTypesRelations) Every(
	params ...UserPaymentTypesWhereParam,
) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "userPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// MasterPaymentType -> UserPaymentTypes
//
// @relation
// @required
func (masterPaymentTypeQueryUserPaymentTypesRelations) None(
	params ...UserPaymentTypesWhereParam,
) masterPaymentTypeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeDefaultParam{
		data: builder.Field{
			Name: "userPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (masterPaymentTypeQueryUserPaymentTypesRelations) Fetch(

	params ...UserPaymentTypesWhereParam,

) masterPaymentTypeToUserPaymentTypesFindMany {
	var v masterPaymentTypeToUserPaymentTypesFindMany

	v.query.Operation = "query"
	v.query.Method = "userPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r masterPaymentTypeQueryUserPaymentTypesRelations) Link(
	params ...UserPaymentTypesWhereParam,
) masterPaymentTypeSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "userPaymentTypes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r masterPaymentTypeQueryUserPaymentTypesRelations) Unlink(
	params ...UserPaymentTypesWhereParam,
) masterPaymentTypeSetParam {
	var v masterPaymentTypeSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = masterPaymentTypeSetParam{
		data: builder.Field{
			Name: "userPaymentTypes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r masterPaymentTypeQueryUserPaymentTypesUserPaymentTypes) Field() masterPaymentTypePrismaFields {
	return masterPaymentTypeFieldUserPaymentTypes
}

// UserPaymentTypes acts as a namespaces to access query methods for the UserPaymentTypes model
var UserPaymentTypes = userPaymentTypesQuery{}

// userPaymentTypesQuery exposes query functions for the userPaymentTypes model
type userPaymentTypesQuery struct {

	// ID
	//
	// @required
	ID userPaymentTypesQueryIDInt

	User userPaymentTypesQueryUserRelations

	// UserID
	//
	// @required
	UserID userPaymentTypesQueryUserIDInt

	MasterPaymentType userPaymentTypesQueryMasterPaymentTypeRelations

	// MasterPaymentTypeID
	//
	// @required
	MasterPaymentTypeID userPaymentTypesQueryMasterPaymentTypeIDInt
}

func (userPaymentTypesQuery) Not(params ...UserPaymentTypesWhereParam) userPaymentTypesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userPaymentTypesQuery) Or(params ...UserPaymentTypesWhereParam) userPaymentTypesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userPaymentTypesQuery) And(params ...UserPaymentTypesWhereParam) userPaymentTypesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userPaymentTypesQueryIDInt struct{}

// Set the required value of ID
func (r userPaymentTypesQueryIDInt) Set(value int) userPaymentTypesSetParam {

	return userPaymentTypesSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userPaymentTypesQueryIDInt) SetIfPresent(value *Int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r userPaymentTypesQueryIDInt) Increment(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) IncrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r userPaymentTypesQueryIDInt) Decrement(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) DecrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r userPaymentTypesQueryIDInt) Multiply(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) MultiplyIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r userPaymentTypesQueryIDInt) Divide(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) DivideIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Divide(*value)
}

func (r userPaymentTypesQueryIDInt) Equals(value int) userPaymentTypesWithPrismaIDEqualsUniqueParam {

	return userPaymentTypesWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) EqualsIfPresent(value *int) userPaymentTypesWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userPaymentTypesWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userPaymentTypesQueryIDInt) Order(direction SortOrder) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userPaymentTypesQueryIDInt) Cursor(cursor int) userPaymentTypesCursorParam {
	return userPaymentTypesCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userPaymentTypesQueryIDInt) In(value []int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) InIfPresent(value []int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.In(value)
}

func (r userPaymentTypesQueryIDInt) NotIn(value []int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) NotInIfPresent(value []int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.NotIn(value)
}

func (r userPaymentTypesQueryIDInt) Lt(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) LtIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.Lt(*value)
}

func (r userPaymentTypesQueryIDInt) Lte(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) LteIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.Lte(*value)
}

func (r userPaymentTypesQueryIDInt) Gt(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) GtIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.Gt(*value)
}

func (r userPaymentTypesQueryIDInt) Gte(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) GteIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.Gte(*value)
}

func (r userPaymentTypesQueryIDInt) Not(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryIDInt) NotIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userPaymentTypesQueryIDInt) LT(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userPaymentTypesQueryIDInt) LTIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userPaymentTypesQueryIDInt) LTE(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userPaymentTypesQueryIDInt) LTEIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userPaymentTypesQueryIDInt) GT(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userPaymentTypesQueryIDInt) GTIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userPaymentTypesQueryIDInt) GTE(value int) userPaymentTypesParamUnique {
	return userPaymentTypesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userPaymentTypesQueryIDInt) GTEIfPresent(value *int) userPaymentTypesParamUnique {
	if value == nil {
		return userPaymentTypesParamUnique{}
	}
	return r.GTE(*value)
}

func (r userPaymentTypesQueryIDInt) Field() userPaymentTypesPrismaFields {
	return userPaymentTypesFieldID
}

// base struct
type userPaymentTypesQueryUserUser struct{}

type userPaymentTypesQueryUserRelations struct{}

// UserPaymentTypes -> User
//
// @relation
// @required
func (userPaymentTypesQueryUserRelations) Where(
	params ...UserWhereParam,
) userPaymentTypesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (userPaymentTypesQueryUserRelations) Fetch() userPaymentTypesToUserFindUnique {
	var v userPaymentTypesToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r userPaymentTypesQueryUserRelations) Link(
	params UserWhereParam,
) userPaymentTypesWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return userPaymentTypesWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return userPaymentTypesWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserRelations) Unlink() userPaymentTypesWithPrismaUserSetParam {
	var v userPaymentTypesWithPrismaUserSetParam

	v = userPaymentTypesWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r userPaymentTypesQueryUserUser) Field() userPaymentTypesPrismaFields {
	return userPaymentTypesFieldUser
}

// base struct
type userPaymentTypesQueryUserIDInt struct{}

// Set the required value of UserID
func (r userPaymentTypesQueryUserIDInt) Set(value int) userPaymentTypesSetParam {

	return userPaymentTypesSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r userPaymentTypesQueryUserIDInt) SetIfPresent(value *Int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r userPaymentTypesQueryUserIDInt) Increment(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) IncrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r userPaymentTypesQueryUserIDInt) Decrement(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) DecrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r userPaymentTypesQueryUserIDInt) Multiply(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) MultiplyIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r userPaymentTypesQueryUserIDInt) Divide(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) DivideIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Divide(*value)
}

func (r userPaymentTypesQueryUserIDInt) Equals(value int) userPaymentTypesWithPrismaUserIDEqualsParam {

	return userPaymentTypesWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) EqualsIfPresent(value *int) userPaymentTypesWithPrismaUserIDEqualsParam {
	if value == nil {
		return userPaymentTypesWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userPaymentTypesQueryUserIDInt) Order(direction SortOrder) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) Cursor(cursor int) userPaymentTypesCursorParam {
	return userPaymentTypesCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) In(value []int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) InIfPresent(value []int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.In(value)
}

func (r userPaymentTypesQueryUserIDInt) NotIn(value []int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) NotInIfPresent(value []int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userPaymentTypesQueryUserIDInt) Lt(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) LtIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userPaymentTypesQueryUserIDInt) Lte(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) LteIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userPaymentTypesQueryUserIDInt) Gt(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) GtIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userPaymentTypesQueryUserIDInt) Gte(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) GteIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userPaymentTypesQueryUserIDInt) Not(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryUserIDInt) NotIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userPaymentTypesQueryUserIDInt) LT(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userPaymentTypesQueryUserIDInt) LTIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userPaymentTypesQueryUserIDInt) LTE(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userPaymentTypesQueryUserIDInt) LTEIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userPaymentTypesQueryUserIDInt) GT(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userPaymentTypesQueryUserIDInt) GTIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userPaymentTypesQueryUserIDInt) GTE(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userPaymentTypesQueryUserIDInt) GTEIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.GTE(*value)
}

func (r userPaymentTypesQueryUserIDInt) Field() userPaymentTypesPrismaFields {
	return userPaymentTypesFieldUserID
}

// base struct
type userPaymentTypesQueryMasterPaymentTypeMasterPaymentType struct{}

type userPaymentTypesQueryMasterPaymentTypeRelations struct{}

// UserPaymentTypes -> MasterPaymentType
//
// @relation
// @required
func (userPaymentTypesQueryMasterPaymentTypeRelations) Where(
	params ...MasterPaymentTypeWhereParam,
) userPaymentTypesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentType",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (userPaymentTypesQueryMasterPaymentTypeRelations) Fetch() userPaymentTypesToMasterPaymentTypeFindUnique {
	var v userPaymentTypesToMasterPaymentTypeFindUnique

	v.query.Operation = "query"
	v.query.Method = "masterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	return v
}

func (r userPaymentTypesQueryMasterPaymentTypeRelations) Link(
	params MasterPaymentTypeWhereParam,
) userPaymentTypesWithPrismaMasterPaymentTypeSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return userPaymentTypesWithPrismaMasterPaymentTypeSetParam{}
	}

	fields = append(fields, f)

	return userPaymentTypesWithPrismaMasterPaymentTypeSetParam{
		data: builder.Field{
			Name: "masterPaymentType",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeRelations) Unlink() userPaymentTypesWithPrismaMasterPaymentTypeSetParam {
	var v userPaymentTypesWithPrismaMasterPaymentTypeSetParam

	v = userPaymentTypesWithPrismaMasterPaymentTypeSetParam{
		data: builder.Field{
			Name: "masterPaymentType",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r userPaymentTypesQueryMasterPaymentTypeMasterPaymentType) Field() userPaymentTypesPrismaFields {
	return userPaymentTypesFieldMasterPaymentType
}

// base struct
type userPaymentTypesQueryMasterPaymentTypeIDInt struct{}

// Set the required value of MasterPaymentTypeID
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Set(value int) userPaymentTypesSetParam {

	return userPaymentTypesSetParam{
		data: builder.Field{
			Name:  "masterPaymentTypeId",
			Value: value,
		},
	}

}

// Set the optional value of MasterPaymentTypeID dynamically
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) SetIfPresent(value *Int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of MasterPaymentTypeID
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Increment(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) IncrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of MasterPaymentTypeID
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Decrement(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) DecrementIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of MasterPaymentTypeID
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Multiply(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) MultiplyIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of MasterPaymentTypeID
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Divide(value int) userPaymentTypesSetParam {
	return userPaymentTypesSetParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) DivideIfPresent(value *int) userPaymentTypesSetParam {
	if value == nil {
		return userPaymentTypesSetParam{}
	}
	return r.Divide(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Equals(value int) userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam {

	return userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) EqualsIfPresent(value *int) userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam {
	if value == nil {
		return userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Order(direction SortOrder) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name:  "masterPaymentTypeId",
			Value: direction,
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Cursor(cursor int) userPaymentTypesCursorParam {
	return userPaymentTypesCursorParam{
		data: builder.Field{
			Name:  "masterPaymentTypeId",
			Value: cursor,
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) In(value []int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) InIfPresent(value []int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.In(value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) NotIn(value []int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) NotInIfPresent(value []int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Lt(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LtIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Lte(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LteIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Gt(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GtIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Gte(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GteIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Not(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) NotIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LT(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LTIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LTE(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) LTEIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GT(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GTIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GTE(value int) userPaymentTypesDefaultParam {
	return userPaymentTypesDefaultParam{
		data: builder.Field{
			Name: "masterPaymentTypeId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userPaymentTypesQueryMasterPaymentTypeIDInt) GTEIfPresent(value *int) userPaymentTypesDefaultParam {
	if value == nil {
		return userPaymentTypesDefaultParam{}
	}
	return r.GTE(*value)
}

func (r userPaymentTypesQueryMasterPaymentTypeIDInt) Field() userPaymentTypesPrismaFields {
	return userPaymentTypesFieldMasterPaymentTypeID
}

// Transaction acts as a namespaces to access query methods for the Transaction model
var Transaction = transactionQuery{}

// transactionQuery exposes query functions for the transaction model
type transactionQuery struct {

	// ID
	//
	// @required
	ID transactionQueryIDInt

	User transactionQueryUserRelations

	// UserID
	//
	// @required
	UserID transactionQueryUserIDInt

	// ToAddress
	//
	// @required
	ToAddress transactionQueryToAddressString

	// FromAddress
	//
	// @required
	FromAddress transactionQueryFromAddressString

	// Currency
	//
	// @required
	Currency transactionQueryCurrencyString

	TransactionHistory transactionQueryTransactionHistoryRelations
}

func (transactionQuery) Not(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionQuery) Or(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionQuery) And(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transactionQueryIDInt struct{}

// Set the required value of ID
func (r transactionQueryIDInt) Set(value int) transactionSetParam {

	return transactionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transactionQueryIDInt) SetIfPresent(value *Int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r transactionQueryIDInt) Increment(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) IncrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r transactionQueryIDInt) Decrement(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) DecrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r transactionQueryIDInt) Multiply(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) MultiplyIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r transactionQueryIDInt) Divide(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) DivideIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Divide(*value)
}

func (r transactionQueryIDInt) Equals(value int) transactionWithPrismaIDEqualsUniqueParam {

	return transactionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) EqualsIfPresent(value *int) transactionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transactionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryIDInt) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transactionQueryIDInt) Cursor(cursor int) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transactionQueryIDInt) In(value []int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) InIfPresent(value []int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.In(value)
}

func (r transactionQueryIDInt) NotIn(value []int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) NotInIfPresent(value []int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.NotIn(value)
}

func (r transactionQueryIDInt) Lt(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) LtIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Lt(*value)
}

func (r transactionQueryIDInt) Lte(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) LteIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Lte(*value)
}

func (r transactionQueryIDInt) Gt(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) GtIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Gt(*value)
}

func (r transactionQueryIDInt) Gte(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) GteIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Gte(*value)
}

func (r transactionQueryIDInt) Not(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) NotIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionQueryIDInt) LT(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionQueryIDInt) LTIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionQueryIDInt) LTE(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionQueryIDInt) LTEIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionQueryIDInt) GT(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionQueryIDInt) GTIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionQueryIDInt) GTE(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionQueryIDInt) GTEIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.GTE(*value)
}

func (r transactionQueryIDInt) Field() transactionPrismaFields {
	return transactionFieldID
}

// base struct
type transactionQueryUserUser struct{}

type transactionQueryUserRelations struct{}

// Transaction -> User
//
// @relation
// @required
func (transactionQueryUserRelations) Where(
	params ...UserWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (transactionQueryUserRelations) Fetch() transactionToUserFindUnique {
	var v transactionToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r transactionQueryUserRelations) Link(
	params UserWhereParam,
) transactionWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return transactionWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return transactionWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r transactionQueryUserRelations) Unlink() transactionWithPrismaUserSetParam {
	var v transactionWithPrismaUserSetParam

	v = transactionWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r transactionQueryUserUser) Field() transactionPrismaFields {
	return transactionFieldUser
}

// base struct
type transactionQueryUserIDInt struct{}

// Set the required value of UserID
func (r transactionQueryUserIDInt) Set(value int) transactionSetParam {

	return transactionSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r transactionQueryUserIDInt) SetIfPresent(value *Int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r transactionQueryUserIDInt) Increment(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) IncrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r transactionQueryUserIDInt) Decrement(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) DecrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r transactionQueryUserIDInt) Multiply(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) MultiplyIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r transactionQueryUserIDInt) Divide(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) DivideIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Divide(*value)
}

func (r transactionQueryUserIDInt) Equals(value int) transactionWithPrismaUserIDEqualsParam {

	return transactionWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) EqualsIfPresent(value *int) transactionWithPrismaUserIDEqualsParam {
	if value == nil {
		return transactionWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryUserIDInt) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r transactionQueryUserIDInt) Cursor(cursor int) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r transactionQueryUserIDInt) In(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) InIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryUserIDInt) NotIn(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) NotInIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryUserIDInt) Lt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) LtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryUserIDInt) Lte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) LteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryUserIDInt) Gt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) GtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryUserIDInt) Gte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) GteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryUserIDInt) Not(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) NotIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionQueryUserIDInt) LT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionQueryUserIDInt) LTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionQueryUserIDInt) LTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionQueryUserIDInt) LTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionQueryUserIDInt) GT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionQueryUserIDInt) GTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionQueryUserIDInt) GTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionQueryUserIDInt) GTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r transactionQueryUserIDInt) Field() transactionPrismaFields {
	return transactionFieldUserID
}

// base struct
type transactionQueryToAddressString struct{}

// Set the required value of ToAddress
func (r transactionQueryToAddressString) Set(value string) transactionWithPrismaToAddressSetParam {

	return transactionWithPrismaToAddressSetParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: value,
		},
	}

}

// Set the optional value of ToAddress dynamically
func (r transactionQueryToAddressString) SetIfPresent(value *String) transactionWithPrismaToAddressSetParam {
	if value == nil {
		return transactionWithPrismaToAddressSetParam{}
	}

	return r.Set(*value)
}

func (r transactionQueryToAddressString) Equals(value string) transactionWithPrismaToAddressEqualsParam {

	return transactionWithPrismaToAddressEqualsParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) EqualsIfPresent(value *string) transactionWithPrismaToAddressEqualsParam {
	if value == nil {
		return transactionWithPrismaToAddressEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryToAddressString) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: direction,
		},
	}
}

func (r transactionQueryToAddressString) Cursor(cursor string) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: cursor,
		},
	}
}

func (r transactionQueryToAddressString) In(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) InIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryToAddressString) NotIn(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) NotInIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryToAddressString) Lt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) LtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryToAddressString) Lte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) LteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryToAddressString) Gt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) GtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryToAddressString) Gte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) GteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryToAddressString) Contains(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) ContainsIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionQueryToAddressString) StartsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) StartsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionQueryToAddressString) EndsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) EndsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionQueryToAddressString) Mode(value QueryMode) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) ModeIfPresent(value *QueryMode) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionQueryToAddressString) Not(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) NotIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionQueryToAddressString) HasPrefix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionQueryToAddressString) HasPrefixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionQueryToAddressString) HasSuffix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionQueryToAddressString) HasSuffixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionQueryToAddressString) Field() transactionPrismaFields {
	return transactionFieldToAddress
}

// base struct
type transactionQueryFromAddressString struct{}

// Set the required value of FromAddress
func (r transactionQueryFromAddressString) Set(value string) transactionWithPrismaFromAddressSetParam {

	return transactionWithPrismaFromAddressSetParam{
		data: builder.Field{
			Name:  "fromAddress",
			Value: value,
		},
	}

}

// Set the optional value of FromAddress dynamically
func (r transactionQueryFromAddressString) SetIfPresent(value *String) transactionWithPrismaFromAddressSetParam {
	if value == nil {
		return transactionWithPrismaFromAddressSetParam{}
	}

	return r.Set(*value)
}

func (r transactionQueryFromAddressString) Equals(value string) transactionWithPrismaFromAddressEqualsParam {

	return transactionWithPrismaFromAddressEqualsParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) EqualsIfPresent(value *string) transactionWithPrismaFromAddressEqualsParam {
	if value == nil {
		return transactionWithPrismaFromAddressEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryFromAddressString) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "fromAddress",
			Value: direction,
		},
	}
}

func (r transactionQueryFromAddressString) Cursor(cursor string) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "fromAddress",
			Value: cursor,
		},
	}
}

func (r transactionQueryFromAddressString) In(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) InIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryFromAddressString) NotIn(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) NotInIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryFromAddressString) Lt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) LtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryFromAddressString) Lte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) LteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryFromAddressString) Gt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) GtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryFromAddressString) Gte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) GteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryFromAddressString) Contains(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) ContainsIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionQueryFromAddressString) StartsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) StartsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionQueryFromAddressString) EndsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) EndsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionQueryFromAddressString) Mode(value QueryMode) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) ModeIfPresent(value *QueryMode) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionQueryFromAddressString) Not(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryFromAddressString) NotIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionQueryFromAddressString) HasPrefix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionQueryFromAddressString) HasPrefixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionQueryFromAddressString) HasSuffix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "fromAddress",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionQueryFromAddressString) HasSuffixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionQueryFromAddressString) Field() transactionPrismaFields {
	return transactionFieldFromAddress
}

// base struct
type transactionQueryCurrencyString struct{}

// Set the required value of Currency
func (r transactionQueryCurrencyString) Set(value string) transactionWithPrismaCurrencySetParam {

	return transactionWithPrismaCurrencySetParam{
		data: builder.Field{
			Name:  "currency",
			Value: value,
		},
	}

}

// Set the optional value of Currency dynamically
func (r transactionQueryCurrencyString) SetIfPresent(value *String) transactionWithPrismaCurrencySetParam {
	if value == nil {
		return transactionWithPrismaCurrencySetParam{}
	}

	return r.Set(*value)
}

func (r transactionQueryCurrencyString) Equals(value string) transactionWithPrismaCurrencyEqualsParam {

	return transactionWithPrismaCurrencyEqualsParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) EqualsIfPresent(value *string) transactionWithPrismaCurrencyEqualsParam {
	if value == nil {
		return transactionWithPrismaCurrencyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryCurrencyString) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "currency",
			Value: direction,
		},
	}
}

func (r transactionQueryCurrencyString) Cursor(cursor string) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "currency",
			Value: cursor,
		},
	}
}

func (r transactionQueryCurrencyString) In(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) InIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryCurrencyString) NotIn(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) NotInIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryCurrencyString) Lt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) LtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryCurrencyString) Lte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) LteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryCurrencyString) Gt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) GtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryCurrencyString) Gte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) GteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryCurrencyString) Contains(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) ContainsIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionQueryCurrencyString) StartsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) StartsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionQueryCurrencyString) EndsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) EndsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionQueryCurrencyString) Mode(value QueryMode) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) ModeIfPresent(value *QueryMode) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionQueryCurrencyString) Not(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) NotIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionQueryCurrencyString) HasPrefix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionQueryCurrencyString) HasPrefixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionQueryCurrencyString) HasSuffix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionQueryCurrencyString) HasSuffixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionQueryCurrencyString) Field() transactionPrismaFields {
	return transactionFieldCurrency
}

// base struct
type transactionQueryTransactionHistoryTransactionHistory struct{}

type transactionQueryTransactionHistoryRelations struct{}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) Some(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) Every(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) None(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (transactionQueryTransactionHistoryRelations) Fetch(

	params ...TransactionHistoryWhereParam,

) transactionToTransactionHistoryFindMany {
	var v transactionToTransactionHistoryFindMany

	v.query.Operation = "query"
	v.query.Method = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionQueryTransactionHistoryRelations) Link(
	params ...TransactionHistoryWhereParam,
) transactionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionSetParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transactionQueryTransactionHistoryRelations) Unlink(
	params ...TransactionHistoryWhereParam,
) transactionSetParam {
	var v transactionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transactionSetParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r transactionQueryTransactionHistoryTransactionHistory) Field() transactionPrismaFields {
	return transactionFieldTransactionHistory
}

// TransactionHistory acts as a namespaces to access query methods for the TransactionHistory model
var TransactionHistory = transactionHistoryQuery{}

// transactionHistoryQuery exposes query functions for the transactionHistory model
type transactionHistoryQuery struct {

	// ID
	//
	// @required
	ID transactionHistoryQueryIDInt

	Transaction transactionHistoryQueryTransactionRelations

	// TransactionID
	//
	// @required
	TransactionID transactionHistoryQueryTransactionIDInt

	// Status
	//
	// @required
	Status transactionHistoryQueryStatusString
}

func (transactionHistoryQuery) Not(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionHistoryQuery) Or(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionHistoryQuery) And(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transactionHistoryQueryIDInt struct{}

// Set the required value of ID
func (r transactionHistoryQueryIDInt) Set(value int) transactionHistorySetParam {

	return transactionHistorySetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transactionHistoryQueryIDInt) SetIfPresent(value *Int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r transactionHistoryQueryIDInt) Increment(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) IncrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r transactionHistoryQueryIDInt) Decrement(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) DecrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r transactionHistoryQueryIDInt) Multiply(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) MultiplyIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r transactionHistoryQueryIDInt) Divide(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) DivideIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Divide(*value)
}

func (r transactionHistoryQueryIDInt) Equals(value int) transactionHistoryWithPrismaIDEqualsUniqueParam {

	return transactionHistoryWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) EqualsIfPresent(value *int) transactionHistoryWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transactionHistoryWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryIDInt) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryIDInt) Cursor(cursor int) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryIDInt) In(value []int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) InIfPresent(value []int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryIDInt) NotIn(value []int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) NotInIfPresent(value []int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryIDInt) Lt(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) LtIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryIDInt) Lte(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) LteIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryIDInt) Gt(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) GtIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryIDInt) Gte(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) GteIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryIDInt) Not(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) NotIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionHistoryQueryIDInt) LT(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionHistoryQueryIDInt) LTIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionHistoryQueryIDInt) LTE(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionHistoryQueryIDInt) LTEIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionHistoryQueryIDInt) GT(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionHistoryQueryIDInt) GTIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionHistoryQueryIDInt) GTE(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionHistoryQueryIDInt) GTEIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.GTE(*value)
}

func (r transactionHistoryQueryIDInt) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldID
}

// base struct
type transactionHistoryQueryTransactionTransaction struct{}

type transactionHistoryQueryTransactionRelations struct{}

// TransactionHistory -> Transaction
//
// @relation
// @required
func (transactionHistoryQueryTransactionRelations) Where(
	params ...TransactionWhereParam,
) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (transactionHistoryQueryTransactionRelations) Fetch() transactionHistoryToTransactionFindUnique {
	var v transactionHistoryToTransactionFindUnique

	v.query.Operation = "query"
	v.query.Method = "transaction"
	v.query.Outputs = transactionOutput

	return v
}

func (r transactionHistoryQueryTransactionRelations) Link(
	params TransactionWhereParam,
) transactionHistoryWithPrismaTransactionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return transactionHistoryWithPrismaTransactionSetParam{}
	}

	fields = append(fields, f)

	return transactionHistoryWithPrismaTransactionSetParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionRelations) Unlink() transactionHistoryWithPrismaTransactionSetParam {
	var v transactionHistoryWithPrismaTransactionSetParam

	v = transactionHistoryWithPrismaTransactionSetParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r transactionHistoryQueryTransactionTransaction) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldTransaction
}

// base struct
type transactionHistoryQueryTransactionIDInt struct{}

// Set the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Set(value int) transactionHistorySetParam {

	return transactionHistorySetParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: value,
		},
	}

}

// Set the optional value of TransactionID dynamically
func (r transactionHistoryQueryTransactionIDInt) SetIfPresent(value *Int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Increment(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) IncrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Decrement(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) DecrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Multiply(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) MultiplyIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Divide(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) DivideIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Divide(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Equals(value int) transactionHistoryWithPrismaTransactionIDEqualsParam {

	return transactionHistoryWithPrismaTransactionIDEqualsParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) EqualsIfPresent(value *int) transactionHistoryWithPrismaTransactionIDEqualsParam {
	if value == nil {
		return transactionHistoryWithPrismaTransactionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) Cursor(cursor int) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) In(value []int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) InIfPresent(value []int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryTransactionIDInt) NotIn(value []int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) NotInIfPresent(value []int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryTransactionIDInt) Lt(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) LtIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Lte(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) LteIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Gt(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) GtIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Gte(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) GteIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Not(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) NotIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionHistoryQueryTransactionIDInt) LT(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) LTIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionHistoryQueryTransactionIDInt) LTE(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) LTEIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionHistoryQueryTransactionIDInt) GT(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) GTIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionHistoryQueryTransactionIDInt) GTE(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) GTEIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.GTE(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldTransactionID
}

// base struct
type transactionHistoryQueryStatusString struct{}

// Set the required value of Status
func (r transactionHistoryQueryStatusString) Set(value string) transactionHistoryWithPrismaStatusSetParam {

	return transactionHistoryWithPrismaStatusSetParam{
		data: builder.Field{
			Name:  "status",
			Value: value,
		},
	}

}

// Set the optional value of Status dynamically
func (r transactionHistoryQueryStatusString) SetIfPresent(value *String) transactionHistoryWithPrismaStatusSetParam {
	if value == nil {
		return transactionHistoryWithPrismaStatusSetParam{}
	}

	return r.Set(*value)
}

func (r transactionHistoryQueryStatusString) Equals(value string) transactionHistoryWithPrismaStatusEqualsParam {

	return transactionHistoryWithPrismaStatusEqualsParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) EqualsIfPresent(value *string) transactionHistoryWithPrismaStatusEqualsParam {
	if value == nil {
		return transactionHistoryWithPrismaStatusEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryStatusString) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "status",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryStatusString) Cursor(cursor string) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "status",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryStatusString) In(value []string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) InIfPresent(value []string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryStatusString) NotIn(value []string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) NotInIfPresent(value []string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryStatusString) Lt(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) LtIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryStatusString) Lte(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) LteIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryStatusString) Gt(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) GtIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryStatusString) Gte(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) GteIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryStatusString) Contains(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) ContainsIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionHistoryQueryStatusString) StartsWith(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) StartsWithIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionHistoryQueryStatusString) EndsWith(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) EndsWithIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionHistoryQueryStatusString) Mode(value QueryMode) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) ModeIfPresent(value *QueryMode) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionHistoryQueryStatusString) Not(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) NotIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionHistoryQueryStatusString) HasPrefix(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionHistoryQueryStatusString) HasPrefixIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionHistoryQueryStatusString) HasSuffix(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionHistoryQueryStatusString) HasSuffixIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionHistoryQueryStatusString) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldStatus
}

// Deposit acts as a namespaces to access query methods for the Deposit model
var Deposit = depositQuery{}

// depositQuery exposes query functions for the deposit model
type depositQuery struct {

	// ID
	//
	// @required
	ID depositQueryIDInt

	User depositQueryUserRelations

	// UserID
	//
	// @required
	UserID depositQueryUserIDInt

	// Amount
	//
	// @required
	Amount depositQueryAmountInt

	WithDraw depositQueryWithDrawRelations

	DepositTransaction depositQueryDepositTransactionRelations
}

func (depositQuery) Not(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositQuery) Or(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositQuery) And(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type depositQueryIDInt struct{}

// Set the required value of ID
func (r depositQueryIDInt) Set(value int) depositSetParam {

	return depositSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r depositQueryIDInt) SetIfPresent(value *Int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r depositQueryIDInt) Increment(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) IncrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r depositQueryIDInt) Decrement(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) DecrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r depositQueryIDInt) Multiply(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) MultiplyIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r depositQueryIDInt) Divide(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) DivideIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryIDInt) Equals(value int) depositWithPrismaIDEqualsUniqueParam {

	return depositWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) EqualsIfPresent(value *int) depositWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return depositWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryIDInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r depositQueryIDInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r depositQueryIDInt) In(value []int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) InIfPresent(value []int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.In(value)
}

func (r depositQueryIDInt) NotIn(value []int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) NotInIfPresent(value []int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.NotIn(value)
}

func (r depositQueryIDInt) Lt(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) LtIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Lt(*value)
}

func (r depositQueryIDInt) Lte(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) LteIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Lte(*value)
}

func (r depositQueryIDInt) Gt(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) GtIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Gt(*value)
}

func (r depositQueryIDInt) Gte(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) GteIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Gte(*value)
}

func (r depositQueryIDInt) Not(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) NotIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryIDInt) LT(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryIDInt) LTIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryIDInt) LTE(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryIDInt) LTEIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryIDInt) GT(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryIDInt) GTIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryIDInt) GTE(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryIDInt) GTEIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.GTE(*value)
}

func (r depositQueryIDInt) Field() depositPrismaFields {
	return depositFieldID
}

// base struct
type depositQueryUserUser struct{}

type depositQueryUserRelations struct{}

// Deposit -> User
//
// @relation
// @required
func (depositQueryUserRelations) Where(
	params ...UserWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (depositQueryUserRelations) Fetch() depositToUserFindUnique {
	var v depositToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r depositQueryUserRelations) Link(
	params UserWhereParam,
) depositWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return depositWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return depositWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r depositQueryUserRelations) Unlink() depositWithPrismaUserSetParam {
	var v depositWithPrismaUserSetParam

	v = depositWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r depositQueryUserUser) Field() depositPrismaFields {
	return depositFieldUser
}

// base struct
type depositQueryUserIDInt struct{}

// Set the required value of UserID
func (r depositQueryUserIDInt) Set(value int) depositSetParam {

	return depositSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r depositQueryUserIDInt) SetIfPresent(value *Int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r depositQueryUserIDInt) Increment(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) IncrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r depositQueryUserIDInt) Decrement(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) DecrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r depositQueryUserIDInt) Multiply(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) MultiplyIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r depositQueryUserIDInt) Divide(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) DivideIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryUserIDInt) Equals(value int) depositWithPrismaUserIDEqualsParam {

	return depositWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) EqualsIfPresent(value *int) depositWithPrismaUserIDEqualsParam {
	if value == nil {
		return depositWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryUserIDInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r depositQueryUserIDInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r depositQueryUserIDInt) In(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) InIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.In(value)
}

func (r depositQueryUserIDInt) NotIn(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) NotInIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositQueryUserIDInt) Lt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) LtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositQueryUserIDInt) Lte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) LteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositQueryUserIDInt) Gt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) GtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositQueryUserIDInt) Gte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) GteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositQueryUserIDInt) Not(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) NotIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryUserIDInt) LT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryUserIDInt) LTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryUserIDInt) LTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryUserIDInt) LTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryUserIDInt) GT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryUserIDInt) GTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryUserIDInt) GTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryUserIDInt) GTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositQueryUserIDInt) Field() depositPrismaFields {
	return depositFieldUserID
}

// base struct
type depositQueryAmountInt struct{}

// Set the required value of Amount
func (r depositQueryAmountInt) Set(value int) depositWithPrismaAmountSetParam {

	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name:  "amount",
			Value: value,
		},
	}

}

// Set the optional value of Amount dynamically
func (r depositQueryAmountInt) SetIfPresent(value *Int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Amount
func (r depositQueryAmountInt) Increment(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) IncrementIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Amount
func (r depositQueryAmountInt) Decrement(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) DecrementIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Amount
func (r depositQueryAmountInt) Multiply(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) MultiplyIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Amount
func (r depositQueryAmountInt) Divide(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) DivideIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryAmountInt) Equals(value int) depositWithPrismaAmountEqualsParam {

	return depositWithPrismaAmountEqualsParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) EqualsIfPresent(value *int) depositWithPrismaAmountEqualsParam {
	if value == nil {
		return depositWithPrismaAmountEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryAmountInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "amount",
			Value: direction,
		},
	}
}

func (r depositQueryAmountInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "amount",
			Value: cursor,
		},
	}
}

func (r depositQueryAmountInt) In(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) InIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.In(value)
}

func (r depositQueryAmountInt) NotIn(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) NotInIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositQueryAmountInt) Lt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) LtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositQueryAmountInt) Lte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) LteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositQueryAmountInt) Gt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) GtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositQueryAmountInt) Gte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) GteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositQueryAmountInt) Not(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) NotIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryAmountInt) LT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryAmountInt) LTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryAmountInt) LTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryAmountInt) LTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryAmountInt) GT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryAmountInt) GTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryAmountInt) GTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryAmountInt) GTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositQueryAmountInt) Field() depositPrismaFields {
	return depositFieldAmount
}

// base struct
type depositQueryWithDrawWithDraw struct{}

type depositQueryWithDrawRelations struct{}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) Some(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) Every(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) None(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (depositQueryWithDrawRelations) Fetch(

	params ...WithDrawWhereParam,

) depositToWithDrawFindMany {
	var v depositToWithDrawFindMany

	v.query.Operation = "query"
	v.query.Method = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositQueryWithDrawRelations) Link(
	params ...WithDrawWhereParam,
) depositSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r depositQueryWithDrawRelations) Unlink(
	params ...WithDrawWhereParam,
) depositSetParam {
	var v depositSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = depositSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r depositQueryWithDrawWithDraw) Field() depositPrismaFields {
	return depositFieldWithDraw
}

// base struct
type depositQueryDepositTransactionDepositTransaction struct{}

type depositQueryDepositTransactionRelations struct{}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) Some(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) Every(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) None(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (depositQueryDepositTransactionRelations) Fetch(

	params ...DepositTransactionWhereParam,

) depositToDepositTransactionFindMany {
	var v depositToDepositTransactionFindMany

	v.query.Operation = "query"
	v.query.Method = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositQueryDepositTransactionRelations) Link(
	params ...DepositTransactionWhereParam,
) depositSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositSetParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r depositQueryDepositTransactionRelations) Unlink(
	params ...DepositTransactionWhereParam,
) depositSetParam {
	var v depositSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = depositSetParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r depositQueryDepositTransactionDepositTransaction) Field() depositPrismaFields {
	return depositFieldDepositTransaction
}

// WithDraw acts as a namespaces to access query methods for the WithDraw model
var WithDraw = withDrawQuery{}

// withDrawQuery exposes query functions for the withDraw model
type withDrawQuery struct {

	// ID
	//
	// @required
	ID withDrawQueryIDInt

	// Charge
	//
	// @required
	Charge withDrawQueryChargeInt

	User withDrawQueryUserRelations

	// UserID
	//
	// @required
	UserID withDrawQueryUserIDInt

	Deposit withDrawQueryDepositRelations

	// DepositID
	//
	// @required
	DepositID withDrawQueryDepositIDInt
}

func (withDrawQuery) Not(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (withDrawQuery) Or(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (withDrawQuery) And(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type withDrawQueryIDInt struct{}

// Set the required value of ID
func (r withDrawQueryIDInt) Set(value int) withDrawSetParam {

	return withDrawSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r withDrawQueryIDInt) SetIfPresent(value *Int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r withDrawQueryIDInt) Increment(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) IncrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r withDrawQueryIDInt) Decrement(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) DecrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r withDrawQueryIDInt) Multiply(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) MultiplyIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r withDrawQueryIDInt) Divide(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) DivideIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryIDInt) Equals(value int) withDrawWithPrismaIDEqualsUniqueParam {

	return withDrawWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) EqualsIfPresent(value *int) withDrawWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return withDrawWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r withDrawQueryIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r withDrawQueryIDInt) In(value []int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) InIfPresent(value []int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.In(value)
}

func (r withDrawQueryIDInt) NotIn(value []int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) NotInIfPresent(value []int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryIDInt) Lt(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) LtIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryIDInt) Lte(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) LteIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryIDInt) Gt(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) GtIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryIDInt) Gte(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) GteIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryIDInt) Not(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) NotIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryIDInt) LT(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryIDInt) LTIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryIDInt) LTE(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryIDInt) LTEIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryIDInt) GT(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryIDInt) GTIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryIDInt) GTE(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryIDInt) GTEIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryIDInt) Field() withDrawPrismaFields {
	return withDrawFieldID
}

// base struct
type withDrawQueryChargeInt struct{}

// Set the required value of Charge
func (r withDrawQueryChargeInt) Set(value int) withDrawWithPrismaChargeSetParam {

	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name:  "charge",
			Value: value,
		},
	}

}

// Set the optional value of Charge dynamically
func (r withDrawQueryChargeInt) SetIfPresent(value *Int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Charge
func (r withDrawQueryChargeInt) Increment(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) IncrementIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Charge
func (r withDrawQueryChargeInt) Decrement(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) DecrementIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Charge
func (r withDrawQueryChargeInt) Multiply(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) MultiplyIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Charge
func (r withDrawQueryChargeInt) Divide(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) DivideIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryChargeInt) Equals(value int) withDrawWithPrismaChargeEqualsParam {

	return withDrawWithPrismaChargeEqualsParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) EqualsIfPresent(value *int) withDrawWithPrismaChargeEqualsParam {
	if value == nil {
		return withDrawWithPrismaChargeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryChargeInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "charge",
			Value: direction,
		},
	}
}

func (r withDrawQueryChargeInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "charge",
			Value: cursor,
		},
	}
}

func (r withDrawQueryChargeInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryChargeInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryChargeInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryChargeInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryChargeInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryChargeInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryChargeInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryChargeInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryChargeInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryChargeInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryChargeInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryChargeInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryChargeInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryChargeInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryChargeInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryChargeInt) Field() withDrawPrismaFields {
	return withDrawFieldCharge
}

// base struct
type withDrawQueryUserUser struct{}

type withDrawQueryUserRelations struct{}

// WithDraw -> User
//
// @relation
// @required
func (withDrawQueryUserRelations) Where(
	params ...UserWhereParam,
) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (withDrawQueryUserRelations) Fetch() withDrawToUserFindUnique {
	var v withDrawToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r withDrawQueryUserRelations) Link(
	params UserWhereParam,
) withDrawWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return withDrawWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return withDrawWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r withDrawQueryUserRelations) Unlink() withDrawWithPrismaUserSetParam {
	var v withDrawWithPrismaUserSetParam

	v = withDrawWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r withDrawQueryUserUser) Field() withDrawPrismaFields {
	return withDrawFieldUser
}

// base struct
type withDrawQueryUserIDInt struct{}

// Set the required value of UserID
func (r withDrawQueryUserIDInt) Set(value int) withDrawSetParam {

	return withDrawSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r withDrawQueryUserIDInt) SetIfPresent(value *Int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r withDrawQueryUserIDInt) Increment(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) IncrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r withDrawQueryUserIDInt) Decrement(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) DecrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r withDrawQueryUserIDInt) Multiply(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) MultiplyIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r withDrawQueryUserIDInt) Divide(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) DivideIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryUserIDInt) Equals(value int) withDrawWithPrismaUserIDEqualsParam {

	return withDrawWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) EqualsIfPresent(value *int) withDrawWithPrismaUserIDEqualsParam {
	if value == nil {
		return withDrawWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryUserIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r withDrawQueryUserIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r withDrawQueryUserIDInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryUserIDInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryUserIDInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryUserIDInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryUserIDInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryUserIDInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryUserIDInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryUserIDInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryUserIDInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryUserIDInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryUserIDInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryUserIDInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryUserIDInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryUserIDInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryUserIDInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryUserIDInt) Field() withDrawPrismaFields {
	return withDrawFieldUserID
}

// base struct
type withDrawQueryDepositDeposit struct{}

type withDrawQueryDepositRelations struct{}

// WithDraw -> Deposit
//
// @relation
// @required
func (withDrawQueryDepositRelations) Where(
	params ...DepositWhereParam,
) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (withDrawQueryDepositRelations) Fetch() withDrawToDepositFindUnique {
	var v withDrawToDepositFindUnique

	v.query.Operation = "query"
	v.query.Method = "deposit"
	v.query.Outputs = depositOutput

	return v
}

func (r withDrawQueryDepositRelations) Link(
	params DepositWhereParam,
) withDrawWithPrismaDepositSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return withDrawWithPrismaDepositSetParam{}
	}

	fields = append(fields, f)

	return withDrawWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r withDrawQueryDepositRelations) Unlink() withDrawWithPrismaDepositSetParam {
	var v withDrawWithPrismaDepositSetParam

	v = withDrawWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r withDrawQueryDepositDeposit) Field() withDrawPrismaFields {
	return withDrawFieldDeposit
}

// base struct
type withDrawQueryDepositIDInt struct{}

// Set the required value of DepositID
func (r withDrawQueryDepositIDInt) Set(value int) withDrawSetParam {

	return withDrawSetParam{
		data: builder.Field{
			Name:  "depositId",
			Value: value,
		},
	}

}

// Set the optional value of DepositID dynamically
func (r withDrawQueryDepositIDInt) SetIfPresent(value *Int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of DepositID
func (r withDrawQueryDepositIDInt) Increment(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) IncrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of DepositID
func (r withDrawQueryDepositIDInt) Decrement(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) DecrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of DepositID
func (r withDrawQueryDepositIDInt) Multiply(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) MultiplyIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of DepositID
func (r withDrawQueryDepositIDInt) Divide(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) DivideIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryDepositIDInt) Equals(value int) withDrawWithPrismaDepositIDEqualsParam {

	return withDrawWithPrismaDepositIDEqualsParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) EqualsIfPresent(value *int) withDrawWithPrismaDepositIDEqualsParam {
	if value == nil {
		return withDrawWithPrismaDepositIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryDepositIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "depositId",
			Value: direction,
		},
	}
}

func (r withDrawQueryDepositIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "depositId",
			Value: cursor,
		},
	}
}

func (r withDrawQueryDepositIDInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryDepositIDInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryDepositIDInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryDepositIDInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryDepositIDInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryDepositIDInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryDepositIDInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryDepositIDInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryDepositIDInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryDepositIDInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryDepositIDInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryDepositIDInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryDepositIDInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryDepositIDInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryDepositIDInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryDepositIDInt) Field() withDrawPrismaFields {
	return withDrawFieldDepositID
}

// DepositTransaction acts as a namespaces to access query methods for the DepositTransaction model
var DepositTransaction = depositTransactionQuery{}

// depositTransactionQuery exposes query functions for the depositTransaction model
type depositTransactionQuery struct {

	// ID
	//
	// @required
	ID depositTransactionQueryIDInt

	// Amount
	//
	// @required
	Amount depositTransactionQueryAmountInt

	Deposit depositTransactionQueryDepositRelations

	// DepositID
	//
	// @required
	DepositID depositTransactionQueryDepositIDInt
}

func (depositTransactionQuery) Not(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositTransactionQuery) Or(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositTransactionQuery) And(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type depositTransactionQueryIDInt struct{}

// Set the required value of ID
func (r depositTransactionQueryIDInt) Set(value int) depositTransactionSetParam {

	return depositTransactionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r depositTransactionQueryIDInt) SetIfPresent(value *Int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r depositTransactionQueryIDInt) Increment(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) IncrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r depositTransactionQueryIDInt) Decrement(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) DecrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r depositTransactionQueryIDInt) Multiply(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) MultiplyIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r depositTransactionQueryIDInt) Divide(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) DivideIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryIDInt) Equals(value int) depositTransactionWithPrismaIDEqualsUniqueParam {

	return depositTransactionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) EqualsIfPresent(value *int) depositTransactionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return depositTransactionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryIDInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryIDInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryIDInt) In(value []int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) InIfPresent(value []int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.In(value)
}

func (r depositTransactionQueryIDInt) NotIn(value []int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) NotInIfPresent(value []int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryIDInt) Lt(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) LtIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryIDInt) Lte(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) LteIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryIDInt) Gt(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) GtIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryIDInt) Gte(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) GteIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryIDInt) Not(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) NotIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryIDInt) LT(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryIDInt) LTIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryIDInt) LTE(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryIDInt) LTEIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryIDInt) GT(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryIDInt) GTIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryIDInt) GTE(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryIDInt) GTEIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryIDInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldID
}

// base struct
type depositTransactionQueryAmountInt struct{}

// Set the required value of Amount
func (r depositTransactionQueryAmountInt) Set(value int) depositTransactionWithPrismaAmountSetParam {

	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name:  "amount",
			Value: value,
		},
	}

}

// Set the optional value of Amount dynamically
func (r depositTransactionQueryAmountInt) SetIfPresent(value *Int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Amount
func (r depositTransactionQueryAmountInt) Increment(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) IncrementIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Amount
func (r depositTransactionQueryAmountInt) Decrement(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) DecrementIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Amount
func (r depositTransactionQueryAmountInt) Multiply(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) MultiplyIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Amount
func (r depositTransactionQueryAmountInt) Divide(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) DivideIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryAmountInt) Equals(value int) depositTransactionWithPrismaAmountEqualsParam {

	return depositTransactionWithPrismaAmountEqualsParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) EqualsIfPresent(value *int) depositTransactionWithPrismaAmountEqualsParam {
	if value == nil {
		return depositTransactionWithPrismaAmountEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryAmountInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "amount",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryAmountInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "amount",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryAmountInt) In(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) InIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.In(value)
}

func (r depositTransactionQueryAmountInt) NotIn(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) NotInIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryAmountInt) Lt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) LtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryAmountInt) Lte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) LteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryAmountInt) Gt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) GtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryAmountInt) Gte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) GteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryAmountInt) Not(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) NotIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryAmountInt) LT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryAmountInt) LTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryAmountInt) LTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryAmountInt) LTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryAmountInt) GT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryAmountInt) GTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryAmountInt) GTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryAmountInt) GTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryAmountInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldAmount
}

// base struct
type depositTransactionQueryDepositDeposit struct{}

type depositTransactionQueryDepositRelations struct{}

// DepositTransaction -> Deposit
//
// @relation
// @required
func (depositTransactionQueryDepositRelations) Where(
	params ...DepositWhereParam,
) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (depositTransactionQueryDepositRelations) Fetch() depositTransactionToDepositFindUnique {
	var v depositTransactionToDepositFindUnique

	v.query.Operation = "query"
	v.query.Method = "deposit"
	v.query.Outputs = depositOutput

	return v
}

func (r depositTransactionQueryDepositRelations) Link(
	params DepositWhereParam,
) depositTransactionWithPrismaDepositSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return depositTransactionWithPrismaDepositSetParam{}
	}

	fields = append(fields, f)

	return depositTransactionWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositRelations) Unlink() depositTransactionWithPrismaDepositSetParam {
	var v depositTransactionWithPrismaDepositSetParam

	v = depositTransactionWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r depositTransactionQueryDepositDeposit) Field() depositTransactionPrismaFields {
	return depositTransactionFieldDeposit
}

// base struct
type depositTransactionQueryDepositIDInt struct{}

// Set the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Set(value int) depositTransactionSetParam {

	return depositTransactionSetParam{
		data: builder.Field{
			Name:  "depositId",
			Value: value,
		},
	}

}

// Set the optional value of DepositID dynamically
func (r depositTransactionQueryDepositIDInt) SetIfPresent(value *Int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Increment(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) IncrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Decrement(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) DecrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Multiply(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) MultiplyIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Divide(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) DivideIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryDepositIDInt) Equals(value int) depositTransactionWithPrismaDepositIDEqualsParam {

	return depositTransactionWithPrismaDepositIDEqualsParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) EqualsIfPresent(value *int) depositTransactionWithPrismaDepositIDEqualsParam {
	if value == nil {
		return depositTransactionWithPrismaDepositIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryDepositIDInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "depositId",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryDepositIDInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "depositId",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryDepositIDInt) In(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) InIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.In(value)
}

func (r depositTransactionQueryDepositIDInt) NotIn(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) NotInIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryDepositIDInt) Lt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) LtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryDepositIDInt) Lte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) LteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryDepositIDInt) Gt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) GtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryDepositIDInt) Gte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) GteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryDepositIDInt) Not(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) NotIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryDepositIDInt) LT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryDepositIDInt) LTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryDepositIDInt) LTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryDepositIDInt) LTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryDepositIDInt) GT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryDepositIDInt) GTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryDepositIDInt) GTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryDepositIDInt) GTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryDepositIDInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldDepositID
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "username"},
	{Name: "supabaseId"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUsernameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	usernameField()
}

type UserWithPrismaUsernameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameSetParam) userModel() {}

func (p userWithPrismaUsernameSetParam) usernameField() {}

type UserWithPrismaUsernameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	usernameField()
}

type userWithPrismaUsernameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsParam) userModel() {}

func (p userWithPrismaUsernameEqualsParam) usernameField() {}

func (userWithPrismaUsernameSetParam) settable()  {}
func (userWithPrismaUsernameEqualsParam) equals() {}

type userWithPrismaUsernameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUsernameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUsernameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUsernameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaUsernameEqualsUniqueParam) usernameField() {}

func (userWithPrismaUsernameEqualsUniqueParam) unique() {}
func (userWithPrismaUsernameEqualsUniqueParam) equals() {}

type UserWithPrismaSupabaseIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	supabaseIDField()
}

type UserWithPrismaSupabaseIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	supabaseIDField()
}

type userWithPrismaSupabaseIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSupabaseIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSupabaseIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSupabaseIDSetParam) userModel() {}

func (p userWithPrismaSupabaseIDSetParam) supabaseIDField() {}

type UserWithPrismaSupabaseIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	supabaseIDField()
}

type userWithPrismaSupabaseIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSupabaseIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSupabaseIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSupabaseIDEqualsParam) userModel() {}

func (p userWithPrismaSupabaseIDEqualsParam) supabaseIDField() {}

func (userWithPrismaSupabaseIDSetParam) settable()  {}
func (userWithPrismaSupabaseIDEqualsParam) equals() {}

type userWithPrismaSupabaseIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaSupabaseIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaSupabaseIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaSupabaseIDEqualsUniqueParam) userModel()       {}
func (p userWithPrismaSupabaseIDEqualsUniqueParam) supabaseIDField() {}

func (userWithPrismaSupabaseIDEqualsUniqueParam) unique() {}
func (userWithPrismaSupabaseIDEqualsUniqueParam) equals() {}

type UserWithPrismaUserPaymentTypesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	userPaymentTypesField()
}

type UserWithPrismaUserPaymentTypesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	userPaymentTypesField()
}

type userWithPrismaUserPaymentTypesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserPaymentTypesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserPaymentTypesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserPaymentTypesSetParam) userModel() {}

func (p userWithPrismaUserPaymentTypesSetParam) userPaymentTypesField() {}

type UserWithPrismaUserPaymentTypesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	userPaymentTypesField()
}

type userWithPrismaUserPaymentTypesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserPaymentTypesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserPaymentTypesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserPaymentTypesEqualsParam) userModel() {}

func (p userWithPrismaUserPaymentTypesEqualsParam) userPaymentTypesField() {}

func (userWithPrismaUserPaymentTypesSetParam) settable()  {}
func (userWithPrismaUserPaymentTypesEqualsParam) equals() {}

type userWithPrismaUserPaymentTypesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUserPaymentTypesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUserPaymentTypesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUserPaymentTypesEqualsUniqueParam) userModel()             {}
func (p userWithPrismaUserPaymentTypesEqualsUniqueParam) userPaymentTypesField() {}

func (userWithPrismaUserPaymentTypesEqualsUniqueParam) unique() {}
func (userWithPrismaUserPaymentTypesEqualsUniqueParam) equals() {}

type UserWithPrismaDepositEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	depositField()
}

type UserWithPrismaDepositSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	depositField()
}

type userWithPrismaDepositSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDepositSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDepositSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDepositSetParam) userModel() {}

func (p userWithPrismaDepositSetParam) depositField() {}

type UserWithPrismaDepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	depositField()
}

type userWithPrismaDepositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDepositEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDepositEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDepositEqualsParam) userModel() {}

func (p userWithPrismaDepositEqualsParam) depositField() {}

func (userWithPrismaDepositSetParam) settable()  {}
func (userWithPrismaDepositEqualsParam) equals() {}

type userWithPrismaDepositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDepositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDepositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDepositEqualsUniqueParam) userModel()    {}
func (p userWithPrismaDepositEqualsUniqueParam) depositField() {}

func (userWithPrismaDepositEqualsUniqueParam) unique() {}
func (userWithPrismaDepositEqualsUniqueParam) equals() {}

type UserWithPrismaTransactionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	transactionField()
}

type UserWithPrismaTransactionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	transactionField()
}

type userWithPrismaTransactionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTransactionSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTransactionSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTransactionSetParam) userModel() {}

func (p userWithPrismaTransactionSetParam) transactionField() {}

type UserWithPrismaTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	transactionField()
}

type userWithPrismaTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTransactionEqualsParam) userModel() {}

func (p userWithPrismaTransactionEqualsParam) transactionField() {}

func (userWithPrismaTransactionSetParam) settable()  {}
func (userWithPrismaTransactionEqualsParam) equals() {}

type userWithPrismaTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaTransactionEqualsUniqueParam) userModel()        {}
func (p userWithPrismaTransactionEqualsUniqueParam) transactionField() {}

func (userWithPrismaTransactionEqualsUniqueParam) unique() {}
func (userWithPrismaTransactionEqualsUniqueParam) equals() {}

type UserWithPrismaWithDrawEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	withDrawField()
}

type UserWithPrismaWithDrawSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	withDrawField()
}

type userWithPrismaWithDrawSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWithDrawSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWithDrawSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWithDrawSetParam) userModel() {}

func (p userWithPrismaWithDrawSetParam) withDrawField() {}

type UserWithPrismaWithDrawWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	withDrawField()
}

type userWithPrismaWithDrawEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWithDrawEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWithDrawEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWithDrawEqualsParam) userModel() {}

func (p userWithPrismaWithDrawEqualsParam) withDrawField() {}

func (userWithPrismaWithDrawSetParam) settable()  {}
func (userWithPrismaWithDrawEqualsParam) equals() {}

type userWithPrismaWithDrawEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaWithDrawEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaWithDrawEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaWithDrawEqualsUniqueParam) userModel()     {}
func (p userWithPrismaWithDrawEqualsUniqueParam) withDrawField() {}

func (userWithPrismaWithDrawEqualsUniqueParam) unique() {}
func (userWithPrismaWithDrawEqualsUniqueParam) equals() {}

type masterPaymentTypeActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var masterPaymentTypeOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
}

type MasterPaymentTypeRelationWith interface {
	getQuery() builder.Query
	with()
	masterPaymentTypeRelation()
}

type MasterPaymentTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
}

type masterPaymentTypeDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeDefaultParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeDefaultParam) masterPaymentTypeModel() {}

type MasterPaymentTypeOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
}

type masterPaymentTypeOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeOrderByParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeOrderByParam) masterPaymentTypeModel() {}

type MasterPaymentTypeCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	isCursor()
}

type masterPaymentTypeCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeCursorParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeCursorParam) isCursor() {}

func (p masterPaymentTypeCursorParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeCursorParam) masterPaymentTypeModel() {}

type MasterPaymentTypeParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	masterPaymentTypeModel()
}

type masterPaymentTypeParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeParamUnique) masterPaymentTypeModel() {}

func (masterPaymentTypeParamUnique) unique() {}

func (p masterPaymentTypeParamUnique) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeParamUnique) getQuery() builder.Query {
	return p.query
}

type MasterPaymentTypeEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	masterPaymentTypeModel()
}

type masterPaymentTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeEqualsParam) masterPaymentTypeModel() {}

func (masterPaymentTypeEqualsParam) equals() {}

func (p masterPaymentTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

type MasterPaymentTypeEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	masterPaymentTypeModel()
}

type masterPaymentTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeEqualsUniqueParam) masterPaymentTypeModel() {}

func (masterPaymentTypeEqualsUniqueParam) unique() {}
func (masterPaymentTypeEqualsUniqueParam) equals() {}

func (p masterPaymentTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type MasterPaymentTypeSetParam interface {
	field() builder.Field
	settable()
	masterPaymentTypeModel()
}

type masterPaymentTypeSetParam struct {
	data builder.Field
}

func (masterPaymentTypeSetParam) settable() {}

func (p masterPaymentTypeSetParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeSetParam) masterPaymentTypeModel() {}

type MasterPaymentTypeWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	masterPaymentTypeModel()
	idField()
}

type MasterPaymentTypeWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	idField()
}

type masterPaymentTypeWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaIDSetParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaIDSetParam) idField() {}

type MasterPaymentTypeWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	idField()
}

type masterPaymentTypeWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaIDEqualsParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaIDEqualsParam) idField() {}

func (masterPaymentTypeWithPrismaIDSetParam) settable()  {}
func (masterPaymentTypeWithPrismaIDEqualsParam) equals() {}

type masterPaymentTypeWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaIDEqualsUniqueParam) masterPaymentTypeModel() {}
func (p masterPaymentTypeWithPrismaIDEqualsUniqueParam) idField()                {}

func (masterPaymentTypeWithPrismaIDEqualsUniqueParam) unique() {}
func (masterPaymentTypeWithPrismaIDEqualsUniqueParam) equals() {}

type MasterPaymentTypeWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	masterPaymentTypeModel()
	nameField()
}

type MasterPaymentTypeWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	nameField()
}

type masterPaymentTypeWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaNameSetParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaNameSetParam) nameField() {}

type MasterPaymentTypeWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	nameField()
}

type masterPaymentTypeWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaNameEqualsParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaNameEqualsParam) nameField() {}

func (masterPaymentTypeWithPrismaNameSetParam) settable()  {}
func (masterPaymentTypeWithPrismaNameEqualsParam) equals() {}

type masterPaymentTypeWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaNameEqualsUniqueParam) masterPaymentTypeModel() {}
func (p masterPaymentTypeWithPrismaNameEqualsUniqueParam) nameField()              {}

func (masterPaymentTypeWithPrismaNameEqualsUniqueParam) unique() {}
func (masterPaymentTypeWithPrismaNameEqualsUniqueParam) equals() {}

type MasterPaymentTypeWithPrismaUserPaymentTypesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	masterPaymentTypeModel()
	userPaymentTypesField()
}

type MasterPaymentTypeWithPrismaUserPaymentTypesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	userPaymentTypesField()
}

type masterPaymentTypeWithPrismaUserPaymentTypesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesSetParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesSetParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesSetParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaUserPaymentTypesSetParam) userPaymentTypesField() {}

type MasterPaymentTypeWithPrismaUserPaymentTypesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	masterPaymentTypeModel()
	userPaymentTypesField()
}

type masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam) masterPaymentTypeModel() {}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam) userPaymentTypesField() {}

func (masterPaymentTypeWithPrismaUserPaymentTypesSetParam) settable()  {}
func (masterPaymentTypeWithPrismaUserPaymentTypesEqualsParam) equals() {}

type masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) masterPaymentTypeModel() {}
func (p masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) userPaymentTypesField()  {}

func (masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) unique() {}
func (masterPaymentTypeWithPrismaUserPaymentTypesEqualsUniqueParam) equals() {}

type userPaymentTypesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userPaymentTypesOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "masterPaymentTypeId"},
}

type UserPaymentTypesRelationWith interface {
	getQuery() builder.Query
	with()
	userPaymentTypesRelation()
}

type UserPaymentTypesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
}

type userPaymentTypesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesDefaultParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesDefaultParam) userPaymentTypesModel() {}

type UserPaymentTypesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
}

type userPaymentTypesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesOrderByParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesOrderByParam) userPaymentTypesModel() {}

type UserPaymentTypesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	isCursor()
}

type userPaymentTypesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesCursorParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesCursorParam) isCursor() {}

func (p userPaymentTypesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesCursorParam) userPaymentTypesModel() {}

type UserPaymentTypesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userPaymentTypesModel()
}

type userPaymentTypesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesParamUnique) userPaymentTypesModel() {}

func (userPaymentTypesParamUnique) unique() {}

func (p userPaymentTypesParamUnique) field() builder.Field {
	return p.data
}

func (p userPaymentTypesParamUnique) getQuery() builder.Query {
	return p.query
}

type UserPaymentTypesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
}

type userPaymentTypesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesEqualsParam) userPaymentTypesModel() {}

func (userPaymentTypesEqualsParam) equals() {}

func (p userPaymentTypesEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserPaymentTypesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userPaymentTypesModel()
}

type userPaymentTypesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesEqualsUniqueParam) userPaymentTypesModel() {}

func (userPaymentTypesEqualsUniqueParam) unique() {}
func (userPaymentTypesEqualsUniqueParam) equals() {}

func (p userPaymentTypesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserPaymentTypesSetParam interface {
	field() builder.Field
	settable()
	userPaymentTypesModel()
}

type userPaymentTypesSetParam struct {
	data builder.Field
}

func (userPaymentTypesSetParam) settable() {}

func (p userPaymentTypesSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesSetParam) userPaymentTypesModel() {}

type UserPaymentTypesWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
	idField()
}

type UserPaymentTypesWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	idField()
}

type userPaymentTypesWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaIDSetParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaIDSetParam) idField() {}

type UserPaymentTypesWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	idField()
}

type userPaymentTypesWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaIDEqualsParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaIDEqualsParam) idField() {}

func (userPaymentTypesWithPrismaIDSetParam) settable()  {}
func (userPaymentTypesWithPrismaIDEqualsParam) equals() {}

type userPaymentTypesWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaIDEqualsUniqueParam) userPaymentTypesModel() {}
func (p userPaymentTypesWithPrismaIDEqualsUniqueParam) idField()               {}

func (userPaymentTypesWithPrismaIDEqualsUniqueParam) unique() {}
func (userPaymentTypesWithPrismaIDEqualsUniqueParam) equals() {}

type UserPaymentTypesWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
	userField()
}

type UserPaymentTypesWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	userField()
}

type userPaymentTypesWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserSetParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaUserSetParam) userField() {}

type UserPaymentTypesWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	userField()
}

type userPaymentTypesWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserEqualsParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaUserEqualsParam) userField() {}

func (userPaymentTypesWithPrismaUserSetParam) settable()  {}
func (userPaymentTypesWithPrismaUserEqualsParam) equals() {}

type userPaymentTypesWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserEqualsUniqueParam) userPaymentTypesModel() {}
func (p userPaymentTypesWithPrismaUserEqualsUniqueParam) userField()             {}

func (userPaymentTypesWithPrismaUserEqualsUniqueParam) unique() {}
func (userPaymentTypesWithPrismaUserEqualsUniqueParam) equals() {}

type UserPaymentTypesWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
	userIDField()
}

type UserPaymentTypesWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	userIDField()
}

type userPaymentTypesWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserIDSetParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaUserIDSetParam) userIDField() {}

type UserPaymentTypesWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	userIDField()
}

type userPaymentTypesWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserIDEqualsParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaUserIDEqualsParam) userIDField() {}

func (userPaymentTypesWithPrismaUserIDSetParam) settable()  {}
func (userPaymentTypesWithPrismaUserIDEqualsParam) equals() {}

type userPaymentTypesWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaUserIDEqualsUniqueParam) userPaymentTypesModel() {}
func (p userPaymentTypesWithPrismaUserIDEqualsUniqueParam) userIDField()           {}

func (userPaymentTypesWithPrismaUserIDEqualsUniqueParam) unique() {}
func (userPaymentTypesWithPrismaUserIDEqualsUniqueParam) equals() {}

type UserPaymentTypesWithPrismaMasterPaymentTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
	masterPaymentTypeField()
}

type UserPaymentTypesWithPrismaMasterPaymentTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	masterPaymentTypeField()
}

type userPaymentTypesWithPrismaMasterPaymentTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeSetParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaMasterPaymentTypeSetParam) masterPaymentTypeField() {}

type UserPaymentTypesWithPrismaMasterPaymentTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	masterPaymentTypeField()
}

type userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam) masterPaymentTypeField() {}

func (userPaymentTypesWithPrismaMasterPaymentTypeSetParam) settable()  {}
func (userPaymentTypesWithPrismaMasterPaymentTypeEqualsParam) equals() {}

type userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) userPaymentTypesModel()  {}
func (p userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) masterPaymentTypeField() {}

func (userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) unique() {}
func (userPaymentTypesWithPrismaMasterPaymentTypeEqualsUniqueParam) equals() {}

type UserPaymentTypesWithPrismaMasterPaymentTypeIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userPaymentTypesModel()
	masterPaymentTypeIDField()
}

type UserPaymentTypesWithPrismaMasterPaymentTypeIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	masterPaymentTypeIDField()
}

type userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam) masterPaymentTypeIDField() {}

type UserPaymentTypesWithPrismaMasterPaymentTypeIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userPaymentTypesModel()
	masterPaymentTypeIDField()
}

type userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam) userPaymentTypesModel() {}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam) masterPaymentTypeIDField() {}

func (userPaymentTypesWithPrismaMasterPaymentTypeIDSetParam) settable()  {}
func (userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsParam) equals() {}

type userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) userPaymentTypesModel()    {}
func (p userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) masterPaymentTypeIDField() {}

func (userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) unique() {}
func (userPaymentTypesWithPrismaMasterPaymentTypeIDEqualsUniqueParam) equals() {}

type transactionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transactionOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "toAddress"},
	{Name: "fromAddress"},
	{Name: "currency"},
}

type TransactionRelationWith interface {
	getQuery() builder.Query
	with()
	transactionRelation()
}

type TransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
}

type transactionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionDefaultParam) field() builder.Field {
	return p.data
}

func (p transactionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transactionDefaultParam) transactionModel() {}

type TransactionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
}

type transactionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionOrderByParam) field() builder.Field {
	return p.data
}

func (p transactionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transactionOrderByParam) transactionModel() {}

type TransactionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	isCursor()
}

type transactionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionCursorParam) field() builder.Field {
	return p.data
}

func (p transactionCursorParam) isCursor() {}

func (p transactionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transactionCursorParam) transactionModel() {}

type TransactionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transactionModel()
}

type transactionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transactionParamUnique) transactionModel() {}

func (transactionParamUnique) unique() {}

func (p transactionParamUnique) field() builder.Field {
	return p.data
}

func (p transactionParamUnique) getQuery() builder.Query {
	return p.query
}

type TransactionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
}

type transactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionEqualsParam) transactionModel() {}

func (transactionEqualsParam) equals() {}

func (p transactionEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransactionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transactionModel()
}

type transactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionEqualsUniqueParam) transactionModel() {}

func (transactionEqualsUniqueParam) unique() {}
func (transactionEqualsUniqueParam) equals() {}

func (p transactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransactionSetParam interface {
	field() builder.Field
	settable()
	transactionModel()
}

type transactionSetParam struct {
	data builder.Field
}

func (transactionSetParam) settable() {}

func (p transactionSetParam) field() builder.Field {
	return p.data
}

func (p transactionSetParam) transactionModel() {}

type TransactionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	idField()
}

type TransactionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	idField()
}

type transactionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDSetParam) transactionModel() {}

func (p transactionWithPrismaIDSetParam) idField() {}

type TransactionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	idField()
}

type transactionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDEqualsParam) transactionModel() {}

func (p transactionWithPrismaIDEqualsParam) idField() {}

func (transactionWithPrismaIDSetParam) settable()  {}
func (transactionWithPrismaIDEqualsParam) equals() {}

type transactionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaIDEqualsUniqueParam) idField()          {}

func (transactionWithPrismaIDEqualsUniqueParam) unique() {}
func (transactionWithPrismaIDEqualsUniqueParam) equals() {}

type TransactionWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	userField()
}

type TransactionWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userField()
}

type transactionWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserSetParam) transactionModel() {}

func (p transactionWithPrismaUserSetParam) userField() {}

type TransactionWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userField()
}

type transactionWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserEqualsParam) transactionModel() {}

func (p transactionWithPrismaUserEqualsParam) userField() {}

func (transactionWithPrismaUserSetParam) settable()  {}
func (transactionWithPrismaUserEqualsParam) equals() {}

type transactionWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaUserEqualsUniqueParam) userField()        {}

func (transactionWithPrismaUserEqualsUniqueParam) unique() {}
func (transactionWithPrismaUserEqualsUniqueParam) equals() {}

type TransactionWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	userIDField()
}

type TransactionWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userIDField()
}

type transactionWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDSetParam) transactionModel() {}

func (p transactionWithPrismaUserIDSetParam) userIDField() {}

type TransactionWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userIDField()
}

type transactionWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDEqualsParam) transactionModel() {}

func (p transactionWithPrismaUserIDEqualsParam) userIDField() {}

func (transactionWithPrismaUserIDSetParam) settable()  {}
func (transactionWithPrismaUserIDEqualsParam) equals() {}

type transactionWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaUserIDEqualsUniqueParam) userIDField()      {}

func (transactionWithPrismaUserIDEqualsUniqueParam) unique() {}
func (transactionWithPrismaUserIDEqualsUniqueParam) equals() {}

type TransactionWithPrismaToAddressEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	toAddressField()
}

type TransactionWithPrismaToAddressSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	toAddressField()
}

type transactionWithPrismaToAddressSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressSetParam) transactionModel() {}

func (p transactionWithPrismaToAddressSetParam) toAddressField() {}

type TransactionWithPrismaToAddressWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	toAddressField()
}

type transactionWithPrismaToAddressEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressEqualsParam) transactionModel() {}

func (p transactionWithPrismaToAddressEqualsParam) toAddressField() {}

func (transactionWithPrismaToAddressSetParam) settable()  {}
func (transactionWithPrismaToAddressEqualsParam) equals() {}

type transactionWithPrismaToAddressEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaToAddressEqualsUniqueParam) toAddressField()   {}

func (transactionWithPrismaToAddressEqualsUniqueParam) unique() {}
func (transactionWithPrismaToAddressEqualsUniqueParam) equals() {}

type TransactionWithPrismaFromAddressEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	fromAddressField()
}

type TransactionWithPrismaFromAddressSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	fromAddressField()
}

type transactionWithPrismaFromAddressSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaFromAddressSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaFromAddressSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaFromAddressSetParam) transactionModel() {}

func (p transactionWithPrismaFromAddressSetParam) fromAddressField() {}

type TransactionWithPrismaFromAddressWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	fromAddressField()
}

type transactionWithPrismaFromAddressEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaFromAddressEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaFromAddressEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaFromAddressEqualsParam) transactionModel() {}

func (p transactionWithPrismaFromAddressEqualsParam) fromAddressField() {}

func (transactionWithPrismaFromAddressSetParam) settable()  {}
func (transactionWithPrismaFromAddressEqualsParam) equals() {}

type transactionWithPrismaFromAddressEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaFromAddressEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaFromAddressEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaFromAddressEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaFromAddressEqualsUniqueParam) fromAddressField() {}

func (transactionWithPrismaFromAddressEqualsUniqueParam) unique() {}
func (transactionWithPrismaFromAddressEqualsUniqueParam) equals() {}

type TransactionWithPrismaCurrencyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	currencyField()
}

type TransactionWithPrismaCurrencySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	currencyField()
}

type transactionWithPrismaCurrencySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencySetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencySetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencySetParam) transactionModel() {}

func (p transactionWithPrismaCurrencySetParam) currencyField() {}

type TransactionWithPrismaCurrencyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	currencyField()
}

type transactionWithPrismaCurrencyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencyEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencyEqualsParam) transactionModel() {}

func (p transactionWithPrismaCurrencyEqualsParam) currencyField() {}

func (transactionWithPrismaCurrencySetParam) settable()  {}
func (transactionWithPrismaCurrencyEqualsParam) equals() {}

type transactionWithPrismaCurrencyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaCurrencyEqualsUniqueParam) currencyField()    {}

func (transactionWithPrismaCurrencyEqualsUniqueParam) unique() {}
func (transactionWithPrismaCurrencyEqualsUniqueParam) equals() {}

type TransactionWithPrismaTransactionHistoryEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	transactionHistoryField()
}

type TransactionWithPrismaTransactionHistorySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	transactionHistoryField()
}

type transactionWithPrismaTransactionHistorySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistorySetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistorySetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistorySetParam) transactionModel() {}

func (p transactionWithPrismaTransactionHistorySetParam) transactionHistoryField() {}

type TransactionWithPrismaTransactionHistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	transactionHistoryField()
}

type transactionWithPrismaTransactionHistoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) transactionModel() {}

func (p transactionWithPrismaTransactionHistoryEqualsParam) transactionHistoryField() {}

func (transactionWithPrismaTransactionHistorySetParam) settable()  {}
func (transactionWithPrismaTransactionHistoryEqualsParam) equals() {}

type transactionWithPrismaTransactionHistoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) transactionModel()        {}
func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) transactionHistoryField() {}

func (transactionWithPrismaTransactionHistoryEqualsUniqueParam) unique() {}
func (transactionWithPrismaTransactionHistoryEqualsUniqueParam) equals() {}

type transactionHistoryActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transactionHistoryOutput = []builder.Output{
	{Name: "id"},
	{Name: "transactionId"},
	{Name: "status"},
}

type TransactionHistoryRelationWith interface {
	getQuery() builder.Query
	with()
	transactionHistoryRelation()
}

type TransactionHistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
}

type transactionHistoryDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryDefaultParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryDefaultParam) transactionHistoryModel() {}

type TransactionHistoryOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
}

type transactionHistoryOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryOrderByParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryOrderByParam) transactionHistoryModel() {}

type TransactionHistoryCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	isCursor()
}

type transactionHistoryCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryCursorParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryCursorParam) isCursor() {}

func (p transactionHistoryCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryCursorParam) transactionHistoryModel() {}

type TransactionHistoryParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transactionHistoryModel()
}

type transactionHistoryParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryParamUnique) transactionHistoryModel() {}

func (transactionHistoryParamUnique) unique() {}

func (p transactionHistoryParamUnique) field() builder.Field {
	return p.data
}

func (p transactionHistoryParamUnique) getQuery() builder.Query {
	return p.query
}

type TransactionHistoryEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
}

type transactionHistoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryEqualsParam) transactionHistoryModel() {}

func (transactionHistoryEqualsParam) equals() {}

func (p transactionHistoryEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransactionHistoryEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transactionHistoryModel()
}

type transactionHistoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryEqualsUniqueParam) transactionHistoryModel() {}

func (transactionHistoryEqualsUniqueParam) unique() {}
func (transactionHistoryEqualsUniqueParam) equals() {}

func (p transactionHistoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransactionHistorySetParam interface {
	field() builder.Field
	settable()
	transactionHistoryModel()
}

type transactionHistorySetParam struct {
	data builder.Field
}

func (transactionHistorySetParam) settable() {}

func (p transactionHistorySetParam) field() builder.Field {
	return p.data
}

func (p transactionHistorySetParam) transactionHistoryModel() {}

type TransactionHistoryWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	idField()
}

type TransactionHistoryWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	idField()
}

type transactionHistoryWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaIDSetParam) idField() {}

type TransactionHistoryWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	idField()
}

type transactionHistoryWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaIDEqualsParam) idField() {}

func (transactionHistoryWithPrismaIDSetParam) settable()  {}
func (transactionHistoryWithPrismaIDEqualsParam) equals() {}

type transactionHistoryWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaIDEqualsUniqueParam) idField()                 {}

func (transactionHistoryWithPrismaIDEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaIDEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaTransactionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	transactionField()
}

type TransactionHistoryWithPrismaTransactionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionField()
}

type transactionHistoryWithPrismaTransactionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionSetParam) transactionField() {}

type TransactionHistoryWithPrismaTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionField()
}

type transactionHistoryWithPrismaTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionEqualsParam) transactionField() {}

func (transactionHistoryWithPrismaTransactionSetParam) settable()  {}
func (transactionHistoryWithPrismaTransactionEqualsParam) equals() {}

type transactionHistoryWithPrismaTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) transactionField()        {}

func (transactionHistoryWithPrismaTransactionEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaTransactionEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaTransactionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	transactionIDField()
}

type TransactionHistoryWithPrismaTransactionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionIDField()
}

type transactionHistoryWithPrismaTransactionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionIDSetParam) transactionIDField() {}

type TransactionHistoryWithPrismaTransactionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionIDField()
}

type transactionHistoryWithPrismaTransactionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) transactionIDField() {}

func (transactionHistoryWithPrismaTransactionIDSetParam) settable()  {}
func (transactionHistoryWithPrismaTransactionIDEqualsParam) equals() {}

type transactionHistoryWithPrismaTransactionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) transactionIDField()      {}

func (transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaStatusEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	statusField()
}

type TransactionHistoryWithPrismaStatusSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	statusField()
}

type transactionHistoryWithPrismaStatusSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaStatusSetParam) statusField() {}

type TransactionHistoryWithPrismaStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	statusField()
}

type transactionHistoryWithPrismaStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaStatusEqualsParam) statusField() {}

func (transactionHistoryWithPrismaStatusSetParam) settable()  {}
func (transactionHistoryWithPrismaStatusEqualsParam) equals() {}

type transactionHistoryWithPrismaStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) statusField()             {}

func (transactionHistoryWithPrismaStatusEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaStatusEqualsUniqueParam) equals() {}

type depositActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var depositOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "amount"},
}

type DepositRelationWith interface {
	getQuery() builder.Query
	with()
	depositRelation()
}

type DepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
}

type depositDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositDefaultParam) field() builder.Field {
	return p.data
}

func (p depositDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p depositDefaultParam) depositModel() {}

type DepositOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
}

type depositOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositOrderByParam) field() builder.Field {
	return p.data
}

func (p depositOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p depositOrderByParam) depositModel() {}

type DepositCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	isCursor()
}

type depositCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositCursorParam) field() builder.Field {
	return p.data
}

func (p depositCursorParam) isCursor() {}

func (p depositCursorParam) getQuery() builder.Query {
	return p.query
}

func (p depositCursorParam) depositModel() {}

type DepositParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	depositModel()
}

type depositParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p depositParamUnique) depositModel() {}

func (depositParamUnique) unique() {}

func (p depositParamUnique) field() builder.Field {
	return p.data
}

func (p depositParamUnique) getQuery() builder.Query {
	return p.query
}

type DepositEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
}

type depositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositEqualsParam) depositModel() {}

func (depositEqualsParam) equals() {}

func (p depositEqualsParam) field() builder.Field {
	return p.data
}

func (p depositEqualsParam) getQuery() builder.Query {
	return p.query
}

type DepositEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	depositModel()
}

type depositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositEqualsUniqueParam) depositModel() {}

func (depositEqualsUniqueParam) unique() {}
func (depositEqualsUniqueParam) equals() {}

func (p depositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DepositSetParam interface {
	field() builder.Field
	settable()
	depositModel()
}

type depositSetParam struct {
	data builder.Field
}

func (depositSetParam) settable() {}

func (p depositSetParam) field() builder.Field {
	return p.data
}

func (p depositSetParam) depositModel() {}

type DepositWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	idField()
}

type DepositWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	idField()
}

type depositWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDSetParam) depositModel() {}

func (p depositWithPrismaIDSetParam) idField() {}

type DepositWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	idField()
}

type depositWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDEqualsParam) depositModel() {}

func (p depositWithPrismaIDEqualsParam) idField() {}

func (depositWithPrismaIDSetParam) settable()  {}
func (depositWithPrismaIDEqualsParam) equals() {}

type depositWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaIDEqualsUniqueParam) idField()      {}

func (depositWithPrismaIDEqualsUniqueParam) unique() {}
func (depositWithPrismaIDEqualsUniqueParam) equals() {}

type DepositWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	userField()
}

type DepositWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userField()
}

type depositWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserSetParam) depositModel() {}

func (p depositWithPrismaUserSetParam) userField() {}

type DepositWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userField()
}

type depositWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserEqualsParam) depositModel() {}

func (p depositWithPrismaUserEqualsParam) userField() {}

func (depositWithPrismaUserSetParam) settable()  {}
func (depositWithPrismaUserEqualsParam) equals() {}

type depositWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaUserEqualsUniqueParam) userField()    {}

func (depositWithPrismaUserEqualsUniqueParam) unique() {}
func (depositWithPrismaUserEqualsUniqueParam) equals() {}

type DepositWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	userIDField()
}

type DepositWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userIDField()
}

type depositWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDSetParam) depositModel() {}

func (p depositWithPrismaUserIDSetParam) userIDField() {}

type DepositWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userIDField()
}

type depositWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDEqualsParam) depositModel() {}

func (p depositWithPrismaUserIDEqualsParam) userIDField() {}

func (depositWithPrismaUserIDSetParam) settable()  {}
func (depositWithPrismaUserIDEqualsParam) equals() {}

type depositWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (depositWithPrismaUserIDEqualsUniqueParam) unique() {}
func (depositWithPrismaUserIDEqualsUniqueParam) equals() {}

type DepositWithPrismaAmountEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	amountField()
}

type DepositWithPrismaAmountSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	amountField()
}

type depositWithPrismaAmountSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountSetParam) depositModel() {}

func (p depositWithPrismaAmountSetParam) amountField() {}

type DepositWithPrismaAmountWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	amountField()
}

type depositWithPrismaAmountEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountEqualsParam) depositModel() {}

func (p depositWithPrismaAmountEqualsParam) amountField() {}

func (depositWithPrismaAmountSetParam) settable()  {}
func (depositWithPrismaAmountEqualsParam) equals() {}

type depositWithPrismaAmountEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaAmountEqualsUniqueParam) amountField()  {}

func (depositWithPrismaAmountEqualsUniqueParam) unique() {}
func (depositWithPrismaAmountEqualsUniqueParam) equals() {}

type DepositWithPrismaWithDrawEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	withDrawField()
}

type DepositWithPrismaWithDrawSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	withDrawField()
}

type depositWithPrismaWithDrawSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawSetParam) depositModel() {}

func (p depositWithPrismaWithDrawSetParam) withDrawField() {}

type DepositWithPrismaWithDrawWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	withDrawField()
}

type depositWithPrismaWithDrawEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawEqualsParam) depositModel() {}

func (p depositWithPrismaWithDrawEqualsParam) withDrawField() {}

func (depositWithPrismaWithDrawSetParam) settable()  {}
func (depositWithPrismaWithDrawEqualsParam) equals() {}

type depositWithPrismaWithDrawEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) depositModel()  {}
func (p depositWithPrismaWithDrawEqualsUniqueParam) withDrawField() {}

func (depositWithPrismaWithDrawEqualsUniqueParam) unique() {}
func (depositWithPrismaWithDrawEqualsUniqueParam) equals() {}

type DepositWithPrismaDepositTransactionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	depositTransactionField()
}

type DepositWithPrismaDepositTransactionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	depositTransactionField()
}

type depositWithPrismaDepositTransactionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionSetParam) depositModel() {}

func (p depositWithPrismaDepositTransactionSetParam) depositTransactionField() {}

type DepositWithPrismaDepositTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	depositTransactionField()
}

type depositWithPrismaDepositTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionEqualsParam) depositModel() {}

func (p depositWithPrismaDepositTransactionEqualsParam) depositTransactionField() {}

func (depositWithPrismaDepositTransactionSetParam) settable()  {}
func (depositWithPrismaDepositTransactionEqualsParam) equals() {}

type depositWithPrismaDepositTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) depositModel()            {}
func (p depositWithPrismaDepositTransactionEqualsUniqueParam) depositTransactionField() {}

func (depositWithPrismaDepositTransactionEqualsUniqueParam) unique() {}
func (depositWithPrismaDepositTransactionEqualsUniqueParam) equals() {}

type withDrawActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var withDrawOutput = []builder.Output{
	{Name: "id"},
	{Name: "charge"},
	{Name: "userId"},
	{Name: "depositId"},
}

type WithDrawRelationWith interface {
	getQuery() builder.Query
	with()
	withDrawRelation()
}

type WithDrawWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
}

type withDrawDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawDefaultParam) field() builder.Field {
	return p.data
}

func (p withDrawDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawDefaultParam) withDrawModel() {}

type WithDrawOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
}

type withDrawOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawOrderByParam) field() builder.Field {
	return p.data
}

func (p withDrawOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawOrderByParam) withDrawModel() {}

type WithDrawCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	isCursor()
}

type withDrawCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawCursorParam) field() builder.Field {
	return p.data
}

func (p withDrawCursorParam) isCursor() {}

func (p withDrawCursorParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawCursorParam) withDrawModel() {}

type WithDrawParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	withDrawModel()
}

type withDrawParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawParamUnique) withDrawModel() {}

func (withDrawParamUnique) unique() {}

func (p withDrawParamUnique) field() builder.Field {
	return p.data
}

func (p withDrawParamUnique) getQuery() builder.Query {
	return p.query
}

type WithDrawEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
}

type withDrawEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawEqualsParam) withDrawModel() {}

func (withDrawEqualsParam) equals() {}

func (p withDrawEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawEqualsParam) getQuery() builder.Query {
	return p.query
}

type WithDrawEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	withDrawModel()
}

type withDrawEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawEqualsUniqueParam) withDrawModel() {}

func (withDrawEqualsUniqueParam) unique() {}
func (withDrawEqualsUniqueParam) equals() {}

func (p withDrawEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type WithDrawSetParam interface {
	field() builder.Field
	settable()
	withDrawModel()
}

type withDrawSetParam struct {
	data builder.Field
}

func (withDrawSetParam) settable() {}

func (p withDrawSetParam) field() builder.Field {
	return p.data
}

func (p withDrawSetParam) withDrawModel() {}

type WithDrawWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	idField()
}

type WithDrawWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	idField()
}

type withDrawWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaIDSetParam) idField() {}

type WithDrawWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	idField()
}

type withDrawWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaIDEqualsParam) idField() {}

func (withDrawWithPrismaIDSetParam) settable()  {}
func (withDrawWithPrismaIDEqualsParam) equals() {}

type withDrawWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaIDEqualsUniqueParam) idField()       {}

func (withDrawWithPrismaIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaIDEqualsUniqueParam) equals() {}

type WithDrawWithPrismaChargeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	chargeField()
}

type WithDrawWithPrismaChargeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	chargeField()
}

type withDrawWithPrismaChargeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeSetParam) withDrawModel() {}

func (p withDrawWithPrismaChargeSetParam) chargeField() {}

type WithDrawWithPrismaChargeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	chargeField()
}

type withDrawWithPrismaChargeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaChargeEqualsParam) chargeField() {}

func (withDrawWithPrismaChargeSetParam) settable()  {}
func (withDrawWithPrismaChargeEqualsParam) equals() {}

type withDrawWithPrismaChargeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaChargeEqualsUniqueParam) chargeField()   {}

func (withDrawWithPrismaChargeEqualsUniqueParam) unique() {}
func (withDrawWithPrismaChargeEqualsUniqueParam) equals() {}

type WithDrawWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	userField()
}

type WithDrawWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userField()
}

type withDrawWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserSetParam) withDrawModel() {}

func (p withDrawWithPrismaUserSetParam) userField() {}

type WithDrawWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userField()
}

type withDrawWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaUserEqualsParam) userField() {}

func (withDrawWithPrismaUserSetParam) settable()  {}
func (withDrawWithPrismaUserEqualsParam) equals() {}

type withDrawWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaUserEqualsUniqueParam) userField()     {}

func (withDrawWithPrismaUserEqualsUniqueParam) unique() {}
func (withDrawWithPrismaUserEqualsUniqueParam) equals() {}

type WithDrawWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	userIDField()
}

type WithDrawWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userIDField()
}

type withDrawWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaUserIDSetParam) userIDField() {}

type WithDrawWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userIDField()
}

type withDrawWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaUserIDEqualsParam) userIDField() {}

func (withDrawWithPrismaUserIDSetParam) settable()  {}
func (withDrawWithPrismaUserIDEqualsParam) equals() {}

type withDrawWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaUserIDEqualsUniqueParam) userIDField()   {}

func (withDrawWithPrismaUserIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaUserIDEqualsUniqueParam) equals() {}

type WithDrawWithPrismaDepositEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	depositField()
}

type WithDrawWithPrismaDepositSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositField()
}

type withDrawWithPrismaDepositSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositSetParam) withDrawModel() {}

func (p withDrawWithPrismaDepositSetParam) depositField() {}

type WithDrawWithPrismaDepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositField()
}

type withDrawWithPrismaDepositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaDepositEqualsParam) depositField() {}

func (withDrawWithPrismaDepositSetParam) settable()  {}
func (withDrawWithPrismaDepositEqualsParam) equals() {}

type withDrawWithPrismaDepositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaDepositEqualsUniqueParam) depositField()  {}

func (withDrawWithPrismaDepositEqualsUniqueParam) unique() {}
func (withDrawWithPrismaDepositEqualsUniqueParam) equals() {}

type WithDrawWithPrismaDepositIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	depositIDField()
}

type WithDrawWithPrismaDepositIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositIDField()
}

type withDrawWithPrismaDepositIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaDepositIDSetParam) depositIDField() {}

type WithDrawWithPrismaDepositIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositIDField()
}

type withDrawWithPrismaDepositIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaDepositIDEqualsParam) depositIDField() {}

func (withDrawWithPrismaDepositIDSetParam) settable()  {}
func (withDrawWithPrismaDepositIDEqualsParam) equals() {}

type withDrawWithPrismaDepositIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) withDrawModel()  {}
func (p withDrawWithPrismaDepositIDEqualsUniqueParam) depositIDField() {}

func (withDrawWithPrismaDepositIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaDepositIDEqualsUniqueParam) equals() {}

type depositTransactionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var depositTransactionOutput = []builder.Output{
	{Name: "id"},
	{Name: "amount"},
	{Name: "depositId"},
}

type DepositTransactionRelationWith interface {
	getQuery() builder.Query
	with()
	depositTransactionRelation()
}

type DepositTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
}

type depositTransactionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionDefaultParam) field() builder.Field {
	return p.data
}

func (p depositTransactionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionDefaultParam) depositTransactionModel() {}

type DepositTransactionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
}

type depositTransactionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionOrderByParam) field() builder.Field {
	return p.data
}

func (p depositTransactionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionOrderByParam) depositTransactionModel() {}

type DepositTransactionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	isCursor()
}

type depositTransactionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionCursorParam) field() builder.Field {
	return p.data
}

func (p depositTransactionCursorParam) isCursor() {}

func (p depositTransactionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionCursorParam) depositTransactionModel() {}

type DepositTransactionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	depositTransactionModel()
}

type depositTransactionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionParamUnique) depositTransactionModel() {}

func (depositTransactionParamUnique) unique() {}

func (p depositTransactionParamUnique) field() builder.Field {
	return p.data
}

func (p depositTransactionParamUnique) getQuery() builder.Query {
	return p.query
}

type DepositTransactionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
}

type depositTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionEqualsParam) depositTransactionModel() {}

func (depositTransactionEqualsParam) equals() {}

func (p depositTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

type DepositTransactionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	depositTransactionModel()
}

type depositTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionEqualsUniqueParam) depositTransactionModel() {}

func (depositTransactionEqualsUniqueParam) unique() {}
func (depositTransactionEqualsUniqueParam) equals() {}

func (p depositTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DepositTransactionSetParam interface {
	field() builder.Field
	settable()
	depositTransactionModel()
}

type depositTransactionSetParam struct {
	data builder.Field
}

func (depositTransactionSetParam) settable() {}

func (p depositTransactionSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionSetParam) depositTransactionModel() {}

type DepositTransactionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	idField()
}

type DepositTransactionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	idField()
}

type depositTransactionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaIDSetParam) idField() {}

type DepositTransactionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	idField()
}

type depositTransactionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaIDEqualsParam) idField() {}

func (depositTransactionWithPrismaIDSetParam) settable()  {}
func (depositTransactionWithPrismaIDEqualsParam) equals() {}

type depositTransactionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaIDEqualsUniqueParam) idField()                 {}

func (depositTransactionWithPrismaIDEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaIDEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaAmountEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	amountField()
}

type DepositTransactionWithPrismaAmountSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	amountField()
}

type depositTransactionWithPrismaAmountSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaAmountSetParam) amountField() {}

type DepositTransactionWithPrismaAmountWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	amountField()
}

type depositTransactionWithPrismaAmountEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaAmountEqualsParam) amountField() {}

func (depositTransactionWithPrismaAmountSetParam) settable()  {}
func (depositTransactionWithPrismaAmountEqualsParam) equals() {}

type depositTransactionWithPrismaAmountEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaAmountEqualsUniqueParam) amountField()             {}

func (depositTransactionWithPrismaAmountEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaAmountEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaDepositEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	depositField()
}

type DepositTransactionWithPrismaDepositSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositField()
}

type depositTransactionWithPrismaDepositSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositSetParam) depositField() {}

type DepositTransactionWithPrismaDepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositField()
}

type depositTransactionWithPrismaDepositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositEqualsParam) depositField() {}

func (depositTransactionWithPrismaDepositSetParam) settable()  {}
func (depositTransactionWithPrismaDepositEqualsParam) equals() {}

type depositTransactionWithPrismaDepositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaDepositEqualsUniqueParam) depositField()            {}

func (depositTransactionWithPrismaDepositEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaDepositEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaDepositIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	depositIDField()
}

type DepositTransactionWithPrismaDepositIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositIDField()
}

type depositTransactionWithPrismaDepositIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositIDSetParam) depositIDField() {}

type DepositTransactionWithPrismaDepositIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositIDField()
}

type depositTransactionWithPrismaDepositIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositIDEqualsParam) depositIDField() {}

func (depositTransactionWithPrismaDepositIDSetParam) settable()  {}
func (depositTransactionWithPrismaDepositIDEqualsParam) equals() {}

type depositTransactionWithPrismaDepositIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) depositIDField()          {}

func (depositTransactionWithPrismaDepositIDEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaDepositIDEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_username UserWithPrismaUsernameSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _username.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single masterPaymentType.
func (r masterPaymentTypeActions) CreateOne(
	_name MasterPaymentTypeWithPrismaNameSetParam,

	optional ...MasterPaymentTypeSetParam,
) masterPaymentTypeCreateOne {
	var v masterPaymentTypeCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "MasterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	var fields []builder.Field

	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r masterPaymentTypeCreateOne) With(params ...MasterPaymentTypeRelationWith) masterPaymentTypeCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type masterPaymentTypeCreateOne struct {
	query builder.Query
}

func (p masterPaymentTypeCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p masterPaymentTypeCreateOne) masterPaymentTypeModel() {}

func (r masterPaymentTypeCreateOne) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeCreateOne) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single userPaymentTypes.
func (r userPaymentTypesActions) CreateOne(
	_user UserPaymentTypesWithPrismaUserSetParam,
	_masterPaymentType UserPaymentTypesWithPrismaMasterPaymentTypeSetParam,

	optional ...UserPaymentTypesSetParam,
) userPaymentTypesCreateOne {
	var v userPaymentTypesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _masterPaymentType.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userPaymentTypesCreateOne) With(params ...UserPaymentTypesRelationWith) userPaymentTypesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userPaymentTypesCreateOne struct {
	query builder.Query
}

func (p userPaymentTypesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userPaymentTypesCreateOne) userPaymentTypesModel() {}

func (r userPaymentTypesCreateOne) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesCreateOne) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single transaction.
func (r transactionActions) CreateOne(
	_user TransactionWithPrismaUserSetParam,
	_toAddress TransactionWithPrismaToAddressSetParam,
	_fromAddress TransactionWithPrismaFromAddressSetParam,
	_currency TransactionWithPrismaCurrencySetParam,

	optional ...TransactionSetParam,
) transactionCreateOne {
	var v transactionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _toAddress.field())
	fields = append(fields, _fromAddress.field())
	fields = append(fields, _currency.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transactionCreateOne) With(params ...TransactionRelationWith) transactionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transactionCreateOne struct {
	query builder.Query
}

func (p transactionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transactionCreateOne) transactionModel() {}

func (r transactionCreateOne) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionCreateOne) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single transactionHistory.
func (r transactionHistoryActions) CreateOne(
	_transaction TransactionHistoryWithPrismaTransactionSetParam,
	_status TransactionHistoryWithPrismaStatusSetParam,

	optional ...TransactionHistorySetParam,
) transactionHistoryCreateOne {
	var v transactionHistoryCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var fields []builder.Field

	fields = append(fields, _transaction.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transactionHistoryCreateOne) With(params ...TransactionHistoryRelationWith) transactionHistoryCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transactionHistoryCreateOne struct {
	query builder.Query
}

func (p transactionHistoryCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transactionHistoryCreateOne) transactionHistoryModel() {}

func (r transactionHistoryCreateOne) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryCreateOne) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single deposit.
func (r depositActions) CreateOne(
	_user DepositWithPrismaUserSetParam,
	_amount DepositWithPrismaAmountSetParam,

	optional ...DepositSetParam,
) depositCreateOne {
	var v depositCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _amount.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r depositCreateOne) With(params ...DepositRelationWith) depositCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type depositCreateOne struct {
	query builder.Query
}

func (p depositCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p depositCreateOne) depositModel() {}

func (r depositCreateOne) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositCreateOne) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single withDraw.
func (r withDrawActions) CreateOne(
	_charge WithDrawWithPrismaChargeSetParam,
	_user WithDrawWithPrismaUserSetParam,
	_deposit WithDrawWithPrismaDepositSetParam,

	optional ...WithDrawSetParam,
) withDrawCreateOne {
	var v withDrawCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var fields []builder.Field

	fields = append(fields, _charge.field())
	fields = append(fields, _user.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r withDrawCreateOne) With(params ...WithDrawRelationWith) withDrawCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type withDrawCreateOne struct {
	query builder.Query
}

func (p withDrawCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p withDrawCreateOne) withDrawModel() {}

func (r withDrawCreateOne) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawCreateOne) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single depositTransaction.
func (r depositTransactionActions) CreateOne(
	_amount DepositTransactionWithPrismaAmountSetParam,
	_deposit DepositTransactionWithPrismaDepositSetParam,

	optional ...DepositTransactionSetParam,
) depositTransactionCreateOne {
	var v depositTransactionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var fields []builder.Field

	fields = append(fields, _amount.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r depositTransactionCreateOne) With(params ...DepositTransactionRelationWith) depositTransactionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type depositTransactionCreateOne struct {
	query builder.Query
}

func (p depositTransactionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p depositTransactionCreateOne) depositTransactionModel() {}

func (r depositTransactionCreateOne) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionCreateOne) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToUserPaymentTypesFindUnique struct {
	query builder.Query
}

func (r userToUserPaymentTypesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindUnique) with()         {}
func (r userToUserPaymentTypesFindUnique) userModel()    {}
func (r userToUserPaymentTypesFindUnique) userRelation() {}

func (r userToUserPaymentTypesFindUnique) With(params ...UserPaymentTypesRelationWith) userToUserPaymentTypesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToUserPaymentTypesFindUnique) Select(params ...userPrismaFields) userToUserPaymentTypesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindUnique) Omit(params ...userPrismaFields) userToUserPaymentTypesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToUserPaymentTypesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToUserPaymentTypesFindUnique) Update(params ...UserSetParam) userToUserPaymentTypesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToUserPaymentTypesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToUserPaymentTypesUpdateUnique struct {
	query builder.Query
}

func (r userToUserPaymentTypesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesUpdateUnique) userModel() {}

func (r userToUserPaymentTypesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToUserPaymentTypesUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToUserPaymentTypesFindUnique) Delete() userToUserPaymentTypesDeleteUnique {
	var v userToUserPaymentTypesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToUserPaymentTypesDeleteUnique struct {
	query builder.Query
}

func (r userToUserPaymentTypesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToUserPaymentTypesDeleteUnique) userModel() {}

func (r userToUserPaymentTypesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToUserPaymentTypesDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToUserPaymentTypesFindFirst struct {
	query builder.Query
}

func (r userToUserPaymentTypesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindFirst) with()         {}
func (r userToUserPaymentTypesFindFirst) userModel()    {}
func (r userToUserPaymentTypesFindFirst) userRelation() {}

func (r userToUserPaymentTypesFindFirst) With(params ...UserPaymentTypesRelationWith) userToUserPaymentTypesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToUserPaymentTypesFindFirst) Select(params ...userPrismaFields) userToUserPaymentTypesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindFirst) Omit(params ...userPrismaFields) userToUserPaymentTypesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindFirst) OrderBy(params ...UserPaymentTypesOrderByParam) userToUserPaymentTypesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToUserPaymentTypesFindFirst) Skip(count int) userToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToUserPaymentTypesFindFirst) Take(count int) userToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToUserPaymentTypesFindFirst) Cursor(cursor UserCursorParam) userToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToUserPaymentTypesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToUserPaymentTypesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToUserPaymentTypesFindMany struct {
	query builder.Query
}

func (r userToUserPaymentTypesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesFindMany) with()         {}
func (r userToUserPaymentTypesFindMany) userModel()    {}
func (r userToUserPaymentTypesFindMany) userRelation() {}

func (r userToUserPaymentTypesFindMany) With(params ...UserPaymentTypesRelationWith) userToUserPaymentTypesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToUserPaymentTypesFindMany) Select(params ...userPrismaFields) userToUserPaymentTypesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindMany) Omit(params ...userPrismaFields) userToUserPaymentTypesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToUserPaymentTypesFindMany) OrderBy(params ...UserPaymentTypesOrderByParam) userToUserPaymentTypesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToUserPaymentTypesFindMany) Skip(count int) userToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToUserPaymentTypesFindMany) Take(count int) userToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToUserPaymentTypesFindMany) Cursor(cursor UserCursorParam) userToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToUserPaymentTypesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToUserPaymentTypesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToUserPaymentTypesFindMany) Update(params ...UserSetParam) userToUserPaymentTypesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToUserPaymentTypesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToUserPaymentTypesUpdateMany struct {
	query builder.Query
}

func (r userToUserPaymentTypesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToUserPaymentTypesUpdateMany) userModel() {}

func (r userToUserPaymentTypesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToUserPaymentTypesUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToUserPaymentTypesFindMany) Delete() userToUserPaymentTypesDeleteMany {
	var v userToUserPaymentTypesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToUserPaymentTypesDeleteMany struct {
	query builder.Query
}

func (r userToUserPaymentTypesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToUserPaymentTypesDeleteMany) userModel() {}

func (r userToUserPaymentTypesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToUserPaymentTypesDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToDepositFindUnique struct {
	query builder.Query
}

func (r userToDepositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToDepositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDepositFindUnique) with()         {}
func (r userToDepositFindUnique) userModel()    {}
func (r userToDepositFindUnique) userRelation() {}

func (r userToDepositFindUnique) With(params ...DepositRelationWith) userToDepositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDepositFindUnique) Select(params ...userPrismaFields) userToDepositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindUnique) Omit(params ...userPrismaFields) userToDepositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDepositFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDepositFindUnique) Update(params ...UserSetParam) userToDepositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToDepositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToDepositUpdateUnique struct {
	query builder.Query
}

func (r userToDepositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDepositUpdateUnique) userModel() {}

func (r userToDepositUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDepositUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToDepositFindUnique) Delete() userToDepositDeleteUnique {
	var v userToDepositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToDepositDeleteUnique struct {
	query builder.Query
}

func (r userToDepositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToDepositDeleteUnique) userModel() {}

func (r userToDepositDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDepositDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToDepositFindFirst struct {
	query builder.Query
}

func (r userToDepositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToDepositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDepositFindFirst) with()         {}
func (r userToDepositFindFirst) userModel()    {}
func (r userToDepositFindFirst) userRelation() {}

func (r userToDepositFindFirst) With(params ...DepositRelationWith) userToDepositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDepositFindFirst) Select(params ...userPrismaFields) userToDepositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindFirst) Omit(params ...userPrismaFields) userToDepositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindFirst) OrderBy(params ...DepositOrderByParam) userToDepositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToDepositFindFirst) Skip(count int) userToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToDepositFindFirst) Take(count int) userToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToDepositFindFirst) Cursor(cursor UserCursorParam) userToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToDepositFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToDepositFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToDepositFindMany struct {
	query builder.Query
}

func (r userToDepositFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToDepositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDepositFindMany) with()         {}
func (r userToDepositFindMany) userModel()    {}
func (r userToDepositFindMany) userRelation() {}

func (r userToDepositFindMany) With(params ...DepositRelationWith) userToDepositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToDepositFindMany) Select(params ...userPrismaFields) userToDepositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindMany) Omit(params ...userPrismaFields) userToDepositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToDepositFindMany) OrderBy(params ...DepositOrderByParam) userToDepositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToDepositFindMany) Skip(count int) userToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToDepositFindMany) Take(count int) userToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToDepositFindMany) Cursor(cursor UserCursorParam) userToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToDepositFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToDepositFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToDepositFindMany) Update(params ...UserSetParam) userToDepositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToDepositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToDepositUpdateMany struct {
	query builder.Query
}

func (r userToDepositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToDepositUpdateMany) userModel() {}

func (r userToDepositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDepositUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToDepositFindMany) Delete() userToDepositDeleteMany {
	var v userToDepositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToDepositDeleteMany struct {
	query builder.Query
}

func (r userToDepositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToDepositDeleteMany) userModel() {}

func (r userToDepositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToDepositDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToTransactionFindUnique struct {
	query builder.Query
}

func (r userToTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindUnique) with()         {}
func (r userToTransactionFindUnique) userModel()    {}
func (r userToTransactionFindUnique) userRelation() {}

func (r userToTransactionFindUnique) With(params ...TransactionRelationWith) userToTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTransactionFindUnique) Select(params ...userPrismaFields) userToTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindUnique) Omit(params ...userPrismaFields) userToTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTransactionFindUnique) Update(params ...UserSetParam) userToTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToTransactionUpdateUnique struct {
	query builder.Query
}

func (r userToTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTransactionUpdateUnique) userModel() {}

func (r userToTransactionUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTransactionUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToTransactionFindUnique) Delete() userToTransactionDeleteUnique {
	var v userToTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToTransactionDeleteUnique struct {
	query builder.Query
}

func (r userToTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToTransactionDeleteUnique) userModel() {}

func (r userToTransactionDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTransactionDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToTransactionFindFirst struct {
	query builder.Query
}

func (r userToTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindFirst) with()         {}
func (r userToTransactionFindFirst) userModel()    {}
func (r userToTransactionFindFirst) userRelation() {}

func (r userToTransactionFindFirst) With(params ...TransactionRelationWith) userToTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTransactionFindFirst) Select(params ...userPrismaFields) userToTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindFirst) Omit(params ...userPrismaFields) userToTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindFirst) OrderBy(params ...TransactionOrderByParam) userToTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToTransactionFindFirst) Skip(count int) userToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToTransactionFindFirst) Take(count int) userToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToTransactionFindFirst) Cursor(cursor UserCursorParam) userToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToTransactionFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToTransactionFindMany struct {
	query builder.Query
}

func (r userToTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTransactionFindMany) with()         {}
func (r userToTransactionFindMany) userModel()    {}
func (r userToTransactionFindMany) userRelation() {}

func (r userToTransactionFindMany) With(params ...TransactionRelationWith) userToTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToTransactionFindMany) Select(params ...userPrismaFields) userToTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindMany) Omit(params ...userPrismaFields) userToTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToTransactionFindMany) OrderBy(params ...TransactionOrderByParam) userToTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToTransactionFindMany) Skip(count int) userToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToTransactionFindMany) Take(count int) userToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToTransactionFindMany) Cursor(cursor UserCursorParam) userToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToTransactionFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToTransactionFindMany) Update(params ...UserSetParam) userToTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToTransactionUpdateMany struct {
	query builder.Query
}

func (r userToTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToTransactionUpdateMany) userModel() {}

func (r userToTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTransactionUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToTransactionFindMany) Delete() userToTransactionDeleteMany {
	var v userToTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToTransactionDeleteMany struct {
	query builder.Query
}

func (r userToTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToTransactionDeleteMany) userModel() {}

func (r userToTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToTransactionDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToWithDrawFindUnique struct {
	query builder.Query
}

func (r userToWithDrawFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindUnique) with()         {}
func (r userToWithDrawFindUnique) userModel()    {}
func (r userToWithDrawFindUnique) userRelation() {}

func (r userToWithDrawFindUnique) With(params ...WithDrawRelationWith) userToWithDrawFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWithDrawFindUnique) Select(params ...userPrismaFields) userToWithDrawFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindUnique) Omit(params ...userPrismaFields) userToWithDrawFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWithDrawFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWithDrawFindUnique) Update(params ...UserSetParam) userToWithDrawUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToWithDrawUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToWithDrawUpdateUnique struct {
	query builder.Query
}

func (r userToWithDrawUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWithDrawUpdateUnique) userModel() {}

func (r userToWithDrawUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWithDrawUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToWithDrawFindUnique) Delete() userToWithDrawDeleteUnique {
	var v userToWithDrawDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToWithDrawDeleteUnique struct {
	query builder.Query
}

func (r userToWithDrawDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToWithDrawDeleteUnique) userModel() {}

func (r userToWithDrawDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWithDrawDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToWithDrawFindFirst struct {
	query builder.Query
}

func (r userToWithDrawFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindFirst) with()         {}
func (r userToWithDrawFindFirst) userModel()    {}
func (r userToWithDrawFindFirst) userRelation() {}

func (r userToWithDrawFindFirst) With(params ...WithDrawRelationWith) userToWithDrawFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWithDrawFindFirst) Select(params ...userPrismaFields) userToWithDrawFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindFirst) Omit(params ...userPrismaFields) userToWithDrawFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindFirst) OrderBy(params ...WithDrawOrderByParam) userToWithDrawFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToWithDrawFindFirst) Skip(count int) userToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToWithDrawFindFirst) Take(count int) userToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToWithDrawFindFirst) Cursor(cursor UserCursorParam) userToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToWithDrawFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToWithDrawFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToWithDrawFindMany struct {
	query builder.Query
}

func (r userToWithDrawFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWithDrawFindMany) with()         {}
func (r userToWithDrawFindMany) userModel()    {}
func (r userToWithDrawFindMany) userRelation() {}

func (r userToWithDrawFindMany) With(params ...WithDrawRelationWith) userToWithDrawFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToWithDrawFindMany) Select(params ...userPrismaFields) userToWithDrawFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindMany) Omit(params ...userPrismaFields) userToWithDrawFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToWithDrawFindMany) OrderBy(params ...WithDrawOrderByParam) userToWithDrawFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToWithDrawFindMany) Skip(count int) userToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToWithDrawFindMany) Take(count int) userToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToWithDrawFindMany) Cursor(cursor UserCursorParam) userToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToWithDrawFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToWithDrawFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToWithDrawFindMany) Update(params ...UserSetParam) userToWithDrawUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToWithDrawUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToWithDrawUpdateMany struct {
	query builder.Query
}

func (r userToWithDrawUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToWithDrawUpdateMany) userModel() {}

func (r userToWithDrawUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWithDrawUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToWithDrawFindMany) Delete() userToWithDrawDeleteMany {
	var v userToWithDrawDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToWithDrawDeleteMany struct {
	query builder.Query
}

func (r userToWithDrawDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToWithDrawDeleteMany) userModel() {}

func (r userToWithDrawDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToWithDrawDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type masterPaymentTypeToUserPaymentTypesFindUnique struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) with()                      {}
func (r masterPaymentTypeToUserPaymentTypesFindUnique) masterPaymentTypeModel()    {}
func (r masterPaymentTypeToUserPaymentTypesFindUnique) masterPaymentTypeRelation() {}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) With(params ...UserPaymentTypesRelationWith) masterPaymentTypeToUserPaymentTypesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) Exec(ctx context.Context) (
	*MasterPaymentTypeModel,
	error,
) {
	var v *MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) ExecInner(ctx context.Context) (
	*InnerMasterPaymentType,
	error,
) {
	var v *InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) Update(params ...MasterPaymentTypeSetParam) masterPaymentTypeToUserPaymentTypesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "MasterPaymentType"

	var v masterPaymentTypeToUserPaymentTypesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type masterPaymentTypeToUserPaymentTypesUpdateUnique struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesUpdateUnique) masterPaymentTypeModel() {}

func (r masterPaymentTypeToUserPaymentTypesUpdateUnique) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeToUserPaymentTypesUpdateUnique) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r masterPaymentTypeToUserPaymentTypesFindUnique) Delete() masterPaymentTypeToUserPaymentTypesDeleteUnique {
	var v masterPaymentTypeToUserPaymentTypesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "MasterPaymentType"

	return v
}

type masterPaymentTypeToUserPaymentTypesDeleteUnique struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p masterPaymentTypeToUserPaymentTypesDeleteUnique) masterPaymentTypeModel() {}

func (r masterPaymentTypeToUserPaymentTypesDeleteUnique) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeToUserPaymentTypesDeleteUnique) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type masterPaymentTypeToUserPaymentTypesFindFirst struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) with()                      {}
func (r masterPaymentTypeToUserPaymentTypesFindFirst) masterPaymentTypeModel()    {}
func (r masterPaymentTypeToUserPaymentTypesFindFirst) masterPaymentTypeRelation() {}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) With(params ...UserPaymentTypesRelationWith) masterPaymentTypeToUserPaymentTypesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) OrderBy(params ...UserPaymentTypesOrderByParam) masterPaymentTypeToUserPaymentTypesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Skip(count int) masterPaymentTypeToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Take(count int) masterPaymentTypeToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Cursor(cursor MasterPaymentTypeCursorParam) masterPaymentTypeToUserPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) Exec(ctx context.Context) (
	*MasterPaymentTypeModel,
	error,
) {
	var v *MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeToUserPaymentTypesFindFirst) ExecInner(ctx context.Context) (
	*InnerMasterPaymentType,
	error,
) {
	var v *InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type masterPaymentTypeToUserPaymentTypesFindMany struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) with()                      {}
func (r masterPaymentTypeToUserPaymentTypesFindMany) masterPaymentTypeModel()    {}
func (r masterPaymentTypeToUserPaymentTypesFindMany) masterPaymentTypeRelation() {}

func (r masterPaymentTypeToUserPaymentTypesFindMany) With(params ...UserPaymentTypesRelationWith) masterPaymentTypeToUserPaymentTypesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeToUserPaymentTypesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) OrderBy(params ...UserPaymentTypesOrderByParam) masterPaymentTypeToUserPaymentTypesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Skip(count int) masterPaymentTypeToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Take(count int) masterPaymentTypeToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Cursor(cursor MasterPaymentTypeCursorParam) masterPaymentTypeToUserPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Exec(ctx context.Context) (
	[]MasterPaymentTypeModel,
	error,
) {
	var v []MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) ExecInner(ctx context.Context) (
	[]InnerMasterPaymentType,
	error,
) {
	var v []InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Update(params ...MasterPaymentTypeSetParam) masterPaymentTypeToUserPaymentTypesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "MasterPaymentType"

	r.query.Outputs = countOutput

	var v masterPaymentTypeToUserPaymentTypesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type masterPaymentTypeToUserPaymentTypesUpdateMany struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeToUserPaymentTypesUpdateMany) masterPaymentTypeModel() {}

func (r masterPaymentTypeToUserPaymentTypesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeToUserPaymentTypesUpdateMany) Tx() MasterPaymentTypeManyTxResult {
	v := newMasterPaymentTypeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r masterPaymentTypeToUserPaymentTypesFindMany) Delete() masterPaymentTypeToUserPaymentTypesDeleteMany {
	var v masterPaymentTypeToUserPaymentTypesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "MasterPaymentType"

	v.query.Outputs = countOutput

	return v
}

type masterPaymentTypeToUserPaymentTypesDeleteMany struct {
	query builder.Query
}

func (r masterPaymentTypeToUserPaymentTypesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p masterPaymentTypeToUserPaymentTypesDeleteMany) masterPaymentTypeModel() {}

func (r masterPaymentTypeToUserPaymentTypesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeToUserPaymentTypesDeleteMany) Tx() MasterPaymentTypeManyTxResult {
	v := newMasterPaymentTypeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type masterPaymentTypeFindUnique struct {
	query builder.Query
}

func (r masterPaymentTypeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindUnique) with()                      {}
func (r masterPaymentTypeFindUnique) masterPaymentTypeModel()    {}
func (r masterPaymentTypeFindUnique) masterPaymentTypeRelation() {}

func (r masterPaymentTypeActions) FindUnique(
	params MasterPaymentTypeEqualsUniqueWhereParam,
) masterPaymentTypeFindUnique {
	var v masterPaymentTypeFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "MasterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r masterPaymentTypeFindUnique) With(params ...MasterPaymentTypeRelationWith) masterPaymentTypeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeFindUnique) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindUnique) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindUnique) Exec(ctx context.Context) (
	*MasterPaymentTypeModel,
	error,
) {
	var v *MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeFindUnique) ExecInner(ctx context.Context) (
	*InnerMasterPaymentType,
	error,
) {
	var v *InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeFindUnique) Update(params ...MasterPaymentTypeSetParam) masterPaymentTypeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "MasterPaymentType"

	var v masterPaymentTypeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type masterPaymentTypeUpdateUnique struct {
	query builder.Query
}

func (r masterPaymentTypeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeUpdateUnique) masterPaymentTypeModel() {}

func (r masterPaymentTypeUpdateUnique) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeUpdateUnique) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r masterPaymentTypeFindUnique) Delete() masterPaymentTypeDeleteUnique {
	var v masterPaymentTypeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "MasterPaymentType"

	return v
}

type masterPaymentTypeDeleteUnique struct {
	query builder.Query
}

func (r masterPaymentTypeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p masterPaymentTypeDeleteUnique) masterPaymentTypeModel() {}

func (r masterPaymentTypeDeleteUnique) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeDeleteUnique) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type masterPaymentTypeFindFirst struct {
	query builder.Query
}

func (r masterPaymentTypeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindFirst) with()                      {}
func (r masterPaymentTypeFindFirst) masterPaymentTypeModel()    {}
func (r masterPaymentTypeFindFirst) masterPaymentTypeRelation() {}

func (r masterPaymentTypeActions) FindFirst(
	params ...MasterPaymentTypeWhereParam,
) masterPaymentTypeFindFirst {
	var v masterPaymentTypeFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "MasterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r masterPaymentTypeFindFirst) With(params ...MasterPaymentTypeRelationWith) masterPaymentTypeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeFindFirst) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindFirst) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindFirst) OrderBy(params ...MasterPaymentTypeOrderByParam) masterPaymentTypeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r masterPaymentTypeFindFirst) Skip(count int) masterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeFindFirst) Take(count int) masterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeFindFirst) Cursor(cursor MasterPaymentTypeCursorParam) masterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r masterPaymentTypeFindFirst) Exec(ctx context.Context) (
	*MasterPaymentTypeModel,
	error,
) {
	var v *MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r masterPaymentTypeFindFirst) ExecInner(ctx context.Context) (
	*InnerMasterPaymentType,
	error,
) {
	var v *InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type masterPaymentTypeFindMany struct {
	query builder.Query
}

func (r masterPaymentTypeFindMany) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeFindMany) with()                      {}
func (r masterPaymentTypeFindMany) masterPaymentTypeModel()    {}
func (r masterPaymentTypeFindMany) masterPaymentTypeRelation() {}

func (r masterPaymentTypeActions) FindMany(
	params ...MasterPaymentTypeWhereParam,
) masterPaymentTypeFindMany {
	var v masterPaymentTypeFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "MasterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r masterPaymentTypeFindMany) With(params ...MasterPaymentTypeRelationWith) masterPaymentTypeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r masterPaymentTypeFindMany) Select(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindMany) Omit(params ...masterPaymentTypePrismaFields) masterPaymentTypeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range masterPaymentTypeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r masterPaymentTypeFindMany) OrderBy(params ...MasterPaymentTypeOrderByParam) masterPaymentTypeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r masterPaymentTypeFindMany) Skip(count int) masterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeFindMany) Take(count int) masterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r masterPaymentTypeFindMany) Cursor(cursor MasterPaymentTypeCursorParam) masterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r masterPaymentTypeFindMany) Exec(ctx context.Context) (
	[]MasterPaymentTypeModel,
	error,
) {
	var v []MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r masterPaymentTypeFindMany) ExecInner(ctx context.Context) (
	[]InnerMasterPaymentType,
	error,
) {
	var v []InnerMasterPaymentType
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r masterPaymentTypeFindMany) Update(params ...MasterPaymentTypeSetParam) masterPaymentTypeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "MasterPaymentType"

	r.query.Outputs = countOutput

	var v masterPaymentTypeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type masterPaymentTypeUpdateMany struct {
	query builder.Query
}

func (r masterPaymentTypeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeUpdateMany) masterPaymentTypeModel() {}

func (r masterPaymentTypeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeUpdateMany) Tx() MasterPaymentTypeManyTxResult {
	v := newMasterPaymentTypeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r masterPaymentTypeFindMany) Delete() masterPaymentTypeDeleteMany {
	var v masterPaymentTypeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "MasterPaymentType"

	v.query.Outputs = countOutput

	return v
}

type masterPaymentTypeDeleteMany struct {
	query builder.Query
}

func (r masterPaymentTypeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p masterPaymentTypeDeleteMany) masterPaymentTypeModel() {}

func (r masterPaymentTypeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeDeleteMany) Tx() MasterPaymentTypeManyTxResult {
	v := newMasterPaymentTypeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesToUserFindUnique struct {
	query builder.Query
}

func (r userPaymentTypesToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindUnique) with()                     {}
func (r userPaymentTypesToUserFindUnique) userPaymentTypesModel()    {}
func (r userPaymentTypesToUserFindUnique) userPaymentTypesRelation() {}

func (r userPaymentTypesToUserFindUnique) With(params ...UserRelationWith) userPaymentTypesToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToUserFindUnique) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindUnique) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindUnique) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToUserFindUnique) Update(params ...UserPaymentTypesSetParam) userPaymentTypesToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "UserPaymentTypes"

	var v userPaymentTypesToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesToUserUpdateUnique struct {
	query builder.Query
}

func (r userPaymentTypesToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserUpdateUnique) userPaymentTypesModel() {}

func (r userPaymentTypesToUserUpdateUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToUserUpdateUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesToUserFindUnique) Delete() userPaymentTypesToUserDeleteUnique {
	var v userPaymentTypesToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "UserPaymentTypes"

	return v
}

type userPaymentTypesToUserDeleteUnique struct {
	query builder.Query
}

func (r userPaymentTypesToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesToUserDeleteUnique) userPaymentTypesModel() {}

func (r userPaymentTypesToUserDeleteUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToUserDeleteUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesToUserFindFirst struct {
	query builder.Query
}

func (r userPaymentTypesToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindFirst) with()                     {}
func (r userPaymentTypesToUserFindFirst) userPaymentTypesModel()    {}
func (r userPaymentTypesToUserFindFirst) userPaymentTypesRelation() {}

func (r userPaymentTypesToUserFindFirst) With(params ...UserRelationWith) userPaymentTypesToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToUserFindFirst) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindFirst) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindFirst) OrderBy(params ...UserOrderByParam) userPaymentTypesToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesToUserFindFirst) Skip(count int) userPaymentTypesToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToUserFindFirst) Take(count int) userPaymentTypesToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToUserFindFirst) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesToUserFindFirst) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userPaymentTypesToUserFindMany struct {
	query builder.Query
}

func (r userPaymentTypesToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserFindMany) with()                     {}
func (r userPaymentTypesToUserFindMany) userPaymentTypesModel()    {}
func (r userPaymentTypesToUserFindMany) userPaymentTypesRelation() {}

func (r userPaymentTypesToUserFindMany) With(params ...UserRelationWith) userPaymentTypesToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToUserFindMany) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindMany) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToUserFindMany) OrderBy(params ...UserOrderByParam) userPaymentTypesToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesToUserFindMany) Skip(count int) userPaymentTypesToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToUserFindMany) Take(count int) userPaymentTypesToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToUserFindMany) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesToUserFindMany) Exec(ctx context.Context) (
	[]UserPaymentTypesModel,
	error,
) {
	var v []UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerUserPaymentTypes,
	error,
) {
	var v []InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesToUserFindMany) Update(params ...UserPaymentTypesSetParam) userPaymentTypesToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "UserPaymentTypes"

	r.query.Outputs = countOutput

	var v userPaymentTypesToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesToUserUpdateMany struct {
	query builder.Query
}

func (r userPaymentTypesToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToUserUpdateMany) userPaymentTypesModel() {}

func (r userPaymentTypesToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToUserUpdateMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesToUserFindMany) Delete() userPaymentTypesToUserDeleteMany {
	var v userPaymentTypesToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "UserPaymentTypes"

	v.query.Outputs = countOutput

	return v
}

type userPaymentTypesToUserDeleteMany struct {
	query builder.Query
}

func (r userPaymentTypesToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesToUserDeleteMany) userPaymentTypesModel() {}

func (r userPaymentTypesToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToUserDeleteMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesToMasterPaymentTypeFindUnique struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) with()                     {}
func (r userPaymentTypesToMasterPaymentTypeFindUnique) userPaymentTypesModel()    {}
func (r userPaymentTypesToMasterPaymentTypeFindUnique) userPaymentTypesRelation() {}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) With(params ...MasterPaymentTypeRelationWith) userPaymentTypesToMasterPaymentTypeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) Update(params ...UserPaymentTypesSetParam) userPaymentTypesToMasterPaymentTypeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "UserPaymentTypes"

	var v userPaymentTypesToMasterPaymentTypeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesToMasterPaymentTypeUpdateUnique struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeUpdateUnique) userPaymentTypesModel() {}

func (r userPaymentTypesToMasterPaymentTypeUpdateUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToMasterPaymentTypeUpdateUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesToMasterPaymentTypeFindUnique) Delete() userPaymentTypesToMasterPaymentTypeDeleteUnique {
	var v userPaymentTypesToMasterPaymentTypeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "UserPaymentTypes"

	return v
}

type userPaymentTypesToMasterPaymentTypeDeleteUnique struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesToMasterPaymentTypeDeleteUnique) userPaymentTypesModel() {}

func (r userPaymentTypesToMasterPaymentTypeDeleteUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToMasterPaymentTypeDeleteUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesToMasterPaymentTypeFindFirst struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) with()                     {}
func (r userPaymentTypesToMasterPaymentTypeFindFirst) userPaymentTypesModel()    {}
func (r userPaymentTypesToMasterPaymentTypeFindFirst) userPaymentTypesRelation() {}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) With(params ...MasterPaymentTypeRelationWith) userPaymentTypesToMasterPaymentTypeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) OrderBy(params ...MasterPaymentTypeOrderByParam) userPaymentTypesToMasterPaymentTypeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Skip(count int) userPaymentTypesToMasterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Take(count int) userPaymentTypesToMasterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesToMasterPaymentTypeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesToMasterPaymentTypeFindFirst) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userPaymentTypesToMasterPaymentTypeFindMany struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) with()                     {}
func (r userPaymentTypesToMasterPaymentTypeFindMany) userPaymentTypesModel()    {}
func (r userPaymentTypesToMasterPaymentTypeFindMany) userPaymentTypesRelation() {}

func (r userPaymentTypesToMasterPaymentTypeFindMany) With(params ...MasterPaymentTypeRelationWith) userPaymentTypesToMasterPaymentTypeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesToMasterPaymentTypeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) OrderBy(params ...MasterPaymentTypeOrderByParam) userPaymentTypesToMasterPaymentTypeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Skip(count int) userPaymentTypesToMasterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Take(count int) userPaymentTypesToMasterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesToMasterPaymentTypeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Exec(ctx context.Context) (
	[]UserPaymentTypesModel,
	error,
) {
	var v []UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) ExecInner(ctx context.Context) (
	[]InnerUserPaymentTypes,
	error,
) {
	var v []InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Update(params ...UserPaymentTypesSetParam) userPaymentTypesToMasterPaymentTypeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "UserPaymentTypes"

	r.query.Outputs = countOutput

	var v userPaymentTypesToMasterPaymentTypeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesToMasterPaymentTypeUpdateMany struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesToMasterPaymentTypeUpdateMany) userPaymentTypesModel() {}

func (r userPaymentTypesToMasterPaymentTypeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToMasterPaymentTypeUpdateMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesToMasterPaymentTypeFindMany) Delete() userPaymentTypesToMasterPaymentTypeDeleteMany {
	var v userPaymentTypesToMasterPaymentTypeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "UserPaymentTypes"

	v.query.Outputs = countOutput

	return v
}

type userPaymentTypesToMasterPaymentTypeDeleteMany struct {
	query builder.Query
}

func (r userPaymentTypesToMasterPaymentTypeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesToMasterPaymentTypeDeleteMany) userPaymentTypesModel() {}

func (r userPaymentTypesToMasterPaymentTypeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesToMasterPaymentTypeDeleteMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesFindUnique struct {
	query builder.Query
}

func (r userPaymentTypesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindUnique) with()                     {}
func (r userPaymentTypesFindUnique) userPaymentTypesModel()    {}
func (r userPaymentTypesFindUnique) userPaymentTypesRelation() {}

func (r userPaymentTypesActions) FindUnique(
	params UserPaymentTypesEqualsUniqueWhereParam,
) userPaymentTypesFindUnique {
	var v userPaymentTypesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userPaymentTypesFindUnique) With(params ...UserPaymentTypesRelationWith) userPaymentTypesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesFindUnique) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindUnique) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindUnique) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesFindUnique) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesFindUnique) Update(params ...UserPaymentTypesSetParam) userPaymentTypesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "UserPaymentTypes"

	var v userPaymentTypesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesUpdateUnique struct {
	query builder.Query
}

func (r userPaymentTypesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesUpdateUnique) userPaymentTypesModel() {}

func (r userPaymentTypesUpdateUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesUpdateUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesFindUnique) Delete() userPaymentTypesDeleteUnique {
	var v userPaymentTypesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "UserPaymentTypes"

	return v
}

type userPaymentTypesDeleteUnique struct {
	query builder.Query
}

func (r userPaymentTypesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesDeleteUnique) userPaymentTypesModel() {}

func (r userPaymentTypesDeleteUnique) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesDeleteUnique) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesFindFirst struct {
	query builder.Query
}

func (r userPaymentTypesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindFirst) with()                     {}
func (r userPaymentTypesFindFirst) userPaymentTypesModel()    {}
func (r userPaymentTypesFindFirst) userPaymentTypesRelation() {}

func (r userPaymentTypesActions) FindFirst(
	params ...UserPaymentTypesWhereParam,
) userPaymentTypesFindFirst {
	var v userPaymentTypesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userPaymentTypesFindFirst) With(params ...UserPaymentTypesRelationWith) userPaymentTypesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesFindFirst) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindFirst) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindFirst) OrderBy(params ...UserPaymentTypesOrderByParam) userPaymentTypesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesFindFirst) Skip(count int) userPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesFindFirst) Take(count int) userPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesFindFirst) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesFindFirst) Exec(ctx context.Context) (
	*UserPaymentTypesModel,
	error,
) {
	var v *UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userPaymentTypesFindFirst) ExecInner(ctx context.Context) (
	*InnerUserPaymentTypes,
	error,
) {
	var v *InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userPaymentTypesFindMany struct {
	query builder.Query
}

func (r userPaymentTypesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesFindMany) with()                     {}
func (r userPaymentTypesFindMany) userPaymentTypesModel()    {}
func (r userPaymentTypesFindMany) userPaymentTypesRelation() {}

func (r userPaymentTypesActions) FindMany(
	params ...UserPaymentTypesWhereParam,
) userPaymentTypesFindMany {
	var v userPaymentTypesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userPaymentTypesFindMany) With(params ...UserPaymentTypesRelationWith) userPaymentTypesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userPaymentTypesFindMany) Select(params ...userPaymentTypesPrismaFields) userPaymentTypesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindMany) Omit(params ...userPaymentTypesPrismaFields) userPaymentTypesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userPaymentTypesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userPaymentTypesFindMany) OrderBy(params ...UserPaymentTypesOrderByParam) userPaymentTypesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userPaymentTypesFindMany) Skip(count int) userPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userPaymentTypesFindMany) Take(count int) userPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userPaymentTypesFindMany) Cursor(cursor UserPaymentTypesCursorParam) userPaymentTypesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userPaymentTypesFindMany) Exec(ctx context.Context) (
	[]UserPaymentTypesModel,
	error,
) {
	var v []UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesFindMany) ExecInner(ctx context.Context) (
	[]InnerUserPaymentTypes,
	error,
) {
	var v []InnerUserPaymentTypes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userPaymentTypesFindMany) Update(params ...UserPaymentTypesSetParam) userPaymentTypesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "UserPaymentTypes"

	r.query.Outputs = countOutput

	var v userPaymentTypesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userPaymentTypesUpdateMany struct {
	query builder.Query
}

func (r userPaymentTypesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesUpdateMany) userPaymentTypesModel() {}

func (r userPaymentTypesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesUpdateMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userPaymentTypesFindMany) Delete() userPaymentTypesDeleteMany {
	var v userPaymentTypesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "UserPaymentTypes"

	v.query.Outputs = countOutput

	return v
}

type userPaymentTypesDeleteMany struct {
	query builder.Query
}

func (r userPaymentTypesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userPaymentTypesDeleteMany) userPaymentTypesModel() {}

func (r userPaymentTypesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesDeleteMany) Tx() UserPaymentTypesManyTxResult {
	v := newUserPaymentTypesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionToUserFindUnique struct {
	query builder.Query
}

func (r transactionToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindUnique) with()                {}
func (r transactionToUserFindUnique) transactionModel()    {}
func (r transactionToUserFindUnique) transactionRelation() {}

func (r transactionToUserFindUnique) With(params ...UserRelationWith) transactionToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToUserFindUnique) Select(params ...transactionPrismaFields) transactionToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindUnique) Omit(params ...transactionPrismaFields) transactionToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindUnique) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToUserFindUnique) Update(params ...TransactionSetParam) transactionToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transaction"

	var v transactionToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToUserUpdateUnique struct {
	query builder.Query
}

func (r transactionToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToUserUpdateUnique) transactionModel() {}

func (r transactionToUserUpdateUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToUserUpdateUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToUserFindUnique) Delete() transactionToUserDeleteUnique {
	var v transactionToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transaction"

	return v
}

type transactionToUserDeleteUnique struct {
	query builder.Query
}

func (r transactionToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToUserDeleteUnique) transactionModel() {}

func (r transactionToUserDeleteUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToUserDeleteUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionToUserFindFirst struct {
	query builder.Query
}

func (r transactionToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindFirst) with()                {}
func (r transactionToUserFindFirst) transactionModel()    {}
func (r transactionToUserFindFirst) transactionRelation() {}

func (r transactionToUserFindFirst) With(params ...UserRelationWith) transactionToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToUserFindFirst) Select(params ...transactionPrismaFields) transactionToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindFirst) Omit(params ...transactionPrismaFields) transactionToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindFirst) OrderBy(params ...UserOrderByParam) transactionToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToUserFindFirst) Skip(count int) transactionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToUserFindFirst) Take(count int) transactionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToUserFindFirst) Cursor(cursor TransactionCursorParam) transactionToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToUserFindFirst) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionToUserFindMany struct {
	query builder.Query
}

func (r transactionToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToUserFindMany) with()                {}
func (r transactionToUserFindMany) transactionModel()    {}
func (r transactionToUserFindMany) transactionRelation() {}

func (r transactionToUserFindMany) With(params ...UserRelationWith) transactionToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToUserFindMany) Select(params ...transactionPrismaFields) transactionToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindMany) Omit(params ...transactionPrismaFields) transactionToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToUserFindMany) OrderBy(params ...UserOrderByParam) transactionToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToUserFindMany) Skip(count int) transactionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToUserFindMany) Take(count int) transactionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToUserFindMany) Cursor(cursor TransactionCursorParam) transactionToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToUserFindMany) Exec(ctx context.Context) (
	[]TransactionModel,
	error,
) {
	var v []TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerTransaction,
	error,
) {
	var v []InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToUserFindMany) Update(params ...TransactionSetParam) transactionToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transaction"

	r.query.Outputs = countOutput

	var v transactionToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToUserUpdateMany struct {
	query builder.Query
}

func (r transactionToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToUserUpdateMany) transactionModel() {}

func (r transactionToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToUserUpdateMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToUserFindMany) Delete() transactionToUserDeleteMany {
	var v transactionToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transaction"

	v.query.Outputs = countOutput

	return v
}

type transactionToUserDeleteMany struct {
	query builder.Query
}

func (r transactionToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToUserDeleteMany) transactionModel() {}

func (r transactionToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToUserDeleteMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionToTransactionHistoryFindUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindUnique) with()                {}
func (r transactionToTransactionHistoryFindUnique) transactionModel()    {}
func (r transactionToTransactionHistoryFindUnique) transactionRelation() {}

func (r transactionToTransactionHistoryFindUnique) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindUnique) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindUnique) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindUnique) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindUnique) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindUnique) Update(params ...TransactionSetParam) transactionToTransactionHistoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transaction"

	var v transactionToTransactionHistoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToTransactionHistoryUpdateUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryUpdateUnique) transactionModel() {}

func (r transactionToTransactionHistoryUpdateUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryUpdateUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToTransactionHistoryFindUnique) Delete() transactionToTransactionHistoryDeleteUnique {
	var v transactionToTransactionHistoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transaction"

	return v
}

type transactionToTransactionHistoryDeleteUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToTransactionHistoryDeleteUnique) transactionModel() {}

func (r transactionToTransactionHistoryDeleteUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryDeleteUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionToTransactionHistoryFindFirst struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindFirst) with()                {}
func (r transactionToTransactionHistoryFindFirst) transactionModel()    {}
func (r transactionToTransactionHistoryFindFirst) transactionRelation() {}

func (r transactionToTransactionHistoryFindFirst) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindFirst) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindFirst) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindFirst) OrderBy(params ...TransactionHistoryOrderByParam) transactionToTransactionHistoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToTransactionHistoryFindFirst) Skip(count int) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Take(count int) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Cursor(cursor TransactionCursorParam) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindFirst) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionToTransactionHistoryFindMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindMany) with()                {}
func (r transactionToTransactionHistoryFindMany) transactionModel()    {}
func (r transactionToTransactionHistoryFindMany) transactionRelation() {}

func (r transactionToTransactionHistoryFindMany) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindMany) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindMany) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindMany) OrderBy(params ...TransactionHistoryOrderByParam) transactionToTransactionHistoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToTransactionHistoryFindMany) Skip(count int) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Take(count int) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Cursor(cursor TransactionCursorParam) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Exec(ctx context.Context) (
	[]TransactionModel,
	error,
) {
	var v []TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindMany) ExecInner(ctx context.Context) (
	[]InnerTransaction,
	error,
) {
	var v []InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindMany) Update(params ...TransactionSetParam) transactionToTransactionHistoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transaction"

	r.query.Outputs = countOutput

	var v transactionToTransactionHistoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToTransactionHistoryUpdateMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryUpdateMany) transactionModel() {}

func (r transactionToTransactionHistoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryUpdateMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToTransactionHistoryFindMany) Delete() transactionToTransactionHistoryDeleteMany {
	var v transactionToTransactionHistoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transaction"

	v.query.Outputs = countOutput

	return v
}

type transactionToTransactionHistoryDeleteMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToTransactionHistoryDeleteMany) transactionModel() {}

func (r transactionToTransactionHistoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryDeleteMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionFindUnique struct {
	query builder.Query
}

func (r transactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindUnique) with()                {}
func (r transactionFindUnique) transactionModel()    {}
func (r transactionFindUnique) transactionRelation() {}

func (r transactionActions) FindUnique(
	params TransactionEqualsUniqueWhereParam,
) transactionFindUnique {
	var v transactionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionFindUnique) With(params ...TransactionRelationWith) transactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindUnique) Select(params ...transactionPrismaFields) transactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindUnique) Omit(params ...transactionPrismaFields) transactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindUnique) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindUnique) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindUnique) Update(params ...TransactionSetParam) transactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transaction"

	var v transactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionUpdateUnique struct {
	query builder.Query
}

func (r transactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpdateUnique) transactionModel() {}

func (r transactionUpdateUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpdateUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionFindUnique) Delete() transactionDeleteUnique {
	var v transactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transaction"

	return v
}

type transactionDeleteUnique struct {
	query builder.Query
}

func (r transactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionDeleteUnique) transactionModel() {}

func (r transactionDeleteUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionDeleteUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionFindFirst struct {
	query builder.Query
}

func (r transactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindFirst) with()                {}
func (r transactionFindFirst) transactionModel()    {}
func (r transactionFindFirst) transactionRelation() {}

func (r transactionActions) FindFirst(
	params ...TransactionWhereParam,
) transactionFindFirst {
	var v transactionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionFindFirst) With(params ...TransactionRelationWith) transactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindFirst) Select(params ...transactionPrismaFields) transactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindFirst) Omit(params ...transactionPrismaFields) transactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindFirst) OrderBy(params ...TransactionOrderByParam) transactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionFindFirst) Skip(count int) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionFindFirst) Take(count int) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionFindFirst) Cursor(cursor TransactionCursorParam) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionFindFirst) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindFirst) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionFindMany struct {
	query builder.Query
}

func (r transactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindMany) with()                {}
func (r transactionFindMany) transactionModel()    {}
func (r transactionFindMany) transactionRelation() {}

func (r transactionActions) FindMany(
	params ...TransactionWhereParam,
) transactionFindMany {
	var v transactionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionFindMany) With(params ...TransactionRelationWith) transactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindMany) Select(params ...transactionPrismaFields) transactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindMany) Omit(params ...transactionPrismaFields) transactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindMany) OrderBy(params ...TransactionOrderByParam) transactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionFindMany) Skip(count int) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionFindMany) Take(count int) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionFindMany) Cursor(cursor TransactionCursorParam) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionFindMany) Exec(ctx context.Context) (
	[]TransactionModel,
	error,
) {
	var v []TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionFindMany) ExecInner(ctx context.Context) (
	[]InnerTransaction,
	error,
) {
	var v []InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionFindMany) Update(params ...TransactionSetParam) transactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transaction"

	r.query.Outputs = countOutput

	var v transactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionUpdateMany struct {
	query builder.Query
}

func (r transactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpdateMany) transactionModel() {}

func (r transactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpdateMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionFindMany) Delete() transactionDeleteMany {
	var v transactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transaction"

	v.query.Outputs = countOutput

	return v
}

type transactionDeleteMany struct {
	query builder.Query
}

func (r transactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionDeleteMany) transactionModel() {}

func (r transactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionDeleteMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryToTransactionFindUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindUnique) with()                       {}
func (r transactionHistoryToTransactionFindUnique) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindUnique) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindUnique) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindUnique) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindUnique) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindUnique) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindUnique) Update(params ...TransactionHistorySetParam) transactionHistoryToTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransactionHistory"

	var v transactionHistoryToTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryToTransactionUpdateUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionUpdateUnique) transactionHistoryModel() {}

func (r transactionHistoryToTransactionUpdateUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionUpdateUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryToTransactionFindUnique) Delete() transactionHistoryToTransactionDeleteUnique {
	var v transactionHistoryToTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransactionHistory"

	return v
}

type transactionHistoryToTransactionDeleteUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryToTransactionDeleteUnique) transactionHistoryModel() {}

func (r transactionHistoryToTransactionDeleteUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionDeleteUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryToTransactionFindFirst struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindFirst) with()                       {}
func (r transactionHistoryToTransactionFindFirst) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindFirst) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindFirst) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindFirst) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindFirst) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindFirst) OrderBy(params ...TransactionOrderByParam) transactionHistoryToTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryToTransactionFindFirst) Skip(count int) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Take(count int) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionHistoryToTransactionFindMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindMany) with()                       {}
func (r transactionHistoryToTransactionFindMany) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindMany) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindMany) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindMany) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindMany) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindMany) OrderBy(params ...TransactionOrderByParam) transactionHistoryToTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryToTransactionFindMany) Skip(count int) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Take(count int) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Exec(ctx context.Context) (
	[]TransactionHistoryModel,
	error,
) {
	var v []TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerTransactionHistory,
	error,
) {
	var v []InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindMany) Update(params ...TransactionHistorySetParam) transactionHistoryToTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransactionHistory"

	r.query.Outputs = countOutput

	var v transactionHistoryToTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryToTransactionUpdateMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionUpdateMany) transactionHistoryModel() {}

func (r transactionHistoryToTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionUpdateMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryToTransactionFindMany) Delete() transactionHistoryToTransactionDeleteMany {
	var v transactionHistoryToTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransactionHistory"

	v.query.Outputs = countOutput

	return v
}

type transactionHistoryToTransactionDeleteMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryToTransactionDeleteMany) transactionHistoryModel() {}

func (r transactionHistoryToTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionDeleteMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryFindUnique struct {
	query builder.Query
}

func (r transactionHistoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindUnique) with()                       {}
func (r transactionHistoryFindUnique) transactionHistoryModel()    {}
func (r transactionHistoryFindUnique) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindUnique(
	params TransactionHistoryEqualsUniqueWhereParam,
) transactionHistoryFindUnique {
	var v transactionHistoryFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionHistoryFindUnique) With(params ...TransactionHistoryRelationWith) transactionHistoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindUnique) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindUnique) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindUnique) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindUnique) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindUnique) Update(params ...TransactionHistorySetParam) transactionHistoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransactionHistory"

	var v transactionHistoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryUpdateUnique struct {
	query builder.Query
}

func (r transactionHistoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpdateUnique) transactionHistoryModel() {}

func (r transactionHistoryUpdateUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpdateUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryFindUnique) Delete() transactionHistoryDeleteUnique {
	var v transactionHistoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransactionHistory"

	return v
}

type transactionHistoryDeleteUnique struct {
	query builder.Query
}

func (r transactionHistoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryDeleteUnique) transactionHistoryModel() {}

func (r transactionHistoryDeleteUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryDeleteUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryFindFirst struct {
	query builder.Query
}

func (r transactionHistoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindFirst) with()                       {}
func (r transactionHistoryFindFirst) transactionHistoryModel()    {}
func (r transactionHistoryFindFirst) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindFirst(
	params ...TransactionHistoryWhereParam,
) transactionHistoryFindFirst {
	var v transactionHistoryFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionHistoryFindFirst) With(params ...TransactionHistoryRelationWith) transactionHistoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindFirst) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindFirst) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindFirst) OrderBy(params ...TransactionHistoryOrderByParam) transactionHistoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryFindFirst) Skip(count int) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindFirst) Take(count int) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindFirst) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryFindFirst) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindFirst) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionHistoryFindMany struct {
	query builder.Query
}

func (r transactionHistoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindMany) with()                       {}
func (r transactionHistoryFindMany) transactionHistoryModel()    {}
func (r transactionHistoryFindMany) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindMany(
	params ...TransactionHistoryWhereParam,
) transactionHistoryFindMany {
	var v transactionHistoryFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionHistoryFindMany) With(params ...TransactionHistoryRelationWith) transactionHistoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindMany) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindMany) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindMany) OrderBy(params ...TransactionHistoryOrderByParam) transactionHistoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryFindMany) Skip(count int) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindMany) Take(count int) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindMany) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryFindMany) Exec(ctx context.Context) (
	[]TransactionHistoryModel,
	error,
) {
	var v []TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryFindMany) ExecInner(ctx context.Context) (
	[]InnerTransactionHistory,
	error,
) {
	var v []InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryFindMany) Update(params ...TransactionHistorySetParam) transactionHistoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransactionHistory"

	r.query.Outputs = countOutput

	var v transactionHistoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryUpdateMany struct {
	query builder.Query
}

func (r transactionHistoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpdateMany) transactionHistoryModel() {}

func (r transactionHistoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpdateMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryFindMany) Delete() transactionHistoryDeleteMany {
	var v transactionHistoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransactionHistory"

	v.query.Outputs = countOutput

	return v
}

type transactionHistoryDeleteMany struct {
	query builder.Query
}

func (r transactionHistoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryDeleteMany) transactionHistoryModel() {}

func (r transactionHistoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryDeleteMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToUserFindUnique struct {
	query builder.Query
}

func (r depositToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToUserFindUnique) with()            {}
func (r depositToUserFindUnique) depositModel()    {}
func (r depositToUserFindUnique) depositRelation() {}

func (r depositToUserFindUnique) With(params ...UserRelationWith) depositToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToUserFindUnique) Select(params ...depositPrismaFields) depositToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindUnique) Omit(params ...depositPrismaFields) depositToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToUserFindUnique) Update(params ...DepositSetParam) depositToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToUserUpdateUnique struct {
	query builder.Query
}

func (r depositToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToUserUpdateUnique) depositModel() {}

func (r depositToUserUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToUserUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToUserFindUnique) Delete() depositToUserDeleteUnique {
	var v depositToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositToUserDeleteUnique struct {
	query builder.Query
}

func (r depositToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToUserDeleteUnique) depositModel() {}

func (r depositToUserDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToUserDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToUserFindFirst struct {
	query builder.Query
}

func (r depositToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToUserFindFirst) with()            {}
func (r depositToUserFindFirst) depositModel()    {}
func (r depositToUserFindFirst) depositRelation() {}

func (r depositToUserFindFirst) With(params ...UserRelationWith) depositToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToUserFindFirst) Select(params ...depositPrismaFields) depositToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindFirst) Omit(params ...depositPrismaFields) depositToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindFirst) OrderBy(params ...UserOrderByParam) depositToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToUserFindFirst) Skip(count int) depositToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToUserFindFirst) Take(count int) depositToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToUserFindFirst) Cursor(cursor DepositCursorParam) depositToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToUserFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositToUserFindMany struct {
	query builder.Query
}

func (r depositToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToUserFindMany) with()            {}
func (r depositToUserFindMany) depositModel()    {}
func (r depositToUserFindMany) depositRelation() {}

func (r depositToUserFindMany) With(params ...UserRelationWith) depositToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToUserFindMany) Select(params ...depositPrismaFields) depositToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindMany) Omit(params ...depositPrismaFields) depositToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToUserFindMany) OrderBy(params ...UserOrderByParam) depositToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToUserFindMany) Skip(count int) depositToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToUserFindMany) Take(count int) depositToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToUserFindMany) Cursor(cursor DepositCursorParam) depositToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToUserFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToUserFindMany) Update(params ...DepositSetParam) depositToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToUserUpdateMany struct {
	query builder.Query
}

func (r depositToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToUserUpdateMany) depositModel() {}

func (r depositToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToUserUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToUserFindMany) Delete() depositToUserDeleteMany {
	var v depositToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositToUserDeleteMany struct {
	query builder.Query
}

func (r depositToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToUserDeleteMany) depositModel() {}

func (r depositToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToUserDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToWithDrawFindUnique struct {
	query builder.Query
}

func (r depositToWithDrawFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindUnique) with()            {}
func (r depositToWithDrawFindUnique) depositModel()    {}
func (r depositToWithDrawFindUnique) depositRelation() {}

func (r depositToWithDrawFindUnique) With(params ...WithDrawRelationWith) depositToWithDrawFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindUnique) Select(params ...depositPrismaFields) depositToWithDrawFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindUnique) Omit(params ...depositPrismaFields) depositToWithDrawFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindUnique) Update(params ...DepositSetParam) depositToWithDrawUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositToWithDrawUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToWithDrawUpdateUnique struct {
	query builder.Query
}

func (r depositToWithDrawUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawUpdateUnique) depositModel() {}

func (r depositToWithDrawUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToWithDrawFindUnique) Delete() depositToWithDrawDeleteUnique {
	var v depositToWithDrawDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositToWithDrawDeleteUnique struct {
	query builder.Query
}

func (r depositToWithDrawDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToWithDrawDeleteUnique) depositModel() {}

func (r depositToWithDrawDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToWithDrawFindFirst struct {
	query builder.Query
}

func (r depositToWithDrawFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindFirst) with()            {}
func (r depositToWithDrawFindFirst) depositModel()    {}
func (r depositToWithDrawFindFirst) depositRelation() {}

func (r depositToWithDrawFindFirst) With(params ...WithDrawRelationWith) depositToWithDrawFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindFirst) Select(params ...depositPrismaFields) depositToWithDrawFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindFirst) Omit(params ...depositPrismaFields) depositToWithDrawFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindFirst) OrderBy(params ...WithDrawOrderByParam) depositToWithDrawFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToWithDrawFindFirst) Skip(count int) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindFirst) Take(count int) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindFirst) Cursor(cursor DepositCursorParam) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToWithDrawFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositToWithDrawFindMany struct {
	query builder.Query
}

func (r depositToWithDrawFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindMany) with()            {}
func (r depositToWithDrawFindMany) depositModel()    {}
func (r depositToWithDrawFindMany) depositRelation() {}

func (r depositToWithDrawFindMany) With(params ...WithDrawRelationWith) depositToWithDrawFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindMany) Select(params ...depositPrismaFields) depositToWithDrawFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindMany) Omit(params ...depositPrismaFields) depositToWithDrawFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindMany) OrderBy(params ...WithDrawOrderByParam) depositToWithDrawFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToWithDrawFindMany) Skip(count int) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindMany) Take(count int) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindMany) Cursor(cursor DepositCursorParam) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToWithDrawFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToWithDrawFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToWithDrawFindMany) Update(params ...DepositSetParam) depositToWithDrawUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositToWithDrawUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToWithDrawUpdateMany struct {
	query builder.Query
}

func (r depositToWithDrawUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawUpdateMany) depositModel() {}

func (r depositToWithDrawUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToWithDrawFindMany) Delete() depositToWithDrawDeleteMany {
	var v depositToWithDrawDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositToWithDrawDeleteMany struct {
	query builder.Query
}

func (r depositToWithDrawDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToWithDrawDeleteMany) depositModel() {}

func (r depositToWithDrawDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToDepositTransactionFindUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindUnique) with()            {}
func (r depositToDepositTransactionFindUnique) depositModel()    {}
func (r depositToDepositTransactionFindUnique) depositRelation() {}

func (r depositToDepositTransactionFindUnique) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindUnique) Select(params ...depositPrismaFields) depositToDepositTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindUnique) Omit(params ...depositPrismaFields) depositToDepositTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindUnique) Update(params ...DepositSetParam) depositToDepositTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositToDepositTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToDepositTransactionUpdateUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionUpdateUnique) depositModel() {}

func (r depositToDepositTransactionUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToDepositTransactionFindUnique) Delete() depositToDepositTransactionDeleteUnique {
	var v depositToDepositTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositToDepositTransactionDeleteUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToDepositTransactionDeleteUnique) depositModel() {}

func (r depositToDepositTransactionDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToDepositTransactionFindFirst struct {
	query builder.Query
}

func (r depositToDepositTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindFirst) with()            {}
func (r depositToDepositTransactionFindFirst) depositModel()    {}
func (r depositToDepositTransactionFindFirst) depositRelation() {}

func (r depositToDepositTransactionFindFirst) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindFirst) Select(params ...depositPrismaFields) depositToDepositTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindFirst) Omit(params ...depositPrismaFields) depositToDepositTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindFirst) OrderBy(params ...DepositTransactionOrderByParam) depositToDepositTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToDepositTransactionFindFirst) Skip(count int) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Take(count int) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Cursor(cursor DepositCursorParam) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositToDepositTransactionFindMany struct {
	query builder.Query
}

func (r depositToDepositTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindMany) with()            {}
func (r depositToDepositTransactionFindMany) depositModel()    {}
func (r depositToDepositTransactionFindMany) depositRelation() {}

func (r depositToDepositTransactionFindMany) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindMany) Select(params ...depositPrismaFields) depositToDepositTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindMany) Omit(params ...depositPrismaFields) depositToDepositTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindMany) OrderBy(params ...DepositTransactionOrderByParam) depositToDepositTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToDepositTransactionFindMany) Skip(count int) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindMany) Take(count int) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindMany) Cursor(cursor DepositCursorParam) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToDepositTransactionFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToDepositTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToDepositTransactionFindMany) Update(params ...DepositSetParam) depositToDepositTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositToDepositTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToDepositTransactionUpdateMany struct {
	query builder.Query
}

func (r depositToDepositTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionUpdateMany) depositModel() {}

func (r depositToDepositTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToDepositTransactionFindMany) Delete() depositToDepositTransactionDeleteMany {
	var v depositToDepositTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositToDepositTransactionDeleteMany struct {
	query builder.Query
}

func (r depositToDepositTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToDepositTransactionDeleteMany) depositModel() {}

func (r depositToDepositTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositFindUnique struct {
	query builder.Query
}

func (r depositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindUnique) with()            {}
func (r depositFindUnique) depositModel()    {}
func (r depositFindUnique) depositRelation() {}

func (r depositActions) FindUnique(
	params DepositEqualsUniqueWhereParam,
) depositFindUnique {
	var v depositFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositFindUnique) With(params ...DepositRelationWith) depositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindUnique) Select(params ...depositPrismaFields) depositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindUnique) Omit(params ...depositPrismaFields) depositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindUnique) Update(params ...DepositSetParam) depositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositUpdateUnique struct {
	query builder.Query
}

func (r depositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpdateUnique) depositModel() {}

func (r depositUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositFindUnique) Delete() depositDeleteUnique {
	var v depositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositDeleteUnique struct {
	query builder.Query
}

func (r depositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositDeleteUnique) depositModel() {}

func (r depositDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositFindFirst struct {
	query builder.Query
}

func (r depositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindFirst) with()            {}
func (r depositFindFirst) depositModel()    {}
func (r depositFindFirst) depositRelation() {}

func (r depositActions) FindFirst(
	params ...DepositWhereParam,
) depositFindFirst {
	var v depositFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositFindFirst) With(params ...DepositRelationWith) depositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindFirst) Select(params ...depositPrismaFields) depositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindFirst) Omit(params ...depositPrismaFields) depositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindFirst) OrderBy(params ...DepositOrderByParam) depositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositFindFirst) Skip(count int) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositFindFirst) Take(count int) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositFindFirst) Cursor(cursor DepositCursorParam) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositFindMany struct {
	query builder.Query
}

func (r depositFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindMany) with()            {}
func (r depositFindMany) depositModel()    {}
func (r depositFindMany) depositRelation() {}

func (r depositActions) FindMany(
	params ...DepositWhereParam,
) depositFindMany {
	var v depositFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositFindMany) With(params ...DepositRelationWith) depositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindMany) Select(params ...depositPrismaFields) depositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindMany) Omit(params ...depositPrismaFields) depositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindMany) OrderBy(params ...DepositOrderByParam) depositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositFindMany) Skip(count int) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositFindMany) Take(count int) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositFindMany) Cursor(cursor DepositCursorParam) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositFindMany) Update(params ...DepositSetParam) depositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositUpdateMany struct {
	query builder.Query
}

func (r depositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpdateMany) depositModel() {}

func (r depositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositFindMany) Delete() depositDeleteMany {
	var v depositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositDeleteMany struct {
	query builder.Query
}

func (r depositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositDeleteMany) depositModel() {}

func (r depositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToUserFindUnique struct {
	query builder.Query
}

func (r withDrawToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindUnique) with()             {}
func (r withDrawToUserFindUnique) withDrawModel()    {}
func (r withDrawToUserFindUnique) withDrawRelation() {}

func (r withDrawToUserFindUnique) With(params ...UserRelationWith) withDrawToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToUserFindUnique) Select(params ...withDrawPrismaFields) withDrawToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindUnique) Omit(params ...withDrawPrismaFields) withDrawToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindUnique) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToUserFindUnique) Update(params ...WithDrawSetParam) withDrawToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WithDraw"

	var v withDrawToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToUserUpdateUnique struct {
	query builder.Query
}

func (r withDrawToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToUserUpdateUnique) withDrawModel() {}

func (r withDrawToUserUpdateUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToUserUpdateUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToUserFindUnique) Delete() withDrawToUserDeleteUnique {
	var v withDrawToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WithDraw"

	return v
}

type withDrawToUserDeleteUnique struct {
	query builder.Query
}

func (r withDrawToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToUserDeleteUnique) withDrawModel() {}

func (r withDrawToUserDeleteUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToUserDeleteUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToUserFindFirst struct {
	query builder.Query
}

func (r withDrawToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindFirst) with()             {}
func (r withDrawToUserFindFirst) withDrawModel()    {}
func (r withDrawToUserFindFirst) withDrawRelation() {}

func (r withDrawToUserFindFirst) With(params ...UserRelationWith) withDrawToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToUserFindFirst) Select(params ...withDrawPrismaFields) withDrawToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindFirst) Omit(params ...withDrawPrismaFields) withDrawToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindFirst) OrderBy(params ...UserOrderByParam) withDrawToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToUserFindFirst) Skip(count int) withDrawToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToUserFindFirst) Take(count int) withDrawToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToUserFindFirst) Cursor(cursor WithDrawCursorParam) withDrawToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToUserFindFirst) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type withDrawToUserFindMany struct {
	query builder.Query
}

func (r withDrawToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToUserFindMany) with()             {}
func (r withDrawToUserFindMany) withDrawModel()    {}
func (r withDrawToUserFindMany) withDrawRelation() {}

func (r withDrawToUserFindMany) With(params ...UserRelationWith) withDrawToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToUserFindMany) Select(params ...withDrawPrismaFields) withDrawToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindMany) Omit(params ...withDrawPrismaFields) withDrawToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToUserFindMany) OrderBy(params ...UserOrderByParam) withDrawToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToUserFindMany) Skip(count int) withDrawToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToUserFindMany) Take(count int) withDrawToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToUserFindMany) Cursor(cursor WithDrawCursorParam) withDrawToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToUserFindMany) Exec(ctx context.Context) (
	[]WithDrawModel,
	error,
) {
	var v []WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerWithDraw,
	error,
) {
	var v []InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToUserFindMany) Update(params ...WithDrawSetParam) withDrawToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WithDraw"

	r.query.Outputs = countOutput

	var v withDrawToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToUserUpdateMany struct {
	query builder.Query
}

func (r withDrawToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToUserUpdateMany) withDrawModel() {}

func (r withDrawToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToUserUpdateMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToUserFindMany) Delete() withDrawToUserDeleteMany {
	var v withDrawToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WithDraw"

	v.query.Outputs = countOutput

	return v
}

type withDrawToUserDeleteMany struct {
	query builder.Query
}

func (r withDrawToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToUserDeleteMany) withDrawModel() {}

func (r withDrawToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToUserDeleteMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToDepositFindUnique struct {
	query builder.Query
}

func (r withDrawToDepositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindUnique) with()             {}
func (r withDrawToDepositFindUnique) withDrawModel()    {}
func (r withDrawToDepositFindUnique) withDrawRelation() {}

func (r withDrawToDepositFindUnique) With(params ...DepositRelationWith) withDrawToDepositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindUnique) Select(params ...withDrawPrismaFields) withDrawToDepositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindUnique) Omit(params ...withDrawPrismaFields) withDrawToDepositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindUnique) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindUnique) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindUnique) Update(params ...WithDrawSetParam) withDrawToDepositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WithDraw"

	var v withDrawToDepositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToDepositUpdateUnique struct {
	query builder.Query
}

func (r withDrawToDepositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositUpdateUnique) withDrawModel() {}

func (r withDrawToDepositUpdateUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositUpdateUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToDepositFindUnique) Delete() withDrawToDepositDeleteUnique {
	var v withDrawToDepositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WithDraw"

	return v
}

type withDrawToDepositDeleteUnique struct {
	query builder.Query
}

func (r withDrawToDepositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToDepositDeleteUnique) withDrawModel() {}

func (r withDrawToDepositDeleteUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositDeleteUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToDepositFindFirst struct {
	query builder.Query
}

func (r withDrawToDepositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindFirst) with()             {}
func (r withDrawToDepositFindFirst) withDrawModel()    {}
func (r withDrawToDepositFindFirst) withDrawRelation() {}

func (r withDrawToDepositFindFirst) With(params ...DepositRelationWith) withDrawToDepositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindFirst) Select(params ...withDrawPrismaFields) withDrawToDepositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindFirst) Omit(params ...withDrawPrismaFields) withDrawToDepositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindFirst) OrderBy(params ...DepositOrderByParam) withDrawToDepositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToDepositFindFirst) Skip(count int) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindFirst) Take(count int) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindFirst) Cursor(cursor WithDrawCursorParam) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToDepositFindFirst) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindFirst) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type withDrawToDepositFindMany struct {
	query builder.Query
}

func (r withDrawToDepositFindMany) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindMany) with()             {}
func (r withDrawToDepositFindMany) withDrawModel()    {}
func (r withDrawToDepositFindMany) withDrawRelation() {}

func (r withDrawToDepositFindMany) With(params ...DepositRelationWith) withDrawToDepositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindMany) Select(params ...withDrawPrismaFields) withDrawToDepositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindMany) Omit(params ...withDrawPrismaFields) withDrawToDepositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindMany) OrderBy(params ...DepositOrderByParam) withDrawToDepositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToDepositFindMany) Skip(count int) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindMany) Take(count int) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindMany) Cursor(cursor WithDrawCursorParam) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToDepositFindMany) Exec(ctx context.Context) (
	[]WithDrawModel,
	error,
) {
	var v []WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToDepositFindMany) ExecInner(ctx context.Context) (
	[]InnerWithDraw,
	error,
) {
	var v []InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToDepositFindMany) Update(params ...WithDrawSetParam) withDrawToDepositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WithDraw"

	r.query.Outputs = countOutput

	var v withDrawToDepositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToDepositUpdateMany struct {
	query builder.Query
}

func (r withDrawToDepositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositUpdateMany) withDrawModel() {}

func (r withDrawToDepositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositUpdateMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToDepositFindMany) Delete() withDrawToDepositDeleteMany {
	var v withDrawToDepositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WithDraw"

	v.query.Outputs = countOutput

	return v
}

type withDrawToDepositDeleteMany struct {
	query builder.Query
}

func (r withDrawToDepositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToDepositDeleteMany) withDrawModel() {}

func (r withDrawToDepositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositDeleteMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawFindUnique struct {
	query builder.Query
}

func (r withDrawFindUnique) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindUnique) with()             {}
func (r withDrawFindUnique) withDrawModel()    {}
func (r withDrawFindUnique) withDrawRelation() {}

func (r withDrawActions) FindUnique(
	params WithDrawEqualsUniqueWhereParam,
) withDrawFindUnique {
	var v withDrawFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r withDrawFindUnique) With(params ...WithDrawRelationWith) withDrawFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindUnique) Select(params ...withDrawPrismaFields) withDrawFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindUnique) Omit(params ...withDrawPrismaFields) withDrawFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindUnique) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindUnique) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindUnique) Update(params ...WithDrawSetParam) withDrawUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WithDraw"

	var v withDrawUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawUpdateUnique struct {
	query builder.Query
}

func (r withDrawUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpdateUnique) withDrawModel() {}

func (r withDrawUpdateUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpdateUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawFindUnique) Delete() withDrawDeleteUnique {
	var v withDrawDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WithDraw"

	return v
}

type withDrawDeleteUnique struct {
	query builder.Query
}

func (r withDrawDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawDeleteUnique) withDrawModel() {}

func (r withDrawDeleteUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawDeleteUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawFindFirst struct {
	query builder.Query
}

func (r withDrawFindFirst) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindFirst) with()             {}
func (r withDrawFindFirst) withDrawModel()    {}
func (r withDrawFindFirst) withDrawRelation() {}

func (r withDrawActions) FindFirst(
	params ...WithDrawWhereParam,
) withDrawFindFirst {
	var v withDrawFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r withDrawFindFirst) With(params ...WithDrawRelationWith) withDrawFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindFirst) Select(params ...withDrawPrismaFields) withDrawFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindFirst) Omit(params ...withDrawPrismaFields) withDrawFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindFirst) OrderBy(params ...WithDrawOrderByParam) withDrawFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawFindFirst) Skip(count int) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawFindFirst) Take(count int) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawFindFirst) Cursor(cursor WithDrawCursorParam) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawFindFirst) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindFirst) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type withDrawFindMany struct {
	query builder.Query
}

func (r withDrawFindMany) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindMany) with()             {}
func (r withDrawFindMany) withDrawModel()    {}
func (r withDrawFindMany) withDrawRelation() {}

func (r withDrawActions) FindMany(
	params ...WithDrawWhereParam,
) withDrawFindMany {
	var v withDrawFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r withDrawFindMany) With(params ...WithDrawRelationWith) withDrawFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindMany) Select(params ...withDrawPrismaFields) withDrawFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindMany) Omit(params ...withDrawPrismaFields) withDrawFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindMany) OrderBy(params ...WithDrawOrderByParam) withDrawFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawFindMany) Skip(count int) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawFindMany) Take(count int) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawFindMany) Cursor(cursor WithDrawCursorParam) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawFindMany) Exec(ctx context.Context) (
	[]WithDrawModel,
	error,
) {
	var v []WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawFindMany) ExecInner(ctx context.Context) (
	[]InnerWithDraw,
	error,
) {
	var v []InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawFindMany) Update(params ...WithDrawSetParam) withDrawUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WithDraw"

	r.query.Outputs = countOutput

	var v withDrawUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawUpdateMany struct {
	query builder.Query
}

func (r withDrawUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpdateMany) withDrawModel() {}

func (r withDrawUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpdateMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawFindMany) Delete() withDrawDeleteMany {
	var v withDrawDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WithDraw"

	v.query.Outputs = countOutput

	return v
}

type withDrawDeleteMany struct {
	query builder.Query
}

func (r withDrawDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawDeleteMany) withDrawModel() {}

func (r withDrawDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawDeleteMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionToDepositFindUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindUnique) with()                       {}
func (r depositTransactionToDepositFindUnique) depositTransactionModel()    {}
func (r depositTransactionToDepositFindUnique) depositTransactionRelation() {}

func (r depositTransactionToDepositFindUnique) With(params ...DepositRelationWith) depositTransactionToDepositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindUnique) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindUnique) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindUnique) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindUnique) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindUnique) Update(params ...DepositTransactionSetParam) depositTransactionToDepositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DepositTransaction"

	var v depositTransactionToDepositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionToDepositUpdateUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositUpdateUnique) depositTransactionModel() {}

func (r depositTransactionToDepositUpdateUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositUpdateUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionToDepositFindUnique) Delete() depositTransactionToDepositDeleteUnique {
	var v depositTransactionToDepositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DepositTransaction"

	return v
}

type depositTransactionToDepositDeleteUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionToDepositDeleteUnique) depositTransactionModel() {}

func (r depositTransactionToDepositDeleteUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositDeleteUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionToDepositFindFirst struct {
	query builder.Query
}

func (r depositTransactionToDepositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindFirst) with()                       {}
func (r depositTransactionToDepositFindFirst) depositTransactionModel()    {}
func (r depositTransactionToDepositFindFirst) depositTransactionRelation() {}

func (r depositTransactionToDepositFindFirst) With(params ...DepositRelationWith) depositTransactionToDepositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindFirst) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindFirst) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindFirst) OrderBy(params ...DepositOrderByParam) depositTransactionToDepositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionToDepositFindFirst) Skip(count int) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Take(count int) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Cursor(cursor DepositTransactionCursorParam) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindFirst) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositTransactionToDepositFindMany struct {
	query builder.Query
}

func (r depositTransactionToDepositFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindMany) with()                       {}
func (r depositTransactionToDepositFindMany) depositTransactionModel()    {}
func (r depositTransactionToDepositFindMany) depositTransactionRelation() {}

func (r depositTransactionToDepositFindMany) With(params ...DepositRelationWith) depositTransactionToDepositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindMany) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindMany) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindMany) OrderBy(params ...DepositOrderByParam) depositTransactionToDepositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionToDepositFindMany) Skip(count int) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindMany) Take(count int) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindMany) Cursor(cursor DepositTransactionCursorParam) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionToDepositFindMany) Exec(ctx context.Context) (
	[]DepositTransactionModel,
	error,
) {
	var v []DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionToDepositFindMany) ExecInner(ctx context.Context) (
	[]InnerDepositTransaction,
	error,
) {
	var v []InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionToDepositFindMany) Update(params ...DepositTransactionSetParam) depositTransactionToDepositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DepositTransaction"

	r.query.Outputs = countOutput

	var v depositTransactionToDepositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionToDepositUpdateMany struct {
	query builder.Query
}

func (r depositTransactionToDepositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositUpdateMany) depositTransactionModel() {}

func (r depositTransactionToDepositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositUpdateMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionToDepositFindMany) Delete() depositTransactionToDepositDeleteMany {
	var v depositTransactionToDepositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DepositTransaction"

	v.query.Outputs = countOutput

	return v
}

type depositTransactionToDepositDeleteMany struct {
	query builder.Query
}

func (r depositTransactionToDepositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionToDepositDeleteMany) depositTransactionModel() {}

func (r depositTransactionToDepositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositDeleteMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionFindUnique struct {
	query builder.Query
}

func (r depositTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindUnique) with()                       {}
func (r depositTransactionFindUnique) depositTransactionModel()    {}
func (r depositTransactionFindUnique) depositTransactionRelation() {}

func (r depositTransactionActions) FindUnique(
	params DepositTransactionEqualsUniqueWhereParam,
) depositTransactionFindUnique {
	var v depositTransactionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositTransactionFindUnique) With(params ...DepositTransactionRelationWith) depositTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindUnique) Select(params ...depositTransactionPrismaFields) depositTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindUnique) Omit(params ...depositTransactionPrismaFields) depositTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindUnique) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindUnique) Update(params ...DepositTransactionSetParam) depositTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DepositTransaction"

	var v depositTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionUpdateUnique struct {
	query builder.Query
}

func (r depositTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpdateUnique) depositTransactionModel() {}

func (r depositTransactionUpdateUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpdateUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionFindUnique) Delete() depositTransactionDeleteUnique {
	var v depositTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DepositTransaction"

	return v
}

type depositTransactionDeleteUnique struct {
	query builder.Query
}

func (r depositTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionDeleteUnique) depositTransactionModel() {}

func (r depositTransactionDeleteUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionDeleteUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionFindFirst struct {
	query builder.Query
}

func (r depositTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindFirst) with()                       {}
func (r depositTransactionFindFirst) depositTransactionModel()    {}
func (r depositTransactionFindFirst) depositTransactionRelation() {}

func (r depositTransactionActions) FindFirst(
	params ...DepositTransactionWhereParam,
) depositTransactionFindFirst {
	var v depositTransactionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositTransactionFindFirst) With(params ...DepositTransactionRelationWith) depositTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindFirst) Select(params ...depositTransactionPrismaFields) depositTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindFirst) Omit(params ...depositTransactionPrismaFields) depositTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindFirst) OrderBy(params ...DepositTransactionOrderByParam) depositTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionFindFirst) Skip(count int) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionFindFirst) Take(count int) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionFindFirst) Cursor(cursor DepositTransactionCursorParam) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionFindFirst) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositTransactionFindMany struct {
	query builder.Query
}

func (r depositTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindMany) with()                       {}
func (r depositTransactionFindMany) depositTransactionModel()    {}
func (r depositTransactionFindMany) depositTransactionRelation() {}

func (r depositTransactionActions) FindMany(
	params ...DepositTransactionWhereParam,
) depositTransactionFindMany {
	var v depositTransactionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositTransactionFindMany) With(params ...DepositTransactionRelationWith) depositTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindMany) Select(params ...depositTransactionPrismaFields) depositTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindMany) Omit(params ...depositTransactionPrismaFields) depositTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindMany) OrderBy(params ...DepositTransactionOrderByParam) depositTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionFindMany) Skip(count int) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionFindMany) Take(count int) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionFindMany) Cursor(cursor DepositTransactionCursorParam) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionFindMany) Exec(ctx context.Context) (
	[]DepositTransactionModel,
	error,
) {
	var v []DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerDepositTransaction,
	error,
) {
	var v []InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionFindMany) Update(params ...DepositTransactionSetParam) depositTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DepositTransaction"

	r.query.Outputs = countOutput

	var v depositTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionUpdateMany struct {
	query builder.Query
}

func (r depositTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpdateMany) depositTransactionModel() {}

func (r depositTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpdateMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionFindMany) Delete() depositTransactionDeleteMany {
	var v depositTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DepositTransaction"

	v.query.Outputs = countOutput

	return v
}

type depositTransactionDeleteMany struct {
	query builder.Query
}

func (r depositTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionDeleteMany) depositTransactionModel() {}

func (r depositTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionDeleteMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newMasterPaymentTypeUniqueTxResult() MasterPaymentTypeUniqueTxResult {
	return MasterPaymentTypeUniqueTxResult{
		result: &transaction.Result{},
	}
}

type MasterPaymentTypeUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p MasterPaymentTypeUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p MasterPaymentTypeUniqueTxResult) IsTx() {}

func (r MasterPaymentTypeUniqueTxResult) Result() (v *MasterPaymentTypeModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newMasterPaymentTypeManyTxResult() MasterPaymentTypeManyTxResult {
	return MasterPaymentTypeManyTxResult{
		result: &transaction.Result{},
	}
}

type MasterPaymentTypeManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p MasterPaymentTypeManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p MasterPaymentTypeManyTxResult) IsTx() {}

func (r MasterPaymentTypeManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserPaymentTypesUniqueTxResult() UserPaymentTypesUniqueTxResult {
	return UserPaymentTypesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserPaymentTypesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserPaymentTypesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserPaymentTypesUniqueTxResult) IsTx() {}

func (r UserPaymentTypesUniqueTxResult) Result() (v *UserPaymentTypesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserPaymentTypesManyTxResult() UserPaymentTypesManyTxResult {
	return UserPaymentTypesManyTxResult{
		result: &transaction.Result{},
	}
}

type UserPaymentTypesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserPaymentTypesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserPaymentTypesManyTxResult) IsTx() {}

func (r UserPaymentTypesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionUniqueTxResult() TransactionUniqueTxResult {
	return TransactionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TransactionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionUniqueTxResult) IsTx() {}

func (r TransactionUniqueTxResult) Result() (v *TransactionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionManyTxResult() TransactionManyTxResult {
	return TransactionManyTxResult{
		result: &transaction.Result{},
	}
}

type TransactionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionManyTxResult) IsTx() {}

func (r TransactionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionHistoryUniqueTxResult() TransactionHistoryUniqueTxResult {
	return TransactionHistoryUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TransactionHistoryUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionHistoryUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionHistoryUniqueTxResult) IsTx() {}

func (r TransactionHistoryUniqueTxResult) Result() (v *TransactionHistoryModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionHistoryManyTxResult() TransactionHistoryManyTxResult {
	return TransactionHistoryManyTxResult{
		result: &transaction.Result{},
	}
}

type TransactionHistoryManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionHistoryManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionHistoryManyTxResult) IsTx() {}

func (r TransactionHistoryManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositUniqueTxResult() DepositUniqueTxResult {
	return DepositUniqueTxResult{
		result: &transaction.Result{},
	}
}

type DepositUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositUniqueTxResult) IsTx() {}

func (r DepositUniqueTxResult) Result() (v *DepositModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositManyTxResult() DepositManyTxResult {
	return DepositManyTxResult{
		result: &transaction.Result{},
	}
}

type DepositManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositManyTxResult) IsTx() {}

func (r DepositManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWithDrawUniqueTxResult() WithDrawUniqueTxResult {
	return WithDrawUniqueTxResult{
		result: &transaction.Result{},
	}
}

type WithDrawUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WithDrawUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WithDrawUniqueTxResult) IsTx() {}

func (r WithDrawUniqueTxResult) Result() (v *WithDrawModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWithDrawManyTxResult() WithDrawManyTxResult {
	return WithDrawManyTxResult{
		result: &transaction.Result{},
	}
}

type WithDrawManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WithDrawManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WithDrawManyTxResult) IsTx() {}

func (r WithDrawManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositTransactionUniqueTxResult() DepositTransactionUniqueTxResult {
	return DepositTransactionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type DepositTransactionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositTransactionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositTransactionUniqueTxResult) IsTx() {}

func (r DepositTransactionUniqueTxResult) Result() (v *DepositTransactionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositTransactionManyTxResult() DepositTransactionManyTxResult {
	return DepositTransactionManyTxResult{
		result: &transaction.Result{},
	}
}

type DepositTransactionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositTransactionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositTransactionManyTxResult) IsTx() {}

func (r DepositTransactionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_username UserWithPrismaUsernameSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _username.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type masterPaymentTypeUpsertOne struct {
	query builder.Query
}

func (r masterPaymentTypeUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r masterPaymentTypeUpsertOne) with()                      {}
func (r masterPaymentTypeUpsertOne) masterPaymentTypeModel()    {}
func (r masterPaymentTypeUpsertOne) masterPaymentTypeRelation() {}

func (r masterPaymentTypeActions) UpsertOne(
	params MasterPaymentTypeEqualsUniqueWhereParam,
) masterPaymentTypeUpsertOne {
	var v masterPaymentTypeUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "MasterPaymentType"
	v.query.Outputs = masterPaymentTypeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r masterPaymentTypeUpsertOne) Create(

	_name MasterPaymentTypeWithPrismaNameSetParam,

	optional ...MasterPaymentTypeSetParam,
) masterPaymentTypeUpsertOne {
	var v masterPaymentTypeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r masterPaymentTypeUpsertOne) Update(
	params ...MasterPaymentTypeSetParam,
) masterPaymentTypeUpsertOne {
	var v masterPaymentTypeUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r masterPaymentTypeUpsertOne) Exec(ctx context.Context) (*MasterPaymentTypeModel, error) {
	var v MasterPaymentTypeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r masterPaymentTypeUpsertOne) Tx() MasterPaymentTypeUniqueTxResult {
	v := newMasterPaymentTypeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userPaymentTypesUpsertOne struct {
	query builder.Query
}

func (r userPaymentTypesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userPaymentTypesUpsertOne) with()                     {}
func (r userPaymentTypesUpsertOne) userPaymentTypesModel()    {}
func (r userPaymentTypesUpsertOne) userPaymentTypesRelation() {}

func (r userPaymentTypesActions) UpsertOne(
	params UserPaymentTypesEqualsUniqueWhereParam,
) userPaymentTypesUpsertOne {
	var v userPaymentTypesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "UserPaymentTypes"
	v.query.Outputs = userPaymentTypesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userPaymentTypesUpsertOne) Create(

	_user UserPaymentTypesWithPrismaUserSetParam,
	_masterPaymentType UserPaymentTypesWithPrismaMasterPaymentTypeSetParam,

	optional ...UserPaymentTypesSetParam,
) userPaymentTypesUpsertOne {
	var v userPaymentTypesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _masterPaymentType.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userPaymentTypesUpsertOne) Update(
	params ...UserPaymentTypesSetParam,
) userPaymentTypesUpsertOne {
	var v userPaymentTypesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userPaymentTypesUpsertOne) Exec(ctx context.Context) (*UserPaymentTypesModel, error) {
	var v UserPaymentTypesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userPaymentTypesUpsertOne) Tx() UserPaymentTypesUniqueTxResult {
	v := newUserPaymentTypesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionUpsertOne struct {
	query builder.Query
}

func (r transactionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transactionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpsertOne) with()                {}
func (r transactionUpsertOne) transactionModel()    {}
func (r transactionUpsertOne) transactionRelation() {}

func (r transactionActions) UpsertOne(
	params TransactionEqualsUniqueWhereParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionUpsertOne) Create(

	_user TransactionWithPrismaUserSetParam,
	_toAddress TransactionWithPrismaToAddressSetParam,
	_fromAddress TransactionWithPrismaFromAddressSetParam,
	_currency TransactionWithPrismaCurrencySetParam,

	optional ...TransactionSetParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _toAddress.field())
	fields = append(fields, _fromAddress.field())
	fields = append(fields, _currency.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transactionUpsertOne) Update(
	params ...TransactionSetParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transactionUpsertOne) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpsertOne) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryUpsertOne struct {
	query builder.Query
}

func (r transactionHistoryUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpsertOne) with()                       {}
func (r transactionHistoryUpsertOne) transactionHistoryModel()    {}
func (r transactionHistoryUpsertOne) transactionHistoryRelation() {}

func (r transactionHistoryActions) UpsertOne(
	params TransactionHistoryEqualsUniqueWhereParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionHistoryUpsertOne) Create(

	_transaction TransactionHistoryWithPrismaTransactionSetParam,
	_status TransactionHistoryWithPrismaStatusSetParam,

	optional ...TransactionHistorySetParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _transaction.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transactionHistoryUpsertOne) Update(
	params ...TransactionHistorySetParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transactionHistoryUpsertOne) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpsertOne) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositUpsertOne struct {
	query builder.Query
}

func (r depositUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r depositUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpsertOne) with()            {}
func (r depositUpsertOne) depositModel()    {}
func (r depositUpsertOne) depositRelation() {}

func (r depositActions) UpsertOne(
	params DepositEqualsUniqueWhereParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositUpsertOne) Create(

	_user DepositWithPrismaUserSetParam,
	_amount DepositWithPrismaAmountSetParam,

	optional ...DepositSetParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _amount.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r depositUpsertOne) Update(
	params ...DepositSetParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r depositUpsertOne) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpsertOne) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawUpsertOne struct {
	query builder.Query
}

func (r withDrawUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r withDrawUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpsertOne) with()             {}
func (r withDrawUpsertOne) withDrawModel()    {}
func (r withDrawUpsertOne) withDrawRelation() {}

func (r withDrawActions) UpsertOne(
	params WithDrawEqualsUniqueWhereParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r withDrawUpsertOne) Create(

	_charge WithDrawWithPrismaChargeSetParam,
	_user WithDrawWithPrismaUserSetParam,
	_deposit WithDrawWithPrismaDepositSetParam,

	optional ...WithDrawSetParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _charge.field())
	fields = append(fields, _user.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r withDrawUpsertOne) Update(
	params ...WithDrawSetParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r withDrawUpsertOne) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpsertOne) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionUpsertOne struct {
	query builder.Query
}

func (r depositTransactionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpsertOne) with()                       {}
func (r depositTransactionUpsertOne) depositTransactionModel()    {}
func (r depositTransactionUpsertOne) depositTransactionRelation() {}

func (r depositTransactionActions) UpsertOne(
	params DepositTransactionEqualsUniqueWhereParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositTransactionUpsertOne) Create(

	_amount DepositTransactionWithPrismaAmountSetParam,
	_deposit DepositTransactionWithPrismaDepositSetParam,

	optional ...DepositTransactionSetParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _amount.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r depositTransactionUpsertOne) Update(
	params ...DepositTransactionSetParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r depositTransactionUpsertOne) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpsertOne) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}
