// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"","value":"postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"},"config":null}]`

const schema = `datasource db {
  // could be postgresql or mysql
  provider = "postgresql"
  url      = "postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"
}

generator db {
  provider = "go run github.com/steebchen/prisma-client-go"
}


model Transaction {
    id                     Int                @id @default(autoincrement())
    userId                Int
    amount                Int
    toAddress              String
    currency              String
    TransactionHistory    TransactionHistory[]
}


model TransactionHistory {
  id                Int   @id @default(autoincrement())
  transaction       Transaction @relation(fields: [transactionId], references: [id])
  transactionId     Int
  status            String
}

model Deposit {
  id        Int                @id @default(autoincrement())
  userId    Int
  amount    Int
  WithDraw WithDraw[]
  DepositTransaction DepositTransaction[]
}

model WithDraw {
    id        Int                @id @default(autoincrement())
    charge  Int
    userId    Int
    deposit   Deposit               @relation(fields: [depositId], references: [id])
    depositId    Int
}

model DepositTransaction {
     id        Int                @id @default(autoincrement())
     amount    Int
     deposit   Deposit               @relation(fields: [depositId], references: [id])
    depositId    Int
}




`
const schemaDatasourceURL = "postgres://postgres.fxselsmgvmysikytlrae:C9NCSN8bhztwFbmf@aws-0-ap-southeast-1.pooler.supabase.com:5432/postgres"
const schemaEnvVarName = ""

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set" + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Transaction = transactionActions{client: c}
	c.TransactionHistory = transactionHistoryActions{client: c}
	c.Deposit = depositActions{client: c}
	c.WithDraw = withDrawActions{client: c}
	c.DepositTransaction = depositTransactionActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Transaction provides access to CRUD methods.
	Transaction transactionActions
	// TransactionHistory provides access to CRUD methods.
	TransactionHistory transactionHistoryActions
	// Deposit provides access to CRUD methods.
	Deposit depositActions
	// WithDraw provides access to CRUD methods.
	WithDraw withDrawActions
	// DepositTransaction provides access to CRUD methods.
	DepositTransaction depositTransactionActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type TransactionScalarFieldEnum string

const (
	TransactionScalarFieldEnumID        TransactionScalarFieldEnum = "id"
	TransactionScalarFieldEnumUserID    TransactionScalarFieldEnum = "userId"
	TransactionScalarFieldEnumAmount    TransactionScalarFieldEnum = "amount"
	TransactionScalarFieldEnumToAddress TransactionScalarFieldEnum = "toAddress"
	TransactionScalarFieldEnumCurrency  TransactionScalarFieldEnum = "currency"
)

type TransactionHistoryScalarFieldEnum string

const (
	TransactionHistoryScalarFieldEnumID            TransactionHistoryScalarFieldEnum = "id"
	TransactionHistoryScalarFieldEnumTransactionID TransactionHistoryScalarFieldEnum = "transactionId"
	TransactionHistoryScalarFieldEnumStatus        TransactionHistoryScalarFieldEnum = "status"
)

type DepositScalarFieldEnum string

const (
	DepositScalarFieldEnumID     DepositScalarFieldEnum = "id"
	DepositScalarFieldEnumUserID DepositScalarFieldEnum = "userId"
	DepositScalarFieldEnumAmount DepositScalarFieldEnum = "amount"
)

type WithDrawScalarFieldEnum string

const (
	WithDrawScalarFieldEnumID        WithDrawScalarFieldEnum = "id"
	WithDrawScalarFieldEnumCharge    WithDrawScalarFieldEnum = "charge"
	WithDrawScalarFieldEnumUserID    WithDrawScalarFieldEnum = "userId"
	WithDrawScalarFieldEnumDepositID WithDrawScalarFieldEnum = "depositId"
)

type DepositTransactionScalarFieldEnum string

const (
	DepositTransactionScalarFieldEnumID        DepositTransactionScalarFieldEnum = "id"
	DepositTransactionScalarFieldEnumAmount    DepositTransactionScalarFieldEnum = "amount"
	DepositTransactionScalarFieldEnumDepositID DepositTransactionScalarFieldEnum = "depositId"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type transactionPrismaFields = prismaFields

const transactionFieldID transactionPrismaFields = "id"

const transactionFieldUserID transactionPrismaFields = "userId"

const transactionFieldAmount transactionPrismaFields = "amount"

const transactionFieldToAddress transactionPrismaFields = "toAddress"

const transactionFieldCurrency transactionPrismaFields = "currency"

const transactionFieldTransactionHistory transactionPrismaFields = "TransactionHistory"

type transactionHistoryPrismaFields = prismaFields

const transactionHistoryFieldID transactionHistoryPrismaFields = "id"

const transactionHistoryFieldTransaction transactionHistoryPrismaFields = "transaction"

const transactionHistoryFieldTransactionID transactionHistoryPrismaFields = "transactionId"

const transactionHistoryFieldStatus transactionHistoryPrismaFields = "status"

type depositPrismaFields = prismaFields

const depositFieldID depositPrismaFields = "id"

const depositFieldUserID depositPrismaFields = "userId"

const depositFieldAmount depositPrismaFields = "amount"

const depositFieldWithDraw depositPrismaFields = "WithDraw"

const depositFieldDepositTransaction depositPrismaFields = "DepositTransaction"

type withDrawPrismaFields = prismaFields

const withDrawFieldID withDrawPrismaFields = "id"

const withDrawFieldCharge withDrawPrismaFields = "charge"

const withDrawFieldUserID withDrawPrismaFields = "userId"

const withDrawFieldDeposit withDrawPrismaFields = "deposit"

const withDrawFieldDepositID withDrawPrismaFields = "depositId"

type depositTransactionPrismaFields = prismaFields

const depositTransactionFieldID depositTransactionPrismaFields = "id"

const depositTransactionFieldAmount depositTransactionPrismaFields = "amount"

const depositTransactionFieldDeposit depositTransactionPrismaFields = "deposit"

const depositTransactionFieldDepositID depositTransactionPrismaFields = "depositId"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Transaction = transactionMock{
		mock: m,
	}

	m.TransactionHistory = transactionHistoryMock{
		mock: m,
	}

	m.Deposit = depositMock{
		mock: m,
	}

	m.WithDraw = withDrawMock{
		mock: m,
	}

	m.DepositTransaction = depositTransactionMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Transaction transactionMock

	TransactionHistory transactionHistoryMock

	Deposit depositMock

	WithDraw withDrawMock

	DepositTransaction depositTransactionMock
}

type transactionMock struct {
	mock *Mock
}

type TransactionMockExpectParam interface {
	ExtractQuery() builder.Query
	transactionModel()
}

func (m *transactionMock) Expect(query TransactionMockExpectParam) *transactionMockExec {
	return &transactionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transactionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transactionMockExec) Returns(v TransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionMockExec) ReturnsMany(v []TransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type transactionHistoryMock struct {
	mock *Mock
}

type TransactionHistoryMockExpectParam interface {
	ExtractQuery() builder.Query
	transactionHistoryModel()
}

func (m *transactionHistoryMock) Expect(query TransactionHistoryMockExpectParam) *transactionHistoryMockExec {
	return &transactionHistoryMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type transactionHistoryMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *transactionHistoryMockExec) Returns(v TransactionHistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionHistoryMockExec) ReturnsMany(v []TransactionHistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *transactionHistoryMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type depositMock struct {
	mock *Mock
}

type DepositMockExpectParam interface {
	ExtractQuery() builder.Query
	depositModel()
}

func (m *depositMock) Expect(query DepositMockExpectParam) *depositMockExec {
	return &depositMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type depositMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *depositMockExec) Returns(v DepositModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositMockExec) ReturnsMany(v []DepositModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type withDrawMock struct {
	mock *Mock
}

type WithDrawMockExpectParam interface {
	ExtractQuery() builder.Query
	withDrawModel()
}

func (m *withDrawMock) Expect(query WithDrawMockExpectParam) *withDrawMockExec {
	return &withDrawMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type withDrawMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *withDrawMockExec) Returns(v WithDrawModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *withDrawMockExec) ReturnsMany(v []WithDrawModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *withDrawMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type depositTransactionMock struct {
	mock *Mock
}

type DepositTransactionMockExpectParam interface {
	ExtractQuery() builder.Query
	depositTransactionModel()
}

func (m *depositTransactionMock) Expect(query DepositTransactionMockExpectParam) *depositTransactionMockExec {
	return &depositTransactionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type depositTransactionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *depositTransactionMockExec) Returns(v DepositTransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositTransactionMockExec) ReturnsMany(v []DepositTransactionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *depositTransactionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// TransactionModel represents the Transaction model and is a wrapper for accessing fields and methods
type TransactionModel struct {
	InnerTransaction
	RelationsTransaction
}

// InnerTransaction holds the actual data
type InnerTransaction struct {
	ID        int    `json:"id"`
	UserID    int    `json:"userId"`
	Amount    int    `json:"amount"`
	ToAddress string `json:"toAddress"`
	Currency  string `json:"currency"`
}

// RawTransactionModel is a struct for Transaction when used in raw queries
type RawTransactionModel struct {
	ID        RawInt    `json:"id"`
	UserID    RawInt    `json:"userId"`
	Amount    RawInt    `json:"amount"`
	ToAddress RawString `json:"toAddress"`
	Currency  RawString `json:"currency"`
}

// RelationsTransaction holds the relation data separately
type RelationsTransaction struct {
	TransactionHistory []TransactionHistoryModel `json:"TransactionHistory,omitempty"`
}

func (r TransactionModel) TransactionHistory() (value []TransactionHistoryModel) {
	if r.RelationsTransaction.TransactionHistory == nil {
		panic("attempted to access transactionHistory but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransaction.TransactionHistory
}

// TransactionHistoryModel represents the TransactionHistory model and is a wrapper for accessing fields and methods
type TransactionHistoryModel struct {
	InnerTransactionHistory
	RelationsTransactionHistory
}

// InnerTransactionHistory holds the actual data
type InnerTransactionHistory struct {
	ID            int    `json:"id"`
	TransactionID int    `json:"transactionId"`
	Status        string `json:"status"`
}

// RawTransactionHistoryModel is a struct for TransactionHistory when used in raw queries
type RawTransactionHistoryModel struct {
	ID            RawInt    `json:"id"`
	TransactionID RawInt    `json:"transactionId"`
	Status        RawString `json:"status"`
}

// RelationsTransactionHistory holds the relation data separately
type RelationsTransactionHistory struct {
	Transaction *TransactionModel `json:"transaction,omitempty"`
}

func (r TransactionHistoryModel) Transaction() (value *TransactionModel) {
	if r.RelationsTransactionHistory.Transaction == nil {
		panic("attempted to access transaction but did not fetch it using the .With() syntax")
	}
	return r.RelationsTransactionHistory.Transaction
}

// DepositModel represents the Deposit model and is a wrapper for accessing fields and methods
type DepositModel struct {
	InnerDeposit
	RelationsDeposit
}

// InnerDeposit holds the actual data
type InnerDeposit struct {
	ID     int `json:"id"`
	UserID int `json:"userId"`
	Amount int `json:"amount"`
}

// RawDepositModel is a struct for Deposit when used in raw queries
type RawDepositModel struct {
	ID     RawInt `json:"id"`
	UserID RawInt `json:"userId"`
	Amount RawInt `json:"amount"`
}

// RelationsDeposit holds the relation data separately
type RelationsDeposit struct {
	WithDraw           []WithDrawModel           `json:"WithDraw,omitempty"`
	DepositTransaction []DepositTransactionModel `json:"DepositTransaction,omitempty"`
}

func (r DepositModel) WithDraw() (value []WithDrawModel) {
	if r.RelationsDeposit.WithDraw == nil {
		panic("attempted to access withDraw but did not fetch it using the .With() syntax")
	}
	return r.RelationsDeposit.WithDraw
}

func (r DepositModel) DepositTransaction() (value []DepositTransactionModel) {
	if r.RelationsDeposit.DepositTransaction == nil {
		panic("attempted to access depositTransaction but did not fetch it using the .With() syntax")
	}
	return r.RelationsDeposit.DepositTransaction
}

// WithDrawModel represents the WithDraw model and is a wrapper for accessing fields and methods
type WithDrawModel struct {
	InnerWithDraw
	RelationsWithDraw
}

// InnerWithDraw holds the actual data
type InnerWithDraw struct {
	ID        int `json:"id"`
	Charge    int `json:"charge"`
	UserID    int `json:"userId"`
	DepositID int `json:"depositId"`
}

// RawWithDrawModel is a struct for WithDraw when used in raw queries
type RawWithDrawModel struct {
	ID        RawInt `json:"id"`
	Charge    RawInt `json:"charge"`
	UserID    RawInt `json:"userId"`
	DepositID RawInt `json:"depositId"`
}

// RelationsWithDraw holds the relation data separately
type RelationsWithDraw struct {
	Deposit *DepositModel `json:"deposit,omitempty"`
}

func (r WithDrawModel) Deposit() (value *DepositModel) {
	if r.RelationsWithDraw.Deposit == nil {
		panic("attempted to access deposit but did not fetch it using the .With() syntax")
	}
	return r.RelationsWithDraw.Deposit
}

// DepositTransactionModel represents the DepositTransaction model and is a wrapper for accessing fields and methods
type DepositTransactionModel struct {
	InnerDepositTransaction
	RelationsDepositTransaction
}

// InnerDepositTransaction holds the actual data
type InnerDepositTransaction struct {
	ID        int `json:"id"`
	Amount    int `json:"amount"`
	DepositID int `json:"depositId"`
}

// RawDepositTransactionModel is a struct for DepositTransaction when used in raw queries
type RawDepositTransactionModel struct {
	ID        RawInt `json:"id"`
	Amount    RawInt `json:"amount"`
	DepositID RawInt `json:"depositId"`
}

// RelationsDepositTransaction holds the relation data separately
type RelationsDepositTransaction struct {
	Deposit *DepositModel `json:"deposit,omitempty"`
}

func (r DepositTransactionModel) Deposit() (value *DepositModel) {
	if r.RelationsDepositTransaction.Deposit == nil {
		panic("attempted to access deposit but did not fetch it using the .With() syntax")
	}
	return r.RelationsDepositTransaction.Deposit
}

// --- template query.gotpl ---

// Transaction acts as a namespaces to access query methods for the Transaction model
var Transaction = transactionQuery{}

// transactionQuery exposes query functions for the transaction model
type transactionQuery struct {

	// ID
	//
	// @required
	ID transactionQueryIDInt

	// UserID
	//
	// @required
	UserID transactionQueryUserIDInt

	// Amount
	//
	// @required
	Amount transactionQueryAmountInt

	// ToAddress
	//
	// @required
	ToAddress transactionQueryToAddressString

	// Currency
	//
	// @required
	Currency transactionQueryCurrencyString

	TransactionHistory transactionQueryTransactionHistoryRelations
}

func (transactionQuery) Not(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionQuery) Or(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionQuery) And(params ...TransactionWhereParam) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transactionQueryIDInt struct{}

// Set the required value of ID
func (r transactionQueryIDInt) Set(value int) transactionSetParam {

	return transactionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transactionQueryIDInt) SetIfPresent(value *Int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r transactionQueryIDInt) Increment(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) IncrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r transactionQueryIDInt) Decrement(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) DecrementIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r transactionQueryIDInt) Multiply(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) MultiplyIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r transactionQueryIDInt) Divide(value int) transactionSetParam {
	return transactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) DivideIfPresent(value *int) transactionSetParam {
	if value == nil {
		return transactionSetParam{}
	}
	return r.Divide(*value)
}

func (r transactionQueryIDInt) Equals(value int) transactionWithPrismaIDEqualsUniqueParam {

	return transactionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) EqualsIfPresent(value *int) transactionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transactionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryIDInt) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transactionQueryIDInt) Cursor(cursor int) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transactionQueryIDInt) In(value []int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) InIfPresent(value []int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.In(value)
}

func (r transactionQueryIDInt) NotIn(value []int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) NotInIfPresent(value []int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.NotIn(value)
}

func (r transactionQueryIDInt) Lt(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) LtIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Lt(*value)
}

func (r transactionQueryIDInt) Lte(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) LteIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Lte(*value)
}

func (r transactionQueryIDInt) Gt(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) GtIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Gt(*value)
}

func (r transactionQueryIDInt) Gte(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) GteIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Gte(*value)
}

func (r transactionQueryIDInt) Not(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryIDInt) NotIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionQueryIDInt) LT(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionQueryIDInt) LTIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionQueryIDInt) LTE(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionQueryIDInt) LTEIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionQueryIDInt) GT(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionQueryIDInt) GTIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionQueryIDInt) GTE(value int) transactionParamUnique {
	return transactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionQueryIDInt) GTEIfPresent(value *int) transactionParamUnique {
	if value == nil {
		return transactionParamUnique{}
	}
	return r.GTE(*value)
}

func (r transactionQueryIDInt) Field() transactionPrismaFields {
	return transactionFieldID
}

// base struct
type transactionQueryUserIDInt struct{}

// Set the required value of UserID
func (r transactionQueryUserIDInt) Set(value int) transactionWithPrismaUserIDSetParam {

	return transactionWithPrismaUserIDSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r transactionQueryUserIDInt) SetIfPresent(value *Int) transactionWithPrismaUserIDSetParam {
	if value == nil {
		return transactionWithPrismaUserIDSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r transactionQueryUserIDInt) Increment(value int) transactionWithPrismaUserIDSetParam {
	return transactionWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) IncrementIfPresent(value *int) transactionWithPrismaUserIDSetParam {
	if value == nil {
		return transactionWithPrismaUserIDSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r transactionQueryUserIDInt) Decrement(value int) transactionWithPrismaUserIDSetParam {
	return transactionWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) DecrementIfPresent(value *int) transactionWithPrismaUserIDSetParam {
	if value == nil {
		return transactionWithPrismaUserIDSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r transactionQueryUserIDInt) Multiply(value int) transactionWithPrismaUserIDSetParam {
	return transactionWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) MultiplyIfPresent(value *int) transactionWithPrismaUserIDSetParam {
	if value == nil {
		return transactionWithPrismaUserIDSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r transactionQueryUserIDInt) Divide(value int) transactionWithPrismaUserIDSetParam {
	return transactionWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) DivideIfPresent(value *int) transactionWithPrismaUserIDSetParam {
	if value == nil {
		return transactionWithPrismaUserIDSetParam{}
	}
	return r.Divide(*value)
}

func (r transactionQueryUserIDInt) Equals(value int) transactionWithPrismaUserIDEqualsParam {

	return transactionWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) EqualsIfPresent(value *int) transactionWithPrismaUserIDEqualsParam {
	if value == nil {
		return transactionWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryUserIDInt) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r transactionQueryUserIDInt) Cursor(cursor int) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r transactionQueryUserIDInt) In(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) InIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryUserIDInt) NotIn(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) NotInIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryUserIDInt) Lt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) LtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryUserIDInt) Lte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) LteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryUserIDInt) Gt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) GtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryUserIDInt) Gte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) GteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryUserIDInt) Not(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryUserIDInt) NotIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionQueryUserIDInt) LT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionQueryUserIDInt) LTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionQueryUserIDInt) LTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionQueryUserIDInt) LTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionQueryUserIDInt) GT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionQueryUserIDInt) GTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionQueryUserIDInt) GTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionQueryUserIDInt) GTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r transactionQueryUserIDInt) Field() transactionPrismaFields {
	return transactionFieldUserID
}

// base struct
type transactionQueryAmountInt struct{}

// Set the required value of Amount
func (r transactionQueryAmountInt) Set(value int) transactionWithPrismaAmountSetParam {

	return transactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name:  "amount",
			Value: value,
		},
	}

}

// Set the optional value of Amount dynamically
func (r transactionQueryAmountInt) SetIfPresent(value *Int) transactionWithPrismaAmountSetParam {
	if value == nil {
		return transactionWithPrismaAmountSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Amount
func (r transactionQueryAmountInt) Increment(value int) transactionWithPrismaAmountSetParam {
	return transactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) IncrementIfPresent(value *int) transactionWithPrismaAmountSetParam {
	if value == nil {
		return transactionWithPrismaAmountSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Amount
func (r transactionQueryAmountInt) Decrement(value int) transactionWithPrismaAmountSetParam {
	return transactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) DecrementIfPresent(value *int) transactionWithPrismaAmountSetParam {
	if value == nil {
		return transactionWithPrismaAmountSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Amount
func (r transactionQueryAmountInt) Multiply(value int) transactionWithPrismaAmountSetParam {
	return transactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) MultiplyIfPresent(value *int) transactionWithPrismaAmountSetParam {
	if value == nil {
		return transactionWithPrismaAmountSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Amount
func (r transactionQueryAmountInt) Divide(value int) transactionWithPrismaAmountSetParam {
	return transactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) DivideIfPresent(value *int) transactionWithPrismaAmountSetParam {
	if value == nil {
		return transactionWithPrismaAmountSetParam{}
	}
	return r.Divide(*value)
}

func (r transactionQueryAmountInt) Equals(value int) transactionWithPrismaAmountEqualsParam {

	return transactionWithPrismaAmountEqualsParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) EqualsIfPresent(value *int) transactionWithPrismaAmountEqualsParam {
	if value == nil {
		return transactionWithPrismaAmountEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryAmountInt) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "amount",
			Value: direction,
		},
	}
}

func (r transactionQueryAmountInt) Cursor(cursor int) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "amount",
			Value: cursor,
		},
	}
}

func (r transactionQueryAmountInt) In(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) InIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryAmountInt) NotIn(value []int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) NotInIfPresent(value []int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryAmountInt) Lt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) LtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryAmountInt) Lte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) LteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryAmountInt) Gt(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) GtIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryAmountInt) Gte(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) GteIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryAmountInt) Not(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryAmountInt) NotIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionQueryAmountInt) LT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionQueryAmountInt) LTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionQueryAmountInt) LTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionQueryAmountInt) LTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionQueryAmountInt) GT(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionQueryAmountInt) GTIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionQueryAmountInt) GTE(value int) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionQueryAmountInt) GTEIfPresent(value *int) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r transactionQueryAmountInt) Field() transactionPrismaFields {
	return transactionFieldAmount
}

// base struct
type transactionQueryToAddressString struct{}

// Set the required value of ToAddress
func (r transactionQueryToAddressString) Set(value string) transactionWithPrismaToAddressSetParam {

	return transactionWithPrismaToAddressSetParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: value,
		},
	}

}

// Set the optional value of ToAddress dynamically
func (r transactionQueryToAddressString) SetIfPresent(value *String) transactionWithPrismaToAddressSetParam {
	if value == nil {
		return transactionWithPrismaToAddressSetParam{}
	}

	return r.Set(*value)
}

func (r transactionQueryToAddressString) Equals(value string) transactionWithPrismaToAddressEqualsParam {

	return transactionWithPrismaToAddressEqualsParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) EqualsIfPresent(value *string) transactionWithPrismaToAddressEqualsParam {
	if value == nil {
		return transactionWithPrismaToAddressEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryToAddressString) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: direction,
		},
	}
}

func (r transactionQueryToAddressString) Cursor(cursor string) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "toAddress",
			Value: cursor,
		},
	}
}

func (r transactionQueryToAddressString) In(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) InIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryToAddressString) NotIn(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) NotInIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryToAddressString) Lt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) LtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryToAddressString) Lte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) LteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryToAddressString) Gt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) GtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryToAddressString) Gte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) GteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryToAddressString) Contains(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) ContainsIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionQueryToAddressString) StartsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) StartsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionQueryToAddressString) EndsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) EndsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionQueryToAddressString) Mode(value QueryMode) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) ModeIfPresent(value *QueryMode) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionQueryToAddressString) Not(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryToAddressString) NotIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionQueryToAddressString) HasPrefix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionQueryToAddressString) HasPrefixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionQueryToAddressString) HasSuffix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "toAddress",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionQueryToAddressString) HasSuffixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionQueryToAddressString) Field() transactionPrismaFields {
	return transactionFieldToAddress
}

// base struct
type transactionQueryCurrencyString struct{}

// Set the required value of Currency
func (r transactionQueryCurrencyString) Set(value string) transactionWithPrismaCurrencySetParam {

	return transactionWithPrismaCurrencySetParam{
		data: builder.Field{
			Name:  "currency",
			Value: value,
		},
	}

}

// Set the optional value of Currency dynamically
func (r transactionQueryCurrencyString) SetIfPresent(value *String) transactionWithPrismaCurrencySetParam {
	if value == nil {
		return transactionWithPrismaCurrencySetParam{}
	}

	return r.Set(*value)
}

func (r transactionQueryCurrencyString) Equals(value string) transactionWithPrismaCurrencyEqualsParam {

	return transactionWithPrismaCurrencyEqualsParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) EqualsIfPresent(value *string) transactionWithPrismaCurrencyEqualsParam {
	if value == nil {
		return transactionWithPrismaCurrencyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionQueryCurrencyString) Order(direction SortOrder) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name:  "currency",
			Value: direction,
		},
	}
}

func (r transactionQueryCurrencyString) Cursor(cursor string) transactionCursorParam {
	return transactionCursorParam{
		data: builder.Field{
			Name:  "currency",
			Value: cursor,
		},
	}
}

func (r transactionQueryCurrencyString) In(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) InIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.In(value)
}

func (r transactionQueryCurrencyString) NotIn(value []string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) NotInIfPresent(value []string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionQueryCurrencyString) Lt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) LtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionQueryCurrencyString) Lte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) LteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionQueryCurrencyString) Gt(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) GtIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionQueryCurrencyString) Gte(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) GteIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionQueryCurrencyString) Contains(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) ContainsIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionQueryCurrencyString) StartsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) StartsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionQueryCurrencyString) EndsWith(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) EndsWithIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionQueryCurrencyString) Mode(value QueryMode) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) ModeIfPresent(value *QueryMode) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionQueryCurrencyString) Not(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionQueryCurrencyString) NotIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionQueryCurrencyString) HasPrefix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionQueryCurrencyString) HasPrefixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionQueryCurrencyString) HasSuffix(value string) transactionDefaultParam {
	return transactionDefaultParam{
		data: builder.Field{
			Name: "currency",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionQueryCurrencyString) HasSuffixIfPresent(value *string) transactionDefaultParam {
	if value == nil {
		return transactionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionQueryCurrencyString) Field() transactionPrismaFields {
	return transactionFieldCurrency
}

// base struct
type transactionQueryTransactionHistoryTransactionHistory struct{}

type transactionQueryTransactionHistoryRelations struct{}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) Some(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) Every(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Transaction -> TransactionHistory
//
// @relation
// @required
func (transactionQueryTransactionHistoryRelations) None(
	params ...TransactionHistoryWhereParam,
) transactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionDefaultParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (transactionQueryTransactionHistoryRelations) Fetch(

	params ...TransactionHistoryWhereParam,

) transactionToTransactionHistoryFindMany {
	var v transactionToTransactionHistoryFindMany

	v.query.Operation = "query"
	v.query.Method = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionQueryTransactionHistoryRelations) Link(
	params ...TransactionHistoryWhereParam,
) transactionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionSetParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r transactionQueryTransactionHistoryRelations) Unlink(
	params ...TransactionHistoryWhereParam,
) transactionSetParam {
	var v transactionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = transactionSetParam{
		data: builder.Field{
			Name: "TransactionHistory",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r transactionQueryTransactionHistoryTransactionHistory) Field() transactionPrismaFields {
	return transactionFieldTransactionHistory
}

// TransactionHistory acts as a namespaces to access query methods for the TransactionHistory model
var TransactionHistory = transactionHistoryQuery{}

// transactionHistoryQuery exposes query functions for the transactionHistory model
type transactionHistoryQuery struct {

	// ID
	//
	// @required
	ID transactionHistoryQueryIDInt

	Transaction transactionHistoryQueryTransactionRelations

	// TransactionID
	//
	// @required
	TransactionID transactionHistoryQueryTransactionIDInt

	// Status
	//
	// @required
	Status transactionHistoryQueryStatusString
}

func (transactionHistoryQuery) Not(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionHistoryQuery) Or(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (transactionHistoryQuery) And(params ...TransactionHistoryWhereParam) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type transactionHistoryQueryIDInt struct{}

// Set the required value of ID
func (r transactionHistoryQueryIDInt) Set(value int) transactionHistorySetParam {

	return transactionHistorySetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r transactionHistoryQueryIDInt) SetIfPresent(value *Int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r transactionHistoryQueryIDInt) Increment(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) IncrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r transactionHistoryQueryIDInt) Decrement(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) DecrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r transactionHistoryQueryIDInt) Multiply(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) MultiplyIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r transactionHistoryQueryIDInt) Divide(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) DivideIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Divide(*value)
}

func (r transactionHistoryQueryIDInt) Equals(value int) transactionHistoryWithPrismaIDEqualsUniqueParam {

	return transactionHistoryWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) EqualsIfPresent(value *int) transactionHistoryWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return transactionHistoryWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryIDInt) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryIDInt) Cursor(cursor int) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryIDInt) In(value []int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) InIfPresent(value []int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryIDInt) NotIn(value []int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) NotInIfPresent(value []int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryIDInt) Lt(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) LtIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryIDInt) Lte(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) LteIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryIDInt) Gt(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) GtIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryIDInt) Gte(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) GteIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryIDInt) Not(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryIDInt) NotIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionHistoryQueryIDInt) LT(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionHistoryQueryIDInt) LTIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionHistoryQueryIDInt) LTE(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionHistoryQueryIDInt) LTEIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionHistoryQueryIDInt) GT(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionHistoryQueryIDInt) GTIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionHistoryQueryIDInt) GTE(value int) transactionHistoryParamUnique {
	return transactionHistoryParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionHistoryQueryIDInt) GTEIfPresent(value *int) transactionHistoryParamUnique {
	if value == nil {
		return transactionHistoryParamUnique{}
	}
	return r.GTE(*value)
}

func (r transactionHistoryQueryIDInt) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldID
}

// base struct
type transactionHistoryQueryTransactionTransaction struct{}

type transactionHistoryQueryTransactionRelations struct{}

// TransactionHistory -> Transaction
//
// @relation
// @required
func (transactionHistoryQueryTransactionRelations) Where(
	params ...TransactionWhereParam,
) transactionHistoryDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (transactionHistoryQueryTransactionRelations) Fetch() transactionHistoryToTransactionFindUnique {
	var v transactionHistoryToTransactionFindUnique

	v.query.Operation = "query"
	v.query.Method = "transaction"
	v.query.Outputs = transactionOutput

	return v
}

func (r transactionHistoryQueryTransactionRelations) Link(
	params TransactionWhereParam,
) transactionHistoryWithPrismaTransactionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return transactionHistoryWithPrismaTransactionSetParam{}
	}

	fields = append(fields, f)

	return transactionHistoryWithPrismaTransactionSetParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionRelations) Unlink() transactionHistoryWithPrismaTransactionSetParam {
	var v transactionHistoryWithPrismaTransactionSetParam

	v = transactionHistoryWithPrismaTransactionSetParam{
		data: builder.Field{
			Name: "transaction",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r transactionHistoryQueryTransactionTransaction) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldTransaction
}

// base struct
type transactionHistoryQueryTransactionIDInt struct{}

// Set the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Set(value int) transactionHistorySetParam {

	return transactionHistorySetParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: value,
		},
	}

}

// Set the optional value of TransactionID dynamically
func (r transactionHistoryQueryTransactionIDInt) SetIfPresent(value *Int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Increment(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) IncrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Decrement(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) DecrementIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Multiply(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) MultiplyIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of TransactionID
func (r transactionHistoryQueryTransactionIDInt) Divide(value int) transactionHistorySetParam {
	return transactionHistorySetParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) DivideIfPresent(value *int) transactionHistorySetParam {
	if value == nil {
		return transactionHistorySetParam{}
	}
	return r.Divide(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Equals(value int) transactionHistoryWithPrismaTransactionIDEqualsParam {

	return transactionHistoryWithPrismaTransactionIDEqualsParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) EqualsIfPresent(value *int) transactionHistoryWithPrismaTransactionIDEqualsParam {
	if value == nil {
		return transactionHistoryWithPrismaTransactionIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) Cursor(cursor int) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "transactionId",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) In(value []int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) InIfPresent(value []int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryTransactionIDInt) NotIn(value []int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) NotInIfPresent(value []int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryTransactionIDInt) Lt(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) LtIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Lte(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) LteIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Gt(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) GtIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Gte(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) GteIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Not(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryTransactionIDInt) NotIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r transactionHistoryQueryTransactionIDInt) LT(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) LTIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r transactionHistoryQueryTransactionIDInt) LTE(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) LTEIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r transactionHistoryQueryTransactionIDInt) GT(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) GTIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r transactionHistoryQueryTransactionIDInt) GTE(value int) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "transactionId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r transactionHistoryQueryTransactionIDInt) GTEIfPresent(value *int) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.GTE(*value)
}

func (r transactionHistoryQueryTransactionIDInt) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldTransactionID
}

// base struct
type transactionHistoryQueryStatusString struct{}

// Set the required value of Status
func (r transactionHistoryQueryStatusString) Set(value string) transactionHistoryWithPrismaStatusSetParam {

	return transactionHistoryWithPrismaStatusSetParam{
		data: builder.Field{
			Name:  "status",
			Value: value,
		},
	}

}

// Set the optional value of Status dynamically
func (r transactionHistoryQueryStatusString) SetIfPresent(value *String) transactionHistoryWithPrismaStatusSetParam {
	if value == nil {
		return transactionHistoryWithPrismaStatusSetParam{}
	}

	return r.Set(*value)
}

func (r transactionHistoryQueryStatusString) Equals(value string) transactionHistoryWithPrismaStatusEqualsParam {

	return transactionHistoryWithPrismaStatusEqualsParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) EqualsIfPresent(value *string) transactionHistoryWithPrismaStatusEqualsParam {
	if value == nil {
		return transactionHistoryWithPrismaStatusEqualsParam{}
	}
	return r.Equals(*value)
}

func (r transactionHistoryQueryStatusString) Order(direction SortOrder) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name:  "status",
			Value: direction,
		},
	}
}

func (r transactionHistoryQueryStatusString) Cursor(cursor string) transactionHistoryCursorParam {
	return transactionHistoryCursorParam{
		data: builder.Field{
			Name:  "status",
			Value: cursor,
		},
	}
}

func (r transactionHistoryQueryStatusString) In(value []string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) InIfPresent(value []string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.In(value)
}

func (r transactionHistoryQueryStatusString) NotIn(value []string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) NotInIfPresent(value []string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.NotIn(value)
}

func (r transactionHistoryQueryStatusString) Lt(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) LtIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lt(*value)
}

func (r transactionHistoryQueryStatusString) Lte(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) LteIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Lte(*value)
}

func (r transactionHistoryQueryStatusString) Gt(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) GtIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gt(*value)
}

func (r transactionHistoryQueryStatusString) Gte(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) GteIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Gte(*value)
}

func (r transactionHistoryQueryStatusString) Contains(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) ContainsIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Contains(*value)
}

func (r transactionHistoryQueryStatusString) StartsWith(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) StartsWithIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r transactionHistoryQueryStatusString) EndsWith(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) EndsWithIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r transactionHistoryQueryStatusString) Mode(value QueryMode) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) ModeIfPresent(value *QueryMode) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Mode(*value)
}

func (r transactionHistoryQueryStatusString) Not(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r transactionHistoryQueryStatusString) NotIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r transactionHistoryQueryStatusString) HasPrefix(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r transactionHistoryQueryStatusString) HasPrefixIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r transactionHistoryQueryStatusString) HasSuffix(value string) transactionHistoryDefaultParam {
	return transactionHistoryDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r transactionHistoryQueryStatusString) HasSuffixIfPresent(value *string) transactionHistoryDefaultParam {
	if value == nil {
		return transactionHistoryDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r transactionHistoryQueryStatusString) Field() transactionHistoryPrismaFields {
	return transactionHistoryFieldStatus
}

// Deposit acts as a namespaces to access query methods for the Deposit model
var Deposit = depositQuery{}

// depositQuery exposes query functions for the deposit model
type depositQuery struct {

	// ID
	//
	// @required
	ID depositQueryIDInt

	// UserID
	//
	// @required
	UserID depositQueryUserIDInt

	// Amount
	//
	// @required
	Amount depositQueryAmountInt

	WithDraw depositQueryWithDrawRelations

	DepositTransaction depositQueryDepositTransactionRelations
}

func (depositQuery) Not(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositQuery) Or(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositQuery) And(params ...DepositWhereParam) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type depositQueryIDInt struct{}

// Set the required value of ID
func (r depositQueryIDInt) Set(value int) depositSetParam {

	return depositSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r depositQueryIDInt) SetIfPresent(value *Int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r depositQueryIDInt) Increment(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) IncrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r depositQueryIDInt) Decrement(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) DecrementIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r depositQueryIDInt) Multiply(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) MultiplyIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r depositQueryIDInt) Divide(value int) depositSetParam {
	return depositSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) DivideIfPresent(value *int) depositSetParam {
	if value == nil {
		return depositSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryIDInt) Equals(value int) depositWithPrismaIDEqualsUniqueParam {

	return depositWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) EqualsIfPresent(value *int) depositWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return depositWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryIDInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r depositQueryIDInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r depositQueryIDInt) In(value []int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) InIfPresent(value []int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.In(value)
}

func (r depositQueryIDInt) NotIn(value []int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) NotInIfPresent(value []int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.NotIn(value)
}

func (r depositQueryIDInt) Lt(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) LtIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Lt(*value)
}

func (r depositQueryIDInt) Lte(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) LteIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Lte(*value)
}

func (r depositQueryIDInt) Gt(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) GtIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Gt(*value)
}

func (r depositQueryIDInt) Gte(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) GteIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Gte(*value)
}

func (r depositQueryIDInt) Not(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryIDInt) NotIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryIDInt) LT(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryIDInt) LTIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryIDInt) LTE(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryIDInt) LTEIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryIDInt) GT(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryIDInt) GTIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryIDInt) GTE(value int) depositParamUnique {
	return depositParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryIDInt) GTEIfPresent(value *int) depositParamUnique {
	if value == nil {
		return depositParamUnique{}
	}
	return r.GTE(*value)
}

func (r depositQueryIDInt) Field() depositPrismaFields {
	return depositFieldID
}

// base struct
type depositQueryUserIDInt struct{}

// Set the required value of UserID
func (r depositQueryUserIDInt) Set(value int) depositWithPrismaUserIDSetParam {

	return depositWithPrismaUserIDSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r depositQueryUserIDInt) SetIfPresent(value *Int) depositWithPrismaUserIDSetParam {
	if value == nil {
		return depositWithPrismaUserIDSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r depositQueryUserIDInt) Increment(value int) depositWithPrismaUserIDSetParam {
	return depositWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) IncrementIfPresent(value *int) depositWithPrismaUserIDSetParam {
	if value == nil {
		return depositWithPrismaUserIDSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r depositQueryUserIDInt) Decrement(value int) depositWithPrismaUserIDSetParam {
	return depositWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) DecrementIfPresent(value *int) depositWithPrismaUserIDSetParam {
	if value == nil {
		return depositWithPrismaUserIDSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r depositQueryUserIDInt) Multiply(value int) depositWithPrismaUserIDSetParam {
	return depositWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) MultiplyIfPresent(value *int) depositWithPrismaUserIDSetParam {
	if value == nil {
		return depositWithPrismaUserIDSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r depositQueryUserIDInt) Divide(value int) depositWithPrismaUserIDSetParam {
	return depositWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) DivideIfPresent(value *int) depositWithPrismaUserIDSetParam {
	if value == nil {
		return depositWithPrismaUserIDSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryUserIDInt) Equals(value int) depositWithPrismaUserIDEqualsParam {

	return depositWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) EqualsIfPresent(value *int) depositWithPrismaUserIDEqualsParam {
	if value == nil {
		return depositWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryUserIDInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r depositQueryUserIDInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r depositQueryUserIDInt) In(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) InIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.In(value)
}

func (r depositQueryUserIDInt) NotIn(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) NotInIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositQueryUserIDInt) Lt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) LtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositQueryUserIDInt) Lte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) LteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositQueryUserIDInt) Gt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) GtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositQueryUserIDInt) Gte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) GteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositQueryUserIDInt) Not(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryUserIDInt) NotIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryUserIDInt) LT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryUserIDInt) LTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryUserIDInt) LTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryUserIDInt) LTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryUserIDInt) GT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryUserIDInt) GTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryUserIDInt) GTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryUserIDInt) GTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositQueryUserIDInt) Field() depositPrismaFields {
	return depositFieldUserID
}

// base struct
type depositQueryAmountInt struct{}

// Set the required value of Amount
func (r depositQueryAmountInt) Set(value int) depositWithPrismaAmountSetParam {

	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name:  "amount",
			Value: value,
		},
	}

}

// Set the optional value of Amount dynamically
func (r depositQueryAmountInt) SetIfPresent(value *Int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Amount
func (r depositQueryAmountInt) Increment(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) IncrementIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Amount
func (r depositQueryAmountInt) Decrement(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) DecrementIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Amount
func (r depositQueryAmountInt) Multiply(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) MultiplyIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Amount
func (r depositQueryAmountInt) Divide(value int) depositWithPrismaAmountSetParam {
	return depositWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) DivideIfPresent(value *int) depositWithPrismaAmountSetParam {
	if value == nil {
		return depositWithPrismaAmountSetParam{}
	}
	return r.Divide(*value)
}

func (r depositQueryAmountInt) Equals(value int) depositWithPrismaAmountEqualsParam {

	return depositWithPrismaAmountEqualsParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) EqualsIfPresent(value *int) depositWithPrismaAmountEqualsParam {
	if value == nil {
		return depositWithPrismaAmountEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositQueryAmountInt) Order(direction SortOrder) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name:  "amount",
			Value: direction,
		},
	}
}

func (r depositQueryAmountInt) Cursor(cursor int) depositCursorParam {
	return depositCursorParam{
		data: builder.Field{
			Name:  "amount",
			Value: cursor,
		},
	}
}

func (r depositQueryAmountInt) In(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) InIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.In(value)
}

func (r depositQueryAmountInt) NotIn(value []int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) NotInIfPresent(value []int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositQueryAmountInt) Lt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) LtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositQueryAmountInt) Lte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) LteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositQueryAmountInt) Gt(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) GtIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositQueryAmountInt) Gte(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) GteIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositQueryAmountInt) Not(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositQueryAmountInt) NotIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositQueryAmountInt) LT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositQueryAmountInt) LTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositQueryAmountInt) LTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositQueryAmountInt) LTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositQueryAmountInt) GT(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositQueryAmountInt) GTIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositQueryAmountInt) GTE(value int) depositDefaultParam {
	return depositDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositQueryAmountInt) GTEIfPresent(value *int) depositDefaultParam {
	if value == nil {
		return depositDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositQueryAmountInt) Field() depositPrismaFields {
	return depositFieldAmount
}

// base struct
type depositQueryWithDrawWithDraw struct{}

type depositQueryWithDrawRelations struct{}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) Some(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) Every(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> WithDraw
//
// @relation
// @required
func (depositQueryWithDrawRelations) None(
	params ...WithDrawWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (depositQueryWithDrawRelations) Fetch(

	params ...WithDrawWhereParam,

) depositToWithDrawFindMany {
	var v depositToWithDrawFindMany

	v.query.Operation = "query"
	v.query.Method = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositQueryWithDrawRelations) Link(
	params ...WithDrawWhereParam,
) depositSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r depositQueryWithDrawRelations) Unlink(
	params ...WithDrawWhereParam,
) depositSetParam {
	var v depositSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = depositSetParam{
		data: builder.Field{
			Name: "WithDraw",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r depositQueryWithDrawWithDraw) Field() depositPrismaFields {
	return depositFieldWithDraw
}

// base struct
type depositQueryDepositTransactionDepositTransaction struct{}

type depositQueryDepositTransactionRelations struct{}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) Some(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) Every(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Deposit -> DepositTransaction
//
// @relation
// @required
func (depositQueryDepositTransactionRelations) None(
	params ...DepositTransactionWhereParam,
) depositDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositDefaultParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (depositQueryDepositTransactionRelations) Fetch(

	params ...DepositTransactionWhereParam,

) depositToDepositTransactionFindMany {
	var v depositToDepositTransactionFindMany

	v.query.Operation = "query"
	v.query.Method = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositQueryDepositTransactionRelations) Link(
	params ...DepositTransactionWhereParam,
) depositSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositSetParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r depositQueryDepositTransactionRelations) Unlink(
	params ...DepositTransactionWhereParam,
) depositSetParam {
	var v depositSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = depositSetParam{
		data: builder.Field{
			Name: "DepositTransaction",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r depositQueryDepositTransactionDepositTransaction) Field() depositPrismaFields {
	return depositFieldDepositTransaction
}

// WithDraw acts as a namespaces to access query methods for the WithDraw model
var WithDraw = withDrawQuery{}

// withDrawQuery exposes query functions for the withDraw model
type withDrawQuery struct {

	// ID
	//
	// @required
	ID withDrawQueryIDInt

	// Charge
	//
	// @required
	Charge withDrawQueryChargeInt

	// UserID
	//
	// @required
	UserID withDrawQueryUserIDInt

	Deposit withDrawQueryDepositRelations

	// DepositID
	//
	// @required
	DepositID withDrawQueryDepositIDInt
}

func (withDrawQuery) Not(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (withDrawQuery) Or(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (withDrawQuery) And(params ...WithDrawWhereParam) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type withDrawQueryIDInt struct{}

// Set the required value of ID
func (r withDrawQueryIDInt) Set(value int) withDrawSetParam {

	return withDrawSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r withDrawQueryIDInt) SetIfPresent(value *Int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r withDrawQueryIDInt) Increment(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) IncrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r withDrawQueryIDInt) Decrement(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) DecrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r withDrawQueryIDInt) Multiply(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) MultiplyIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r withDrawQueryIDInt) Divide(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) DivideIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryIDInt) Equals(value int) withDrawWithPrismaIDEqualsUniqueParam {

	return withDrawWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) EqualsIfPresent(value *int) withDrawWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return withDrawWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r withDrawQueryIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r withDrawQueryIDInt) In(value []int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) InIfPresent(value []int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.In(value)
}

func (r withDrawQueryIDInt) NotIn(value []int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) NotInIfPresent(value []int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryIDInt) Lt(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) LtIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryIDInt) Lte(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) LteIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryIDInt) Gt(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) GtIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryIDInt) Gte(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) GteIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryIDInt) Not(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryIDInt) NotIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryIDInt) LT(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryIDInt) LTIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryIDInt) LTE(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryIDInt) LTEIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryIDInt) GT(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryIDInt) GTIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryIDInt) GTE(value int) withDrawParamUnique {
	return withDrawParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryIDInt) GTEIfPresent(value *int) withDrawParamUnique {
	if value == nil {
		return withDrawParamUnique{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryIDInt) Field() withDrawPrismaFields {
	return withDrawFieldID
}

// base struct
type withDrawQueryChargeInt struct{}

// Set the required value of Charge
func (r withDrawQueryChargeInt) Set(value int) withDrawWithPrismaChargeSetParam {

	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name:  "charge",
			Value: value,
		},
	}

}

// Set the optional value of Charge dynamically
func (r withDrawQueryChargeInt) SetIfPresent(value *Int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Charge
func (r withDrawQueryChargeInt) Increment(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) IncrementIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Charge
func (r withDrawQueryChargeInt) Decrement(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) DecrementIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Charge
func (r withDrawQueryChargeInt) Multiply(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) MultiplyIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Charge
func (r withDrawQueryChargeInt) Divide(value int) withDrawWithPrismaChargeSetParam {
	return withDrawWithPrismaChargeSetParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) DivideIfPresent(value *int) withDrawWithPrismaChargeSetParam {
	if value == nil {
		return withDrawWithPrismaChargeSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryChargeInt) Equals(value int) withDrawWithPrismaChargeEqualsParam {

	return withDrawWithPrismaChargeEqualsParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) EqualsIfPresent(value *int) withDrawWithPrismaChargeEqualsParam {
	if value == nil {
		return withDrawWithPrismaChargeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryChargeInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "charge",
			Value: direction,
		},
	}
}

func (r withDrawQueryChargeInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "charge",
			Value: cursor,
		},
	}
}

func (r withDrawQueryChargeInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryChargeInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryChargeInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryChargeInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryChargeInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryChargeInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryChargeInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryChargeInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryChargeInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryChargeInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryChargeInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryChargeInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryChargeInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryChargeInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryChargeInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "charge",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryChargeInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryChargeInt) Field() withDrawPrismaFields {
	return withDrawFieldCharge
}

// base struct
type withDrawQueryUserIDInt struct{}

// Set the required value of UserID
func (r withDrawQueryUserIDInt) Set(value int) withDrawWithPrismaUserIDSetParam {

	return withDrawWithPrismaUserIDSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r withDrawQueryUserIDInt) SetIfPresent(value *Int) withDrawWithPrismaUserIDSetParam {
	if value == nil {
		return withDrawWithPrismaUserIDSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of UserID
func (r withDrawQueryUserIDInt) Increment(value int) withDrawWithPrismaUserIDSetParam {
	return withDrawWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) IncrementIfPresent(value *int) withDrawWithPrismaUserIDSetParam {
	if value == nil {
		return withDrawWithPrismaUserIDSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of UserID
func (r withDrawQueryUserIDInt) Decrement(value int) withDrawWithPrismaUserIDSetParam {
	return withDrawWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) DecrementIfPresent(value *int) withDrawWithPrismaUserIDSetParam {
	if value == nil {
		return withDrawWithPrismaUserIDSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of UserID
func (r withDrawQueryUserIDInt) Multiply(value int) withDrawWithPrismaUserIDSetParam {
	return withDrawWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) MultiplyIfPresent(value *int) withDrawWithPrismaUserIDSetParam {
	if value == nil {
		return withDrawWithPrismaUserIDSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of UserID
func (r withDrawQueryUserIDInt) Divide(value int) withDrawWithPrismaUserIDSetParam {
	return withDrawWithPrismaUserIDSetParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) DivideIfPresent(value *int) withDrawWithPrismaUserIDSetParam {
	if value == nil {
		return withDrawWithPrismaUserIDSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryUserIDInt) Equals(value int) withDrawWithPrismaUserIDEqualsParam {

	return withDrawWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) EqualsIfPresent(value *int) withDrawWithPrismaUserIDEqualsParam {
	if value == nil {
		return withDrawWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryUserIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r withDrawQueryUserIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r withDrawQueryUserIDInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryUserIDInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryUserIDInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryUserIDInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryUserIDInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryUserIDInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryUserIDInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryUserIDInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryUserIDInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryUserIDInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryUserIDInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryUserIDInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryUserIDInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryUserIDInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryUserIDInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryUserIDInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryUserIDInt) Field() withDrawPrismaFields {
	return withDrawFieldUserID
}

// base struct
type withDrawQueryDepositDeposit struct{}

type withDrawQueryDepositRelations struct{}

// WithDraw -> Deposit
//
// @relation
// @required
func (withDrawQueryDepositRelations) Where(
	params ...DepositWhereParam,
) withDrawDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return withDrawDefaultParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (withDrawQueryDepositRelations) Fetch() withDrawToDepositFindUnique {
	var v withDrawToDepositFindUnique

	v.query.Operation = "query"
	v.query.Method = "deposit"
	v.query.Outputs = depositOutput

	return v
}

func (r withDrawQueryDepositRelations) Link(
	params DepositWhereParam,
) withDrawWithPrismaDepositSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return withDrawWithPrismaDepositSetParam{}
	}

	fields = append(fields, f)

	return withDrawWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r withDrawQueryDepositRelations) Unlink() withDrawWithPrismaDepositSetParam {
	var v withDrawWithPrismaDepositSetParam

	v = withDrawWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r withDrawQueryDepositDeposit) Field() withDrawPrismaFields {
	return withDrawFieldDeposit
}

// base struct
type withDrawQueryDepositIDInt struct{}

// Set the required value of DepositID
func (r withDrawQueryDepositIDInt) Set(value int) withDrawSetParam {

	return withDrawSetParam{
		data: builder.Field{
			Name:  "depositId",
			Value: value,
		},
	}

}

// Set the optional value of DepositID dynamically
func (r withDrawQueryDepositIDInt) SetIfPresent(value *Int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of DepositID
func (r withDrawQueryDepositIDInt) Increment(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) IncrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of DepositID
func (r withDrawQueryDepositIDInt) Decrement(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) DecrementIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of DepositID
func (r withDrawQueryDepositIDInt) Multiply(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) MultiplyIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of DepositID
func (r withDrawQueryDepositIDInt) Divide(value int) withDrawSetParam {
	return withDrawSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) DivideIfPresent(value *int) withDrawSetParam {
	if value == nil {
		return withDrawSetParam{}
	}
	return r.Divide(*value)
}

func (r withDrawQueryDepositIDInt) Equals(value int) withDrawWithPrismaDepositIDEqualsParam {

	return withDrawWithPrismaDepositIDEqualsParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) EqualsIfPresent(value *int) withDrawWithPrismaDepositIDEqualsParam {
	if value == nil {
		return withDrawWithPrismaDepositIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r withDrawQueryDepositIDInt) Order(direction SortOrder) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name:  "depositId",
			Value: direction,
		},
	}
}

func (r withDrawQueryDepositIDInt) Cursor(cursor int) withDrawCursorParam {
	return withDrawCursorParam{
		data: builder.Field{
			Name:  "depositId",
			Value: cursor,
		},
	}
}

func (r withDrawQueryDepositIDInt) In(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) InIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.In(value)
}

func (r withDrawQueryDepositIDInt) NotIn(value []int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) NotInIfPresent(value []int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.NotIn(value)
}

func (r withDrawQueryDepositIDInt) Lt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) LtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lt(*value)
}

func (r withDrawQueryDepositIDInt) Lte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) LteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Lte(*value)
}

func (r withDrawQueryDepositIDInt) Gt(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) GtIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gt(*value)
}

func (r withDrawQueryDepositIDInt) Gte(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) GteIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Gte(*value)
}

func (r withDrawQueryDepositIDInt) Not(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r withDrawQueryDepositIDInt) NotIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r withDrawQueryDepositIDInt) LT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r withDrawQueryDepositIDInt) LTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r withDrawQueryDepositIDInt) LTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r withDrawQueryDepositIDInt) LTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r withDrawQueryDepositIDInt) GT(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r withDrawQueryDepositIDInt) GTIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r withDrawQueryDepositIDInt) GTE(value int) withDrawDefaultParam {
	return withDrawDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r withDrawQueryDepositIDInt) GTEIfPresent(value *int) withDrawDefaultParam {
	if value == nil {
		return withDrawDefaultParam{}
	}
	return r.GTE(*value)
}

func (r withDrawQueryDepositIDInt) Field() withDrawPrismaFields {
	return withDrawFieldDepositID
}

// DepositTransaction acts as a namespaces to access query methods for the DepositTransaction model
var DepositTransaction = depositTransactionQuery{}

// depositTransactionQuery exposes query functions for the depositTransaction model
type depositTransactionQuery struct {

	// ID
	//
	// @required
	ID depositTransactionQueryIDInt

	// Amount
	//
	// @required
	Amount depositTransactionQueryAmountInt

	Deposit depositTransactionQueryDepositRelations

	// DepositID
	//
	// @required
	DepositID depositTransactionQueryDepositIDInt
}

func (depositTransactionQuery) Not(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositTransactionQuery) Or(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (depositTransactionQuery) And(params ...DepositTransactionWhereParam) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type depositTransactionQueryIDInt struct{}

// Set the required value of ID
func (r depositTransactionQueryIDInt) Set(value int) depositTransactionSetParam {

	return depositTransactionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r depositTransactionQueryIDInt) SetIfPresent(value *Int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of ID
func (r depositTransactionQueryIDInt) Increment(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) IncrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of ID
func (r depositTransactionQueryIDInt) Decrement(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) DecrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of ID
func (r depositTransactionQueryIDInt) Multiply(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) MultiplyIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of ID
func (r depositTransactionQueryIDInt) Divide(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) DivideIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryIDInt) Equals(value int) depositTransactionWithPrismaIDEqualsUniqueParam {

	return depositTransactionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) EqualsIfPresent(value *int) depositTransactionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return depositTransactionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryIDInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryIDInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryIDInt) In(value []int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) InIfPresent(value []int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.In(value)
}

func (r depositTransactionQueryIDInt) NotIn(value []int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) NotInIfPresent(value []int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryIDInt) Lt(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) LtIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryIDInt) Lte(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) LteIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryIDInt) Gt(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) GtIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryIDInt) Gte(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) GteIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryIDInt) Not(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryIDInt) NotIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryIDInt) LT(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryIDInt) LTIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryIDInt) LTE(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryIDInt) LTEIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryIDInt) GT(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryIDInt) GTIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryIDInt) GTE(value int) depositTransactionParamUnique {
	return depositTransactionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryIDInt) GTEIfPresent(value *int) depositTransactionParamUnique {
	if value == nil {
		return depositTransactionParamUnique{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryIDInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldID
}

// base struct
type depositTransactionQueryAmountInt struct{}

// Set the required value of Amount
func (r depositTransactionQueryAmountInt) Set(value int) depositTransactionWithPrismaAmountSetParam {

	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name:  "amount",
			Value: value,
		},
	}

}

// Set the optional value of Amount dynamically
func (r depositTransactionQueryAmountInt) SetIfPresent(value *Int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Amount
func (r depositTransactionQueryAmountInt) Increment(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) IncrementIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Amount
func (r depositTransactionQueryAmountInt) Decrement(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) DecrementIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Amount
func (r depositTransactionQueryAmountInt) Multiply(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) MultiplyIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Amount
func (r depositTransactionQueryAmountInt) Divide(value int) depositTransactionWithPrismaAmountSetParam {
	return depositTransactionWithPrismaAmountSetParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) DivideIfPresent(value *int) depositTransactionWithPrismaAmountSetParam {
	if value == nil {
		return depositTransactionWithPrismaAmountSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryAmountInt) Equals(value int) depositTransactionWithPrismaAmountEqualsParam {

	return depositTransactionWithPrismaAmountEqualsParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) EqualsIfPresent(value *int) depositTransactionWithPrismaAmountEqualsParam {
	if value == nil {
		return depositTransactionWithPrismaAmountEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryAmountInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "amount",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryAmountInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "amount",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryAmountInt) In(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) InIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.In(value)
}

func (r depositTransactionQueryAmountInt) NotIn(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) NotInIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryAmountInt) Lt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) LtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryAmountInt) Lte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) LteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryAmountInt) Gt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) GtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryAmountInt) Gte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) GteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryAmountInt) Not(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryAmountInt) NotIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryAmountInt) LT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryAmountInt) LTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryAmountInt) LTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryAmountInt) LTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryAmountInt) GT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryAmountInt) GTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryAmountInt) GTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "amount",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryAmountInt) GTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryAmountInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldAmount
}

// base struct
type depositTransactionQueryDepositDeposit struct{}

type depositTransactionQueryDepositRelations struct{}

// DepositTransaction -> Deposit
//
// @relation
// @required
func (depositTransactionQueryDepositRelations) Where(
	params ...DepositWhereParam,
) depositTransactionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (depositTransactionQueryDepositRelations) Fetch() depositTransactionToDepositFindUnique {
	var v depositTransactionToDepositFindUnique

	v.query.Operation = "query"
	v.query.Method = "deposit"
	v.query.Outputs = depositOutput

	return v
}

func (r depositTransactionQueryDepositRelations) Link(
	params DepositWhereParam,
) depositTransactionWithPrismaDepositSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return depositTransactionWithPrismaDepositSetParam{}
	}

	fields = append(fields, f)

	return depositTransactionWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositRelations) Unlink() depositTransactionWithPrismaDepositSetParam {
	var v depositTransactionWithPrismaDepositSetParam

	v = depositTransactionWithPrismaDepositSetParam{
		data: builder.Field{
			Name: "deposit",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r depositTransactionQueryDepositDeposit) Field() depositTransactionPrismaFields {
	return depositTransactionFieldDeposit
}

// base struct
type depositTransactionQueryDepositIDInt struct{}

// Set the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Set(value int) depositTransactionSetParam {

	return depositTransactionSetParam{
		data: builder.Field{
			Name:  "depositId",
			Value: value,
		},
	}

}

// Set the optional value of DepositID dynamically
func (r depositTransactionQueryDepositIDInt) SetIfPresent(value *Int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Increment(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) IncrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Decrement(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) DecrementIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Multiply(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) MultiplyIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of DepositID
func (r depositTransactionQueryDepositIDInt) Divide(value int) depositTransactionSetParam {
	return depositTransactionSetParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) DivideIfPresent(value *int) depositTransactionSetParam {
	if value == nil {
		return depositTransactionSetParam{}
	}
	return r.Divide(*value)
}

func (r depositTransactionQueryDepositIDInt) Equals(value int) depositTransactionWithPrismaDepositIDEqualsParam {

	return depositTransactionWithPrismaDepositIDEqualsParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) EqualsIfPresent(value *int) depositTransactionWithPrismaDepositIDEqualsParam {
	if value == nil {
		return depositTransactionWithPrismaDepositIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r depositTransactionQueryDepositIDInt) Order(direction SortOrder) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name:  "depositId",
			Value: direction,
		},
	}
}

func (r depositTransactionQueryDepositIDInt) Cursor(cursor int) depositTransactionCursorParam {
	return depositTransactionCursorParam{
		data: builder.Field{
			Name:  "depositId",
			Value: cursor,
		},
	}
}

func (r depositTransactionQueryDepositIDInt) In(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) InIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.In(value)
}

func (r depositTransactionQueryDepositIDInt) NotIn(value []int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) NotInIfPresent(value []int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.NotIn(value)
}

func (r depositTransactionQueryDepositIDInt) Lt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) LtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lt(*value)
}

func (r depositTransactionQueryDepositIDInt) Lte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) LteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Lte(*value)
}

func (r depositTransactionQueryDepositIDInt) Gt(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) GtIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gt(*value)
}

func (r depositTransactionQueryDepositIDInt) Gte(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) GteIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Gte(*value)
}

func (r depositTransactionQueryDepositIDInt) Not(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r depositTransactionQueryDepositIDInt) NotIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r depositTransactionQueryDepositIDInt) LT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r depositTransactionQueryDepositIDInt) LTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r depositTransactionQueryDepositIDInt) LTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r depositTransactionQueryDepositIDInt) LTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r depositTransactionQueryDepositIDInt) GT(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r depositTransactionQueryDepositIDInt) GTIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r depositTransactionQueryDepositIDInt) GTE(value int) depositTransactionDefaultParam {
	return depositTransactionDefaultParam{
		data: builder.Field{
			Name: "depositId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r depositTransactionQueryDepositIDInt) GTEIfPresent(value *int) depositTransactionDefaultParam {
	if value == nil {
		return depositTransactionDefaultParam{}
	}
	return r.GTE(*value)
}

func (r depositTransactionQueryDepositIDInt) Field() depositTransactionPrismaFields {
	return depositTransactionFieldDepositID
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type transactionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transactionOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "amount"},
	{Name: "toAddress"},
	{Name: "currency"},
}

type TransactionRelationWith interface {
	getQuery() builder.Query
	with()
	transactionRelation()
}

type TransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
}

type transactionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionDefaultParam) field() builder.Field {
	return p.data
}

func (p transactionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transactionDefaultParam) transactionModel() {}

type TransactionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
}

type transactionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionOrderByParam) field() builder.Field {
	return p.data
}

func (p transactionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transactionOrderByParam) transactionModel() {}

type TransactionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	isCursor()
}

type transactionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionCursorParam) field() builder.Field {
	return p.data
}

func (p transactionCursorParam) isCursor() {}

func (p transactionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transactionCursorParam) transactionModel() {}

type TransactionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transactionModel()
}

type transactionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transactionParamUnique) transactionModel() {}

func (transactionParamUnique) unique() {}

func (p transactionParamUnique) field() builder.Field {
	return p.data
}

func (p transactionParamUnique) getQuery() builder.Query {
	return p.query
}

type TransactionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
}

type transactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionEqualsParam) transactionModel() {}

func (transactionEqualsParam) equals() {}

func (p transactionEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransactionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transactionModel()
}

type transactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionEqualsUniqueParam) transactionModel() {}

func (transactionEqualsUniqueParam) unique() {}
func (transactionEqualsUniqueParam) equals() {}

func (p transactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransactionSetParam interface {
	field() builder.Field
	settable()
	transactionModel()
}

type transactionSetParam struct {
	data builder.Field
}

func (transactionSetParam) settable() {}

func (p transactionSetParam) field() builder.Field {
	return p.data
}

func (p transactionSetParam) transactionModel() {}

type TransactionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	idField()
}

type TransactionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	idField()
}

type transactionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDSetParam) transactionModel() {}

func (p transactionWithPrismaIDSetParam) idField() {}

type TransactionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	idField()
}

type transactionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDEqualsParam) transactionModel() {}

func (p transactionWithPrismaIDEqualsParam) idField() {}

func (transactionWithPrismaIDSetParam) settable()  {}
func (transactionWithPrismaIDEqualsParam) equals() {}

type transactionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaIDEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaIDEqualsUniqueParam) idField()          {}

func (transactionWithPrismaIDEqualsUniqueParam) unique() {}
func (transactionWithPrismaIDEqualsUniqueParam) equals() {}

type TransactionWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	userIDField()
}

type TransactionWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userIDField()
}

type transactionWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDSetParam) transactionModel() {}

func (p transactionWithPrismaUserIDSetParam) userIDField() {}

type TransactionWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	userIDField()
}

type transactionWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDEqualsParam) transactionModel() {}

func (p transactionWithPrismaUserIDEqualsParam) userIDField() {}

func (transactionWithPrismaUserIDSetParam) settable()  {}
func (transactionWithPrismaUserIDEqualsParam) equals() {}

type transactionWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaUserIDEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaUserIDEqualsUniqueParam) userIDField()      {}

func (transactionWithPrismaUserIDEqualsUniqueParam) unique() {}
func (transactionWithPrismaUserIDEqualsUniqueParam) equals() {}

type TransactionWithPrismaAmountEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	amountField()
}

type TransactionWithPrismaAmountSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	amountField()
}

type transactionWithPrismaAmountSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaAmountSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaAmountSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaAmountSetParam) transactionModel() {}

func (p transactionWithPrismaAmountSetParam) amountField() {}

type TransactionWithPrismaAmountWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	amountField()
}

type transactionWithPrismaAmountEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaAmountEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaAmountEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaAmountEqualsParam) transactionModel() {}

func (p transactionWithPrismaAmountEqualsParam) amountField() {}

func (transactionWithPrismaAmountSetParam) settable()  {}
func (transactionWithPrismaAmountEqualsParam) equals() {}

type transactionWithPrismaAmountEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaAmountEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaAmountEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaAmountEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaAmountEqualsUniqueParam) amountField()      {}

func (transactionWithPrismaAmountEqualsUniqueParam) unique() {}
func (transactionWithPrismaAmountEqualsUniqueParam) equals() {}

type TransactionWithPrismaToAddressEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	toAddressField()
}

type TransactionWithPrismaToAddressSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	toAddressField()
}

type transactionWithPrismaToAddressSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressSetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressSetParam) transactionModel() {}

func (p transactionWithPrismaToAddressSetParam) toAddressField() {}

type TransactionWithPrismaToAddressWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	toAddressField()
}

type transactionWithPrismaToAddressEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressEqualsParam) transactionModel() {}

func (p transactionWithPrismaToAddressEqualsParam) toAddressField() {}

func (transactionWithPrismaToAddressSetParam) settable()  {}
func (transactionWithPrismaToAddressEqualsParam) equals() {}

type transactionWithPrismaToAddressEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaToAddressEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaToAddressEqualsUniqueParam) toAddressField()   {}

func (transactionWithPrismaToAddressEqualsUniqueParam) unique() {}
func (transactionWithPrismaToAddressEqualsUniqueParam) equals() {}

type TransactionWithPrismaCurrencyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	currencyField()
}

type TransactionWithPrismaCurrencySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	currencyField()
}

type transactionWithPrismaCurrencySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencySetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencySetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencySetParam) transactionModel() {}

func (p transactionWithPrismaCurrencySetParam) currencyField() {}

type TransactionWithPrismaCurrencyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	currencyField()
}

type transactionWithPrismaCurrencyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencyEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencyEqualsParam) transactionModel() {}

func (p transactionWithPrismaCurrencyEqualsParam) currencyField() {}

func (transactionWithPrismaCurrencySetParam) settable()  {}
func (transactionWithPrismaCurrencyEqualsParam) equals() {}

type transactionWithPrismaCurrencyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaCurrencyEqualsUniqueParam) transactionModel() {}
func (p transactionWithPrismaCurrencyEqualsUniqueParam) currencyField()    {}

func (transactionWithPrismaCurrencyEqualsUniqueParam) unique() {}
func (transactionWithPrismaCurrencyEqualsUniqueParam) equals() {}

type TransactionWithPrismaTransactionHistoryEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionModel()
	transactionHistoryField()
}

type TransactionWithPrismaTransactionHistorySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	transactionHistoryField()
}

type transactionWithPrismaTransactionHistorySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistorySetParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistorySetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistorySetParam) transactionModel() {}

func (p transactionWithPrismaTransactionHistorySetParam) transactionHistoryField() {}

type TransactionWithPrismaTransactionHistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionModel()
	transactionHistoryField()
}

type transactionWithPrismaTransactionHistoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistoryEqualsParam) transactionModel() {}

func (p transactionWithPrismaTransactionHistoryEqualsParam) transactionHistoryField() {}

func (transactionWithPrismaTransactionHistorySetParam) settable()  {}
func (transactionWithPrismaTransactionHistoryEqualsParam) equals() {}

type transactionWithPrismaTransactionHistoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) transactionModel()        {}
func (p transactionWithPrismaTransactionHistoryEqualsUniqueParam) transactionHistoryField() {}

func (transactionWithPrismaTransactionHistoryEqualsUniqueParam) unique() {}
func (transactionWithPrismaTransactionHistoryEqualsUniqueParam) equals() {}

type transactionHistoryActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var transactionHistoryOutput = []builder.Output{
	{Name: "id"},
	{Name: "transactionId"},
	{Name: "status"},
}

type TransactionHistoryRelationWith interface {
	getQuery() builder.Query
	with()
	transactionHistoryRelation()
}

type TransactionHistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
}

type transactionHistoryDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryDefaultParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryDefaultParam) transactionHistoryModel() {}

type TransactionHistoryOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
}

type transactionHistoryOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryOrderByParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryOrderByParam) transactionHistoryModel() {}

type TransactionHistoryCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	isCursor()
}

type transactionHistoryCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryCursorParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryCursorParam) isCursor() {}

func (p transactionHistoryCursorParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryCursorParam) transactionHistoryModel() {}

type TransactionHistoryParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	transactionHistoryModel()
}

type transactionHistoryParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryParamUnique) transactionHistoryModel() {}

func (transactionHistoryParamUnique) unique() {}

func (p transactionHistoryParamUnique) field() builder.Field {
	return p.data
}

func (p transactionHistoryParamUnique) getQuery() builder.Query {
	return p.query
}

type TransactionHistoryEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
}

type transactionHistoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryEqualsParam) transactionHistoryModel() {}

func (transactionHistoryEqualsParam) equals() {}

func (p transactionHistoryEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryEqualsParam) getQuery() builder.Query {
	return p.query
}

type TransactionHistoryEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	transactionHistoryModel()
}

type transactionHistoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryEqualsUniqueParam) transactionHistoryModel() {}

func (transactionHistoryEqualsUniqueParam) unique() {}
func (transactionHistoryEqualsUniqueParam) equals() {}

func (p transactionHistoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TransactionHistorySetParam interface {
	field() builder.Field
	settable()
	transactionHistoryModel()
}

type transactionHistorySetParam struct {
	data builder.Field
}

func (transactionHistorySetParam) settable() {}

func (p transactionHistorySetParam) field() builder.Field {
	return p.data
}

func (p transactionHistorySetParam) transactionHistoryModel() {}

type TransactionHistoryWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	idField()
}

type TransactionHistoryWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	idField()
}

type transactionHistoryWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaIDSetParam) idField() {}

type TransactionHistoryWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	idField()
}

type transactionHistoryWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaIDEqualsParam) idField() {}

func (transactionHistoryWithPrismaIDSetParam) settable()  {}
func (transactionHistoryWithPrismaIDEqualsParam) equals() {}

type transactionHistoryWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaIDEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaIDEqualsUniqueParam) idField()                 {}

func (transactionHistoryWithPrismaIDEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaIDEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaTransactionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	transactionField()
}

type TransactionHistoryWithPrismaTransactionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionField()
}

type transactionHistoryWithPrismaTransactionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionSetParam) transactionField() {}

type TransactionHistoryWithPrismaTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionField()
}

type transactionHistoryWithPrismaTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionEqualsParam) transactionField() {}

func (transactionHistoryWithPrismaTransactionSetParam) settable()  {}
func (transactionHistoryWithPrismaTransactionEqualsParam) equals() {}

type transactionHistoryWithPrismaTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaTransactionEqualsUniqueParam) transactionField()        {}

func (transactionHistoryWithPrismaTransactionEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaTransactionEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaTransactionIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	transactionIDField()
}

type TransactionHistoryWithPrismaTransactionIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionIDField()
}

type transactionHistoryWithPrismaTransactionIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionIDSetParam) transactionIDField() {}

type TransactionHistoryWithPrismaTransactionIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	transactionIDField()
}

type transactionHistoryWithPrismaTransactionIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaTransactionIDEqualsParam) transactionIDField() {}

func (transactionHistoryWithPrismaTransactionIDSetParam) settable()  {}
func (transactionHistoryWithPrismaTransactionIDEqualsParam) equals() {}

type transactionHistoryWithPrismaTransactionIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) transactionIDField()      {}

func (transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaTransactionIDEqualsUniqueParam) equals() {}

type TransactionHistoryWithPrismaStatusEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	transactionHistoryModel()
	statusField()
}

type TransactionHistoryWithPrismaStatusSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	statusField()
}

type transactionHistoryWithPrismaStatusSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusSetParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusSetParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusSetParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaStatusSetParam) statusField() {}

type TransactionHistoryWithPrismaStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	transactionHistoryModel()
	statusField()
}

type transactionHistoryWithPrismaStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusEqualsParam) transactionHistoryModel() {}

func (p transactionHistoryWithPrismaStatusEqualsParam) statusField() {}

func (transactionHistoryWithPrismaStatusSetParam) settable()  {}
func (transactionHistoryWithPrismaStatusEqualsParam) equals() {}

type transactionHistoryWithPrismaStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) transactionHistoryModel() {}
func (p transactionHistoryWithPrismaStatusEqualsUniqueParam) statusField()             {}

func (transactionHistoryWithPrismaStatusEqualsUniqueParam) unique() {}
func (transactionHistoryWithPrismaStatusEqualsUniqueParam) equals() {}

type depositActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var depositOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "amount"},
}

type DepositRelationWith interface {
	getQuery() builder.Query
	with()
	depositRelation()
}

type DepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
}

type depositDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositDefaultParam) field() builder.Field {
	return p.data
}

func (p depositDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p depositDefaultParam) depositModel() {}

type DepositOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
}

type depositOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositOrderByParam) field() builder.Field {
	return p.data
}

func (p depositOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p depositOrderByParam) depositModel() {}

type DepositCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	isCursor()
}

type depositCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositCursorParam) field() builder.Field {
	return p.data
}

func (p depositCursorParam) isCursor() {}

func (p depositCursorParam) getQuery() builder.Query {
	return p.query
}

func (p depositCursorParam) depositModel() {}

type DepositParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	depositModel()
}

type depositParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p depositParamUnique) depositModel() {}

func (depositParamUnique) unique() {}

func (p depositParamUnique) field() builder.Field {
	return p.data
}

func (p depositParamUnique) getQuery() builder.Query {
	return p.query
}

type DepositEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
}

type depositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositEqualsParam) depositModel() {}

func (depositEqualsParam) equals() {}

func (p depositEqualsParam) field() builder.Field {
	return p.data
}

func (p depositEqualsParam) getQuery() builder.Query {
	return p.query
}

type DepositEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	depositModel()
}

type depositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositEqualsUniqueParam) depositModel() {}

func (depositEqualsUniqueParam) unique() {}
func (depositEqualsUniqueParam) equals() {}

func (p depositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DepositSetParam interface {
	field() builder.Field
	settable()
	depositModel()
}

type depositSetParam struct {
	data builder.Field
}

func (depositSetParam) settable() {}

func (p depositSetParam) field() builder.Field {
	return p.data
}

func (p depositSetParam) depositModel() {}

type DepositWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	idField()
}

type DepositWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	idField()
}

type depositWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDSetParam) depositModel() {}

func (p depositWithPrismaIDSetParam) idField() {}

type DepositWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	idField()
}

type depositWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDEqualsParam) depositModel() {}

func (p depositWithPrismaIDEqualsParam) idField() {}

func (depositWithPrismaIDSetParam) settable()  {}
func (depositWithPrismaIDEqualsParam) equals() {}

type depositWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaIDEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaIDEqualsUniqueParam) idField()      {}

func (depositWithPrismaIDEqualsUniqueParam) unique() {}
func (depositWithPrismaIDEqualsUniqueParam) equals() {}

type DepositWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	userIDField()
}

type DepositWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userIDField()
}

type depositWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDSetParam) depositModel() {}

func (p depositWithPrismaUserIDSetParam) userIDField() {}

type DepositWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	userIDField()
}

type depositWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDEqualsParam) depositModel() {}

func (p depositWithPrismaUserIDEqualsParam) userIDField() {}

func (depositWithPrismaUserIDSetParam) settable()  {}
func (depositWithPrismaUserIDEqualsParam) equals() {}

type depositWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaUserIDEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (depositWithPrismaUserIDEqualsUniqueParam) unique() {}
func (depositWithPrismaUserIDEqualsUniqueParam) equals() {}

type DepositWithPrismaAmountEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	amountField()
}

type DepositWithPrismaAmountSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	amountField()
}

type depositWithPrismaAmountSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountSetParam) depositModel() {}

func (p depositWithPrismaAmountSetParam) amountField() {}

type DepositWithPrismaAmountWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	amountField()
}

type depositWithPrismaAmountEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountEqualsParam) depositModel() {}

func (p depositWithPrismaAmountEqualsParam) amountField() {}

func (depositWithPrismaAmountSetParam) settable()  {}
func (depositWithPrismaAmountEqualsParam) equals() {}

type depositWithPrismaAmountEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaAmountEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaAmountEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaAmountEqualsUniqueParam) depositModel() {}
func (p depositWithPrismaAmountEqualsUniqueParam) amountField()  {}

func (depositWithPrismaAmountEqualsUniqueParam) unique() {}
func (depositWithPrismaAmountEqualsUniqueParam) equals() {}

type DepositWithPrismaWithDrawEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	withDrawField()
}

type DepositWithPrismaWithDrawSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	withDrawField()
}

type depositWithPrismaWithDrawSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawSetParam) depositModel() {}

func (p depositWithPrismaWithDrawSetParam) withDrawField() {}

type DepositWithPrismaWithDrawWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	withDrawField()
}

type depositWithPrismaWithDrawEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawEqualsParam) depositModel() {}

func (p depositWithPrismaWithDrawEqualsParam) withDrawField() {}

func (depositWithPrismaWithDrawSetParam) settable()  {}
func (depositWithPrismaWithDrawEqualsParam) equals() {}

type depositWithPrismaWithDrawEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaWithDrawEqualsUniqueParam) depositModel()  {}
func (p depositWithPrismaWithDrawEqualsUniqueParam) withDrawField() {}

func (depositWithPrismaWithDrawEqualsUniqueParam) unique() {}
func (depositWithPrismaWithDrawEqualsUniqueParam) equals() {}

type DepositWithPrismaDepositTransactionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositModel()
	depositTransactionField()
}

type DepositWithPrismaDepositTransactionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	depositTransactionField()
}

type depositWithPrismaDepositTransactionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionSetParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionSetParam) depositModel() {}

func (p depositWithPrismaDepositTransactionSetParam) depositTransactionField() {}

type DepositWithPrismaDepositTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositModel()
	depositTransactionField()
}

type depositWithPrismaDepositTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionEqualsParam) depositModel() {}

func (p depositWithPrismaDepositTransactionEqualsParam) depositTransactionField() {}

func (depositWithPrismaDepositTransactionSetParam) settable()  {}
func (depositWithPrismaDepositTransactionEqualsParam) equals() {}

type depositWithPrismaDepositTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositWithPrismaDepositTransactionEqualsUniqueParam) depositModel()            {}
func (p depositWithPrismaDepositTransactionEqualsUniqueParam) depositTransactionField() {}

func (depositWithPrismaDepositTransactionEqualsUniqueParam) unique() {}
func (depositWithPrismaDepositTransactionEqualsUniqueParam) equals() {}

type withDrawActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var withDrawOutput = []builder.Output{
	{Name: "id"},
	{Name: "charge"},
	{Name: "userId"},
	{Name: "depositId"},
}

type WithDrawRelationWith interface {
	getQuery() builder.Query
	with()
	withDrawRelation()
}

type WithDrawWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
}

type withDrawDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawDefaultParam) field() builder.Field {
	return p.data
}

func (p withDrawDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawDefaultParam) withDrawModel() {}

type WithDrawOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
}

type withDrawOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawOrderByParam) field() builder.Field {
	return p.data
}

func (p withDrawOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawOrderByParam) withDrawModel() {}

type WithDrawCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	isCursor()
}

type withDrawCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawCursorParam) field() builder.Field {
	return p.data
}

func (p withDrawCursorParam) isCursor() {}

func (p withDrawCursorParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawCursorParam) withDrawModel() {}

type WithDrawParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	withDrawModel()
}

type withDrawParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawParamUnique) withDrawModel() {}

func (withDrawParamUnique) unique() {}

func (p withDrawParamUnique) field() builder.Field {
	return p.data
}

func (p withDrawParamUnique) getQuery() builder.Query {
	return p.query
}

type WithDrawEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
}

type withDrawEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawEqualsParam) withDrawModel() {}

func (withDrawEqualsParam) equals() {}

func (p withDrawEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawEqualsParam) getQuery() builder.Query {
	return p.query
}

type WithDrawEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	withDrawModel()
}

type withDrawEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawEqualsUniqueParam) withDrawModel() {}

func (withDrawEqualsUniqueParam) unique() {}
func (withDrawEqualsUniqueParam) equals() {}

func (p withDrawEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type WithDrawSetParam interface {
	field() builder.Field
	settable()
	withDrawModel()
}

type withDrawSetParam struct {
	data builder.Field
}

func (withDrawSetParam) settable() {}

func (p withDrawSetParam) field() builder.Field {
	return p.data
}

func (p withDrawSetParam) withDrawModel() {}

type WithDrawWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	idField()
}

type WithDrawWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	idField()
}

type withDrawWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaIDSetParam) idField() {}

type WithDrawWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	idField()
}

type withDrawWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaIDEqualsParam) idField() {}

func (withDrawWithPrismaIDSetParam) settable()  {}
func (withDrawWithPrismaIDEqualsParam) equals() {}

type withDrawWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaIDEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaIDEqualsUniqueParam) idField()       {}

func (withDrawWithPrismaIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaIDEqualsUniqueParam) equals() {}

type WithDrawWithPrismaChargeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	chargeField()
}

type WithDrawWithPrismaChargeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	chargeField()
}

type withDrawWithPrismaChargeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeSetParam) withDrawModel() {}

func (p withDrawWithPrismaChargeSetParam) chargeField() {}

type WithDrawWithPrismaChargeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	chargeField()
}

type withDrawWithPrismaChargeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaChargeEqualsParam) chargeField() {}

func (withDrawWithPrismaChargeSetParam) settable()  {}
func (withDrawWithPrismaChargeEqualsParam) equals() {}

type withDrawWithPrismaChargeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaChargeEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaChargeEqualsUniqueParam) chargeField()   {}

func (withDrawWithPrismaChargeEqualsUniqueParam) unique() {}
func (withDrawWithPrismaChargeEqualsUniqueParam) equals() {}

type WithDrawWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	userIDField()
}

type WithDrawWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userIDField()
}

type withDrawWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaUserIDSetParam) userIDField() {}

type WithDrawWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	userIDField()
}

type withDrawWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaUserIDEqualsParam) userIDField() {}

func (withDrawWithPrismaUserIDSetParam) settable()  {}
func (withDrawWithPrismaUserIDEqualsParam) equals() {}

type withDrawWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaUserIDEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaUserIDEqualsUniqueParam) userIDField()   {}

func (withDrawWithPrismaUserIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaUserIDEqualsUniqueParam) equals() {}

type WithDrawWithPrismaDepositEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	depositField()
}

type WithDrawWithPrismaDepositSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositField()
}

type withDrawWithPrismaDepositSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositSetParam) withDrawModel() {}

func (p withDrawWithPrismaDepositSetParam) depositField() {}

type WithDrawWithPrismaDepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositField()
}

type withDrawWithPrismaDepositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaDepositEqualsParam) depositField() {}

func (withDrawWithPrismaDepositSetParam) settable()  {}
func (withDrawWithPrismaDepositEqualsParam) equals() {}

type withDrawWithPrismaDepositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositEqualsUniqueParam) withDrawModel() {}
func (p withDrawWithPrismaDepositEqualsUniqueParam) depositField()  {}

func (withDrawWithPrismaDepositEqualsUniqueParam) unique() {}
func (withDrawWithPrismaDepositEqualsUniqueParam) equals() {}

type WithDrawWithPrismaDepositIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	withDrawModel()
	depositIDField()
}

type WithDrawWithPrismaDepositIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositIDField()
}

type withDrawWithPrismaDepositIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDSetParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDSetParam) withDrawModel() {}

func (p withDrawWithPrismaDepositIDSetParam) depositIDField() {}

type WithDrawWithPrismaDepositIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	withDrawModel()
	depositIDField()
}

type withDrawWithPrismaDepositIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDEqualsParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDEqualsParam) withDrawModel() {}

func (p withDrawWithPrismaDepositIDEqualsParam) depositIDField() {}

func (withDrawWithPrismaDepositIDSetParam) settable()  {}
func (withDrawWithPrismaDepositIDEqualsParam) equals() {}

type withDrawWithPrismaDepositIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p withDrawWithPrismaDepositIDEqualsUniqueParam) withDrawModel()  {}
func (p withDrawWithPrismaDepositIDEqualsUniqueParam) depositIDField() {}

func (withDrawWithPrismaDepositIDEqualsUniqueParam) unique() {}
func (withDrawWithPrismaDepositIDEqualsUniqueParam) equals() {}

type depositTransactionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var depositTransactionOutput = []builder.Output{
	{Name: "id"},
	{Name: "amount"},
	{Name: "depositId"},
}

type DepositTransactionRelationWith interface {
	getQuery() builder.Query
	with()
	depositTransactionRelation()
}

type DepositTransactionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
}

type depositTransactionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionDefaultParam) field() builder.Field {
	return p.data
}

func (p depositTransactionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionDefaultParam) depositTransactionModel() {}

type DepositTransactionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
}

type depositTransactionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionOrderByParam) field() builder.Field {
	return p.data
}

func (p depositTransactionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionOrderByParam) depositTransactionModel() {}

type DepositTransactionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	isCursor()
}

type depositTransactionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionCursorParam) field() builder.Field {
	return p.data
}

func (p depositTransactionCursorParam) isCursor() {}

func (p depositTransactionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionCursorParam) depositTransactionModel() {}

type DepositTransactionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	depositTransactionModel()
}

type depositTransactionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionParamUnique) depositTransactionModel() {}

func (depositTransactionParamUnique) unique() {}

func (p depositTransactionParamUnique) field() builder.Field {
	return p.data
}

func (p depositTransactionParamUnique) getQuery() builder.Query {
	return p.query
}

type DepositTransactionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
}

type depositTransactionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionEqualsParam) depositTransactionModel() {}

func (depositTransactionEqualsParam) equals() {}

func (p depositTransactionEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionEqualsParam) getQuery() builder.Query {
	return p.query
}

type DepositTransactionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	depositTransactionModel()
}

type depositTransactionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionEqualsUniqueParam) depositTransactionModel() {}

func (depositTransactionEqualsUniqueParam) unique() {}
func (depositTransactionEqualsUniqueParam) equals() {}

func (p depositTransactionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DepositTransactionSetParam interface {
	field() builder.Field
	settable()
	depositTransactionModel()
}

type depositTransactionSetParam struct {
	data builder.Field
}

func (depositTransactionSetParam) settable() {}

func (p depositTransactionSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionSetParam) depositTransactionModel() {}

type DepositTransactionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	idField()
}

type DepositTransactionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	idField()
}

type depositTransactionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaIDSetParam) idField() {}

type DepositTransactionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	idField()
}

type depositTransactionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaIDEqualsParam) idField() {}

func (depositTransactionWithPrismaIDSetParam) settable()  {}
func (depositTransactionWithPrismaIDEqualsParam) equals() {}

type depositTransactionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaIDEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaIDEqualsUniqueParam) idField()                 {}

func (depositTransactionWithPrismaIDEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaIDEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaAmountEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	amountField()
}

type DepositTransactionWithPrismaAmountSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	amountField()
}

type depositTransactionWithPrismaAmountSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaAmountSetParam) amountField() {}

type DepositTransactionWithPrismaAmountWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	amountField()
}

type depositTransactionWithPrismaAmountEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaAmountEqualsParam) amountField() {}

func (depositTransactionWithPrismaAmountSetParam) settable()  {}
func (depositTransactionWithPrismaAmountEqualsParam) equals() {}

type depositTransactionWithPrismaAmountEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaAmountEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaAmountEqualsUniqueParam) amountField()             {}

func (depositTransactionWithPrismaAmountEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaAmountEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaDepositEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	depositField()
}

type DepositTransactionWithPrismaDepositSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositField()
}

type depositTransactionWithPrismaDepositSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositSetParam) depositField() {}

type DepositTransactionWithPrismaDepositWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositField()
}

type depositTransactionWithPrismaDepositEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositEqualsParam) depositField() {}

func (depositTransactionWithPrismaDepositSetParam) settable()  {}
func (depositTransactionWithPrismaDepositEqualsParam) equals() {}

type depositTransactionWithPrismaDepositEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaDepositEqualsUniqueParam) depositField()            {}

func (depositTransactionWithPrismaDepositEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaDepositEqualsUniqueParam) equals() {}

type DepositTransactionWithPrismaDepositIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	depositTransactionModel()
	depositIDField()
}

type DepositTransactionWithPrismaDepositIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositIDField()
}

type depositTransactionWithPrismaDepositIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDSetParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDSetParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositIDSetParam) depositIDField() {}

type DepositTransactionWithPrismaDepositIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	depositTransactionModel()
	depositIDField()
}

type depositTransactionWithPrismaDepositIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDEqualsParam) depositTransactionModel() {}

func (p depositTransactionWithPrismaDepositIDEqualsParam) depositIDField() {}

func (depositTransactionWithPrismaDepositIDSetParam) settable()  {}
func (depositTransactionWithPrismaDepositIDEqualsParam) equals() {}

type depositTransactionWithPrismaDepositIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) depositTransactionModel() {}
func (p depositTransactionWithPrismaDepositIDEqualsUniqueParam) depositIDField()          {}

func (depositTransactionWithPrismaDepositIDEqualsUniqueParam) unique() {}
func (depositTransactionWithPrismaDepositIDEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single transaction.
func (r transactionActions) CreateOne(
	_userID TransactionWithPrismaUserIDSetParam,
	_amount TransactionWithPrismaAmountSetParam,
	_toAddress TransactionWithPrismaToAddressSetParam,
	_currency TransactionWithPrismaCurrencySetParam,

	optional ...TransactionSetParam,
) transactionCreateOne {
	var v transactionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var fields []builder.Field

	fields = append(fields, _userID.field())
	fields = append(fields, _amount.field())
	fields = append(fields, _toAddress.field())
	fields = append(fields, _currency.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transactionCreateOne) With(params ...TransactionRelationWith) transactionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transactionCreateOne struct {
	query builder.Query
}

func (p transactionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transactionCreateOne) transactionModel() {}

func (r transactionCreateOne) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionCreateOne) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single transactionHistory.
func (r transactionHistoryActions) CreateOne(
	_transaction TransactionHistoryWithPrismaTransactionSetParam,
	_status TransactionHistoryWithPrismaStatusSetParam,

	optional ...TransactionHistorySetParam,
) transactionHistoryCreateOne {
	var v transactionHistoryCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var fields []builder.Field

	fields = append(fields, _transaction.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r transactionHistoryCreateOne) With(params ...TransactionHistoryRelationWith) transactionHistoryCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type transactionHistoryCreateOne struct {
	query builder.Query
}

func (p transactionHistoryCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p transactionHistoryCreateOne) transactionHistoryModel() {}

func (r transactionHistoryCreateOne) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryCreateOne) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single deposit.
func (r depositActions) CreateOne(
	_userID DepositWithPrismaUserIDSetParam,
	_amount DepositWithPrismaAmountSetParam,

	optional ...DepositSetParam,
) depositCreateOne {
	var v depositCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var fields []builder.Field

	fields = append(fields, _userID.field())
	fields = append(fields, _amount.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r depositCreateOne) With(params ...DepositRelationWith) depositCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type depositCreateOne struct {
	query builder.Query
}

func (p depositCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p depositCreateOne) depositModel() {}

func (r depositCreateOne) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositCreateOne) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single withDraw.
func (r withDrawActions) CreateOne(
	_charge WithDrawWithPrismaChargeSetParam,
	_userID WithDrawWithPrismaUserIDSetParam,
	_deposit WithDrawWithPrismaDepositSetParam,

	optional ...WithDrawSetParam,
) withDrawCreateOne {
	var v withDrawCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var fields []builder.Field

	fields = append(fields, _charge.field())
	fields = append(fields, _userID.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r withDrawCreateOne) With(params ...WithDrawRelationWith) withDrawCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type withDrawCreateOne struct {
	query builder.Query
}

func (p withDrawCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p withDrawCreateOne) withDrawModel() {}

func (r withDrawCreateOne) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawCreateOne) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single depositTransaction.
func (r depositTransactionActions) CreateOne(
	_amount DepositTransactionWithPrismaAmountSetParam,
	_deposit DepositTransactionWithPrismaDepositSetParam,

	optional ...DepositTransactionSetParam,
) depositTransactionCreateOne {
	var v depositTransactionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var fields []builder.Field

	fields = append(fields, _amount.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r depositTransactionCreateOne) With(params ...DepositTransactionRelationWith) depositTransactionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type depositTransactionCreateOne struct {
	query builder.Query
}

func (p depositTransactionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p depositTransactionCreateOne) depositTransactionModel() {}

func (r depositTransactionCreateOne) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionCreateOne) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type transactionToTransactionHistoryFindUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindUnique) with()                {}
func (r transactionToTransactionHistoryFindUnique) transactionModel()    {}
func (r transactionToTransactionHistoryFindUnique) transactionRelation() {}

func (r transactionToTransactionHistoryFindUnique) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindUnique) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindUnique) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindUnique) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindUnique) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindUnique) Update(params ...TransactionSetParam) transactionToTransactionHistoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transaction"

	var v transactionToTransactionHistoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToTransactionHistoryUpdateUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryUpdateUnique) transactionModel() {}

func (r transactionToTransactionHistoryUpdateUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryUpdateUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToTransactionHistoryFindUnique) Delete() transactionToTransactionHistoryDeleteUnique {
	var v transactionToTransactionHistoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transaction"

	return v
}

type transactionToTransactionHistoryDeleteUnique struct {
	query builder.Query
}

func (r transactionToTransactionHistoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToTransactionHistoryDeleteUnique) transactionModel() {}

func (r transactionToTransactionHistoryDeleteUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryDeleteUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionToTransactionHistoryFindFirst struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindFirst) with()                {}
func (r transactionToTransactionHistoryFindFirst) transactionModel()    {}
func (r transactionToTransactionHistoryFindFirst) transactionRelation() {}

func (r transactionToTransactionHistoryFindFirst) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindFirst) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindFirst) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindFirst) OrderBy(params ...TransactionHistoryOrderByParam) transactionToTransactionHistoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToTransactionHistoryFindFirst) Skip(count int) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Take(count int) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Cursor(cursor TransactionCursorParam) transactionToTransactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToTransactionHistoryFindFirst) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindFirst) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionToTransactionHistoryFindMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryFindMany) with()                {}
func (r transactionToTransactionHistoryFindMany) transactionModel()    {}
func (r transactionToTransactionHistoryFindMany) transactionRelation() {}

func (r transactionToTransactionHistoryFindMany) With(params ...TransactionHistoryRelationWith) transactionToTransactionHistoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionToTransactionHistoryFindMany) Select(params ...transactionPrismaFields) transactionToTransactionHistoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindMany) Omit(params ...transactionPrismaFields) transactionToTransactionHistoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionToTransactionHistoryFindMany) OrderBy(params ...TransactionHistoryOrderByParam) transactionToTransactionHistoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionToTransactionHistoryFindMany) Skip(count int) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Take(count int) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Cursor(cursor TransactionCursorParam) transactionToTransactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionToTransactionHistoryFindMany) Exec(ctx context.Context) (
	[]TransactionModel,
	error,
) {
	var v []TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindMany) ExecInner(ctx context.Context) (
	[]InnerTransaction,
	error,
) {
	var v []InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionToTransactionHistoryFindMany) Update(params ...TransactionSetParam) transactionToTransactionHistoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transaction"

	r.query.Outputs = countOutput

	var v transactionToTransactionHistoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionToTransactionHistoryUpdateMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionToTransactionHistoryUpdateMany) transactionModel() {}

func (r transactionToTransactionHistoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryUpdateMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionToTransactionHistoryFindMany) Delete() transactionToTransactionHistoryDeleteMany {
	var v transactionToTransactionHistoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transaction"

	v.query.Outputs = countOutput

	return v
}

type transactionToTransactionHistoryDeleteMany struct {
	query builder.Query
}

func (r transactionToTransactionHistoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionToTransactionHistoryDeleteMany) transactionModel() {}

func (r transactionToTransactionHistoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionToTransactionHistoryDeleteMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionFindUnique struct {
	query builder.Query
}

func (r transactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindUnique) with()                {}
func (r transactionFindUnique) transactionModel()    {}
func (r transactionFindUnique) transactionRelation() {}

func (r transactionActions) FindUnique(
	params TransactionEqualsUniqueWhereParam,
) transactionFindUnique {
	var v transactionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionFindUnique) With(params ...TransactionRelationWith) transactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindUnique) Select(params ...transactionPrismaFields) transactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindUnique) Omit(params ...transactionPrismaFields) transactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindUnique) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindUnique) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindUnique) Update(params ...TransactionSetParam) transactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Transaction"

	var v transactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionUpdateUnique struct {
	query builder.Query
}

func (r transactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpdateUnique) transactionModel() {}

func (r transactionUpdateUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpdateUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionFindUnique) Delete() transactionDeleteUnique {
	var v transactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Transaction"

	return v
}

type transactionDeleteUnique struct {
	query builder.Query
}

func (r transactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionDeleteUnique) transactionModel() {}

func (r transactionDeleteUnique) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionDeleteUnique) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionFindFirst struct {
	query builder.Query
}

func (r transactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindFirst) with()                {}
func (r transactionFindFirst) transactionModel()    {}
func (r transactionFindFirst) transactionRelation() {}

func (r transactionActions) FindFirst(
	params ...TransactionWhereParam,
) transactionFindFirst {
	var v transactionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionFindFirst) With(params ...TransactionRelationWith) transactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindFirst) Select(params ...transactionPrismaFields) transactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindFirst) Omit(params ...transactionPrismaFields) transactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindFirst) OrderBy(params ...TransactionOrderByParam) transactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionFindFirst) Skip(count int) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionFindFirst) Take(count int) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionFindFirst) Cursor(cursor TransactionCursorParam) transactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionFindFirst) Exec(ctx context.Context) (
	*TransactionModel,
	error,
) {
	var v *TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionFindFirst) ExecInner(ctx context.Context) (
	*InnerTransaction,
	error,
) {
	var v *InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionFindMany struct {
	query builder.Query
}

func (r transactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionFindMany) with()                {}
func (r transactionFindMany) transactionModel()    {}
func (r transactionFindMany) transactionRelation() {}

func (r transactionActions) FindMany(
	params ...TransactionWhereParam,
) transactionFindMany {
	var v transactionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionFindMany) With(params ...TransactionRelationWith) transactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionFindMany) Select(params ...transactionPrismaFields) transactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindMany) Omit(params ...transactionPrismaFields) transactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionFindMany) OrderBy(params ...TransactionOrderByParam) transactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionFindMany) Skip(count int) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionFindMany) Take(count int) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionFindMany) Cursor(cursor TransactionCursorParam) transactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionFindMany) Exec(ctx context.Context) (
	[]TransactionModel,
	error,
) {
	var v []TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionFindMany) ExecInner(ctx context.Context) (
	[]InnerTransaction,
	error,
) {
	var v []InnerTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionFindMany) Update(params ...TransactionSetParam) transactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Transaction"

	r.query.Outputs = countOutput

	var v transactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionUpdateMany struct {
	query builder.Query
}

func (r transactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpdateMany) transactionModel() {}

func (r transactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpdateMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionFindMany) Delete() transactionDeleteMany {
	var v transactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Transaction"

	v.query.Outputs = countOutput

	return v
}

type transactionDeleteMany struct {
	query builder.Query
}

func (r transactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionDeleteMany) transactionModel() {}

func (r transactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionDeleteMany) Tx() TransactionManyTxResult {
	v := newTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryToTransactionFindUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindUnique) with()                       {}
func (r transactionHistoryToTransactionFindUnique) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindUnique) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindUnique) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindUnique) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindUnique) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindUnique) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindUnique) Update(params ...TransactionHistorySetParam) transactionHistoryToTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransactionHistory"

	var v transactionHistoryToTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryToTransactionUpdateUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionUpdateUnique) transactionHistoryModel() {}

func (r transactionHistoryToTransactionUpdateUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionUpdateUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryToTransactionFindUnique) Delete() transactionHistoryToTransactionDeleteUnique {
	var v transactionHistoryToTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransactionHistory"

	return v
}

type transactionHistoryToTransactionDeleteUnique struct {
	query builder.Query
}

func (r transactionHistoryToTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryToTransactionDeleteUnique) transactionHistoryModel() {}

func (r transactionHistoryToTransactionDeleteUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionDeleteUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryToTransactionFindFirst struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindFirst) with()                       {}
func (r transactionHistoryToTransactionFindFirst) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindFirst) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindFirst) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindFirst) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindFirst) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindFirst) OrderBy(params ...TransactionOrderByParam) transactionHistoryToTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryToTransactionFindFirst) Skip(count int) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Take(count int) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryToTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryToTransactionFindFirst) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionHistoryToTransactionFindMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionFindMany) with()                       {}
func (r transactionHistoryToTransactionFindMany) transactionHistoryModel()    {}
func (r transactionHistoryToTransactionFindMany) transactionHistoryRelation() {}

func (r transactionHistoryToTransactionFindMany) With(params ...TransactionRelationWith) transactionHistoryToTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryToTransactionFindMany) Select(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindMany) Omit(params ...transactionHistoryPrismaFields) transactionHistoryToTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryToTransactionFindMany) OrderBy(params ...TransactionOrderByParam) transactionHistoryToTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryToTransactionFindMany) Skip(count int) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Take(count int) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryToTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryToTransactionFindMany) Exec(ctx context.Context) (
	[]TransactionHistoryModel,
	error,
) {
	var v []TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerTransactionHistory,
	error,
) {
	var v []InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryToTransactionFindMany) Update(params ...TransactionHistorySetParam) transactionHistoryToTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransactionHistory"

	r.query.Outputs = countOutput

	var v transactionHistoryToTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryToTransactionUpdateMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryToTransactionUpdateMany) transactionHistoryModel() {}

func (r transactionHistoryToTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionUpdateMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryToTransactionFindMany) Delete() transactionHistoryToTransactionDeleteMany {
	var v transactionHistoryToTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransactionHistory"

	v.query.Outputs = countOutput

	return v
}

type transactionHistoryToTransactionDeleteMany struct {
	query builder.Query
}

func (r transactionHistoryToTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryToTransactionDeleteMany) transactionHistoryModel() {}

func (r transactionHistoryToTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryToTransactionDeleteMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryFindUnique struct {
	query builder.Query
}

func (r transactionHistoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindUnique) with()                       {}
func (r transactionHistoryFindUnique) transactionHistoryModel()    {}
func (r transactionHistoryFindUnique) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindUnique(
	params TransactionHistoryEqualsUniqueWhereParam,
) transactionHistoryFindUnique {
	var v transactionHistoryFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionHistoryFindUnique) With(params ...TransactionHistoryRelationWith) transactionHistoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindUnique) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindUnique) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindUnique) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindUnique) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindUnique) Update(params ...TransactionHistorySetParam) transactionHistoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TransactionHistory"

	var v transactionHistoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryUpdateUnique struct {
	query builder.Query
}

func (r transactionHistoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpdateUnique) transactionHistoryModel() {}

func (r transactionHistoryUpdateUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpdateUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryFindUnique) Delete() transactionHistoryDeleteUnique {
	var v transactionHistoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TransactionHistory"

	return v
}

type transactionHistoryDeleteUnique struct {
	query builder.Query
}

func (r transactionHistoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryDeleteUnique) transactionHistoryModel() {}

func (r transactionHistoryDeleteUnique) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryDeleteUnique) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryFindFirst struct {
	query builder.Query
}

func (r transactionHistoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindFirst) with()                       {}
func (r transactionHistoryFindFirst) transactionHistoryModel()    {}
func (r transactionHistoryFindFirst) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindFirst(
	params ...TransactionHistoryWhereParam,
) transactionHistoryFindFirst {
	var v transactionHistoryFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionHistoryFindFirst) With(params ...TransactionHistoryRelationWith) transactionHistoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindFirst) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindFirst) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindFirst) OrderBy(params ...TransactionHistoryOrderByParam) transactionHistoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryFindFirst) Skip(count int) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindFirst) Take(count int) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindFirst) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryFindFirst) Exec(ctx context.Context) (
	*TransactionHistoryModel,
	error,
) {
	var v *TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r transactionHistoryFindFirst) ExecInner(ctx context.Context) (
	*InnerTransactionHistory,
	error,
) {
	var v *InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type transactionHistoryFindMany struct {
	query builder.Query
}

func (r transactionHistoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryFindMany) with()                       {}
func (r transactionHistoryFindMany) transactionHistoryModel()    {}
func (r transactionHistoryFindMany) transactionHistoryRelation() {}

func (r transactionHistoryActions) FindMany(
	params ...TransactionHistoryWhereParam,
) transactionHistoryFindMany {
	var v transactionHistoryFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r transactionHistoryFindMany) With(params ...TransactionHistoryRelationWith) transactionHistoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r transactionHistoryFindMany) Select(params ...transactionHistoryPrismaFields) transactionHistoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindMany) Omit(params ...transactionHistoryPrismaFields) transactionHistoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range transactionHistoryOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r transactionHistoryFindMany) OrderBy(params ...TransactionHistoryOrderByParam) transactionHistoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r transactionHistoryFindMany) Skip(count int) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindMany) Take(count int) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r transactionHistoryFindMany) Cursor(cursor TransactionHistoryCursorParam) transactionHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r transactionHistoryFindMany) Exec(ctx context.Context) (
	[]TransactionHistoryModel,
	error,
) {
	var v []TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryFindMany) ExecInner(ctx context.Context) (
	[]InnerTransactionHistory,
	error,
) {
	var v []InnerTransactionHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r transactionHistoryFindMany) Update(params ...TransactionHistorySetParam) transactionHistoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TransactionHistory"

	r.query.Outputs = countOutput

	var v transactionHistoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type transactionHistoryUpdateMany struct {
	query builder.Query
}

func (r transactionHistoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpdateMany) transactionHistoryModel() {}

func (r transactionHistoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpdateMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r transactionHistoryFindMany) Delete() transactionHistoryDeleteMany {
	var v transactionHistoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TransactionHistory"

	v.query.Outputs = countOutput

	return v
}

type transactionHistoryDeleteMany struct {
	query builder.Query
}

func (r transactionHistoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p transactionHistoryDeleteMany) transactionHistoryModel() {}

func (r transactionHistoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryDeleteMany) Tx() TransactionHistoryManyTxResult {
	v := newTransactionHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToWithDrawFindUnique struct {
	query builder.Query
}

func (r depositToWithDrawFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindUnique) with()            {}
func (r depositToWithDrawFindUnique) depositModel()    {}
func (r depositToWithDrawFindUnique) depositRelation() {}

func (r depositToWithDrawFindUnique) With(params ...WithDrawRelationWith) depositToWithDrawFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindUnique) Select(params ...depositPrismaFields) depositToWithDrawFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindUnique) Omit(params ...depositPrismaFields) depositToWithDrawFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindUnique) Update(params ...DepositSetParam) depositToWithDrawUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositToWithDrawUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToWithDrawUpdateUnique struct {
	query builder.Query
}

func (r depositToWithDrawUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawUpdateUnique) depositModel() {}

func (r depositToWithDrawUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToWithDrawFindUnique) Delete() depositToWithDrawDeleteUnique {
	var v depositToWithDrawDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositToWithDrawDeleteUnique struct {
	query builder.Query
}

func (r depositToWithDrawDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToWithDrawDeleteUnique) depositModel() {}

func (r depositToWithDrawDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToWithDrawFindFirst struct {
	query builder.Query
}

func (r depositToWithDrawFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindFirst) with()            {}
func (r depositToWithDrawFindFirst) depositModel()    {}
func (r depositToWithDrawFindFirst) depositRelation() {}

func (r depositToWithDrawFindFirst) With(params ...WithDrawRelationWith) depositToWithDrawFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindFirst) Select(params ...depositPrismaFields) depositToWithDrawFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindFirst) Omit(params ...depositPrismaFields) depositToWithDrawFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindFirst) OrderBy(params ...WithDrawOrderByParam) depositToWithDrawFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToWithDrawFindFirst) Skip(count int) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindFirst) Take(count int) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindFirst) Cursor(cursor DepositCursorParam) depositToWithDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToWithDrawFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToWithDrawFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositToWithDrawFindMany struct {
	query builder.Query
}

func (r depositToWithDrawFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawFindMany) with()            {}
func (r depositToWithDrawFindMany) depositModel()    {}
func (r depositToWithDrawFindMany) depositRelation() {}

func (r depositToWithDrawFindMany) With(params ...WithDrawRelationWith) depositToWithDrawFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToWithDrawFindMany) Select(params ...depositPrismaFields) depositToWithDrawFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindMany) Omit(params ...depositPrismaFields) depositToWithDrawFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToWithDrawFindMany) OrderBy(params ...WithDrawOrderByParam) depositToWithDrawFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToWithDrawFindMany) Skip(count int) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindMany) Take(count int) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToWithDrawFindMany) Cursor(cursor DepositCursorParam) depositToWithDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToWithDrawFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToWithDrawFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToWithDrawFindMany) Update(params ...DepositSetParam) depositToWithDrawUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositToWithDrawUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToWithDrawUpdateMany struct {
	query builder.Query
}

func (r depositToWithDrawUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToWithDrawUpdateMany) depositModel() {}

func (r depositToWithDrawUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToWithDrawFindMany) Delete() depositToWithDrawDeleteMany {
	var v depositToWithDrawDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositToWithDrawDeleteMany struct {
	query builder.Query
}

func (r depositToWithDrawDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToWithDrawDeleteMany) depositModel() {}

func (r depositToWithDrawDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToWithDrawDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToDepositTransactionFindUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindUnique) with()            {}
func (r depositToDepositTransactionFindUnique) depositModel()    {}
func (r depositToDepositTransactionFindUnique) depositRelation() {}

func (r depositToDepositTransactionFindUnique) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindUnique) Select(params ...depositPrismaFields) depositToDepositTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindUnique) Omit(params ...depositPrismaFields) depositToDepositTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindUnique) Update(params ...DepositSetParam) depositToDepositTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositToDepositTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToDepositTransactionUpdateUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionUpdateUnique) depositModel() {}

func (r depositToDepositTransactionUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToDepositTransactionFindUnique) Delete() depositToDepositTransactionDeleteUnique {
	var v depositToDepositTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositToDepositTransactionDeleteUnique struct {
	query builder.Query
}

func (r depositToDepositTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToDepositTransactionDeleteUnique) depositModel() {}

func (r depositToDepositTransactionDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositToDepositTransactionFindFirst struct {
	query builder.Query
}

func (r depositToDepositTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindFirst) with()            {}
func (r depositToDepositTransactionFindFirst) depositModel()    {}
func (r depositToDepositTransactionFindFirst) depositRelation() {}

func (r depositToDepositTransactionFindFirst) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindFirst) Select(params ...depositPrismaFields) depositToDepositTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindFirst) Omit(params ...depositPrismaFields) depositToDepositTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindFirst) OrderBy(params ...DepositTransactionOrderByParam) depositToDepositTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToDepositTransactionFindFirst) Skip(count int) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Take(count int) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Cursor(cursor DepositCursorParam) depositToDepositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToDepositTransactionFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositToDepositTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositToDepositTransactionFindMany struct {
	query builder.Query
}

func (r depositToDepositTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionFindMany) with()            {}
func (r depositToDepositTransactionFindMany) depositModel()    {}
func (r depositToDepositTransactionFindMany) depositRelation() {}

func (r depositToDepositTransactionFindMany) With(params ...DepositTransactionRelationWith) depositToDepositTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositToDepositTransactionFindMany) Select(params ...depositPrismaFields) depositToDepositTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindMany) Omit(params ...depositPrismaFields) depositToDepositTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositToDepositTransactionFindMany) OrderBy(params ...DepositTransactionOrderByParam) depositToDepositTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositToDepositTransactionFindMany) Skip(count int) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindMany) Take(count int) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositToDepositTransactionFindMany) Cursor(cursor DepositCursorParam) depositToDepositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositToDepositTransactionFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToDepositTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositToDepositTransactionFindMany) Update(params ...DepositSetParam) depositToDepositTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositToDepositTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositToDepositTransactionUpdateMany struct {
	query builder.Query
}

func (r depositToDepositTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositToDepositTransactionUpdateMany) depositModel() {}

func (r depositToDepositTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositToDepositTransactionFindMany) Delete() depositToDepositTransactionDeleteMany {
	var v depositToDepositTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositToDepositTransactionDeleteMany struct {
	query builder.Query
}

func (r depositToDepositTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositToDepositTransactionDeleteMany) depositModel() {}

func (r depositToDepositTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositToDepositTransactionDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositFindUnique struct {
	query builder.Query
}

func (r depositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindUnique) with()            {}
func (r depositFindUnique) depositModel()    {}
func (r depositFindUnique) depositRelation() {}

func (r depositActions) FindUnique(
	params DepositEqualsUniqueWhereParam,
) depositFindUnique {
	var v depositFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositFindUnique) With(params ...DepositRelationWith) depositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindUnique) Select(params ...depositPrismaFields) depositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindUnique) Omit(params ...depositPrismaFields) depositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindUnique) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindUnique) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindUnique) Update(params ...DepositSetParam) depositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Deposit"

	var v depositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositUpdateUnique struct {
	query builder.Query
}

func (r depositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpdateUnique) depositModel() {}

func (r depositUpdateUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpdateUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositFindUnique) Delete() depositDeleteUnique {
	var v depositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Deposit"

	return v
}

type depositDeleteUnique struct {
	query builder.Query
}

func (r depositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositDeleteUnique) depositModel() {}

func (r depositDeleteUnique) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositDeleteUnique) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositFindFirst struct {
	query builder.Query
}

func (r depositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindFirst) with()            {}
func (r depositFindFirst) depositModel()    {}
func (r depositFindFirst) depositRelation() {}

func (r depositActions) FindFirst(
	params ...DepositWhereParam,
) depositFindFirst {
	var v depositFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositFindFirst) With(params ...DepositRelationWith) depositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindFirst) Select(params ...depositPrismaFields) depositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindFirst) Omit(params ...depositPrismaFields) depositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindFirst) OrderBy(params ...DepositOrderByParam) depositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositFindFirst) Skip(count int) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositFindFirst) Take(count int) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositFindFirst) Cursor(cursor DepositCursorParam) depositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositFindFirst) Exec(ctx context.Context) (
	*DepositModel,
	error,
) {
	var v *DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositFindFirst) ExecInner(ctx context.Context) (
	*InnerDeposit,
	error,
) {
	var v *InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositFindMany struct {
	query builder.Query
}

func (r depositFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositFindMany) with()            {}
func (r depositFindMany) depositModel()    {}
func (r depositFindMany) depositRelation() {}

func (r depositActions) FindMany(
	params ...DepositWhereParam,
) depositFindMany {
	var v depositFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositFindMany) With(params ...DepositRelationWith) depositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositFindMany) Select(params ...depositPrismaFields) depositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindMany) Omit(params ...depositPrismaFields) depositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositFindMany) OrderBy(params ...DepositOrderByParam) depositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositFindMany) Skip(count int) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositFindMany) Take(count int) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositFindMany) Cursor(cursor DepositCursorParam) depositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositFindMany) Exec(ctx context.Context) (
	[]DepositModel,
	error,
) {
	var v []DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositFindMany) ExecInner(ctx context.Context) (
	[]InnerDeposit,
	error,
) {
	var v []InnerDeposit
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositFindMany) Update(params ...DepositSetParam) depositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Deposit"

	r.query.Outputs = countOutput

	var v depositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositUpdateMany struct {
	query builder.Query
}

func (r depositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpdateMany) depositModel() {}

func (r depositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpdateMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositFindMany) Delete() depositDeleteMany {
	var v depositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Deposit"

	v.query.Outputs = countOutput

	return v
}

type depositDeleteMany struct {
	query builder.Query
}

func (r depositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositDeleteMany) depositModel() {}

func (r depositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositDeleteMany) Tx() DepositManyTxResult {
	v := newDepositManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToDepositFindUnique struct {
	query builder.Query
}

func (r withDrawToDepositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindUnique) with()             {}
func (r withDrawToDepositFindUnique) withDrawModel()    {}
func (r withDrawToDepositFindUnique) withDrawRelation() {}

func (r withDrawToDepositFindUnique) With(params ...DepositRelationWith) withDrawToDepositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindUnique) Select(params ...withDrawPrismaFields) withDrawToDepositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindUnique) Omit(params ...withDrawPrismaFields) withDrawToDepositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindUnique) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindUnique) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindUnique) Update(params ...WithDrawSetParam) withDrawToDepositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WithDraw"

	var v withDrawToDepositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToDepositUpdateUnique struct {
	query builder.Query
}

func (r withDrawToDepositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositUpdateUnique) withDrawModel() {}

func (r withDrawToDepositUpdateUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositUpdateUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToDepositFindUnique) Delete() withDrawToDepositDeleteUnique {
	var v withDrawToDepositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WithDraw"

	return v
}

type withDrawToDepositDeleteUnique struct {
	query builder.Query
}

func (r withDrawToDepositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToDepositDeleteUnique) withDrawModel() {}

func (r withDrawToDepositDeleteUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositDeleteUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawToDepositFindFirst struct {
	query builder.Query
}

func (r withDrawToDepositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindFirst) with()             {}
func (r withDrawToDepositFindFirst) withDrawModel()    {}
func (r withDrawToDepositFindFirst) withDrawRelation() {}

func (r withDrawToDepositFindFirst) With(params ...DepositRelationWith) withDrawToDepositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindFirst) Select(params ...withDrawPrismaFields) withDrawToDepositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindFirst) Omit(params ...withDrawPrismaFields) withDrawToDepositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindFirst) OrderBy(params ...DepositOrderByParam) withDrawToDepositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToDepositFindFirst) Skip(count int) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindFirst) Take(count int) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindFirst) Cursor(cursor WithDrawCursorParam) withDrawToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToDepositFindFirst) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawToDepositFindFirst) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type withDrawToDepositFindMany struct {
	query builder.Query
}

func (r withDrawToDepositFindMany) getQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositFindMany) with()             {}
func (r withDrawToDepositFindMany) withDrawModel()    {}
func (r withDrawToDepositFindMany) withDrawRelation() {}

func (r withDrawToDepositFindMany) With(params ...DepositRelationWith) withDrawToDepositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawToDepositFindMany) Select(params ...withDrawPrismaFields) withDrawToDepositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindMany) Omit(params ...withDrawPrismaFields) withDrawToDepositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawToDepositFindMany) OrderBy(params ...DepositOrderByParam) withDrawToDepositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawToDepositFindMany) Skip(count int) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindMany) Take(count int) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawToDepositFindMany) Cursor(cursor WithDrawCursorParam) withDrawToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawToDepositFindMany) Exec(ctx context.Context) (
	[]WithDrawModel,
	error,
) {
	var v []WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToDepositFindMany) ExecInner(ctx context.Context) (
	[]InnerWithDraw,
	error,
) {
	var v []InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawToDepositFindMany) Update(params ...WithDrawSetParam) withDrawToDepositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WithDraw"

	r.query.Outputs = countOutput

	var v withDrawToDepositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawToDepositUpdateMany struct {
	query builder.Query
}

func (r withDrawToDepositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawToDepositUpdateMany) withDrawModel() {}

func (r withDrawToDepositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositUpdateMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawToDepositFindMany) Delete() withDrawToDepositDeleteMany {
	var v withDrawToDepositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WithDraw"

	v.query.Outputs = countOutput

	return v
}

type withDrawToDepositDeleteMany struct {
	query builder.Query
}

func (r withDrawToDepositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawToDepositDeleteMany) withDrawModel() {}

func (r withDrawToDepositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawToDepositDeleteMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawFindUnique struct {
	query builder.Query
}

func (r withDrawFindUnique) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindUnique) with()             {}
func (r withDrawFindUnique) withDrawModel()    {}
func (r withDrawFindUnique) withDrawRelation() {}

func (r withDrawActions) FindUnique(
	params WithDrawEqualsUniqueWhereParam,
) withDrawFindUnique {
	var v withDrawFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r withDrawFindUnique) With(params ...WithDrawRelationWith) withDrawFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindUnique) Select(params ...withDrawPrismaFields) withDrawFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindUnique) Omit(params ...withDrawPrismaFields) withDrawFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindUnique) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindUnique) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindUnique) Update(params ...WithDrawSetParam) withDrawUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WithDraw"

	var v withDrawUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawUpdateUnique struct {
	query builder.Query
}

func (r withDrawUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpdateUnique) withDrawModel() {}

func (r withDrawUpdateUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpdateUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawFindUnique) Delete() withDrawDeleteUnique {
	var v withDrawDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WithDraw"

	return v
}

type withDrawDeleteUnique struct {
	query builder.Query
}

func (r withDrawDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawDeleteUnique) withDrawModel() {}

func (r withDrawDeleteUnique) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawDeleteUnique) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawFindFirst struct {
	query builder.Query
}

func (r withDrawFindFirst) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindFirst) with()             {}
func (r withDrawFindFirst) withDrawModel()    {}
func (r withDrawFindFirst) withDrawRelation() {}

func (r withDrawActions) FindFirst(
	params ...WithDrawWhereParam,
) withDrawFindFirst {
	var v withDrawFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r withDrawFindFirst) With(params ...WithDrawRelationWith) withDrawFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindFirst) Select(params ...withDrawPrismaFields) withDrawFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindFirst) Omit(params ...withDrawPrismaFields) withDrawFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindFirst) OrderBy(params ...WithDrawOrderByParam) withDrawFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawFindFirst) Skip(count int) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawFindFirst) Take(count int) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawFindFirst) Cursor(cursor WithDrawCursorParam) withDrawFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawFindFirst) Exec(ctx context.Context) (
	*WithDrawModel,
	error,
) {
	var v *WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r withDrawFindFirst) ExecInner(ctx context.Context) (
	*InnerWithDraw,
	error,
) {
	var v *InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type withDrawFindMany struct {
	query builder.Query
}

func (r withDrawFindMany) getQuery() builder.Query {
	return r.query
}

func (r withDrawFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawFindMany) with()             {}
func (r withDrawFindMany) withDrawModel()    {}
func (r withDrawFindMany) withDrawRelation() {}

func (r withDrawActions) FindMany(
	params ...WithDrawWhereParam,
) withDrawFindMany {
	var v withDrawFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r withDrawFindMany) With(params ...WithDrawRelationWith) withDrawFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r withDrawFindMany) Select(params ...withDrawPrismaFields) withDrawFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindMany) Omit(params ...withDrawPrismaFields) withDrawFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range withDrawOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r withDrawFindMany) OrderBy(params ...WithDrawOrderByParam) withDrawFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r withDrawFindMany) Skip(count int) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r withDrawFindMany) Take(count int) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r withDrawFindMany) Cursor(cursor WithDrawCursorParam) withDrawFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r withDrawFindMany) Exec(ctx context.Context) (
	[]WithDrawModel,
	error,
) {
	var v []WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawFindMany) ExecInner(ctx context.Context) (
	[]InnerWithDraw,
	error,
) {
	var v []InnerWithDraw
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r withDrawFindMany) Update(params ...WithDrawSetParam) withDrawUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WithDraw"

	r.query.Outputs = countOutput

	var v withDrawUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type withDrawUpdateMany struct {
	query builder.Query
}

func (r withDrawUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpdateMany) withDrawModel() {}

func (r withDrawUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpdateMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r withDrawFindMany) Delete() withDrawDeleteMany {
	var v withDrawDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WithDraw"

	v.query.Outputs = countOutput

	return v
}

type withDrawDeleteMany struct {
	query builder.Query
}

func (r withDrawDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p withDrawDeleteMany) withDrawModel() {}

func (r withDrawDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawDeleteMany) Tx() WithDrawManyTxResult {
	v := newWithDrawManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionToDepositFindUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindUnique) with()                       {}
func (r depositTransactionToDepositFindUnique) depositTransactionModel()    {}
func (r depositTransactionToDepositFindUnique) depositTransactionRelation() {}

func (r depositTransactionToDepositFindUnique) With(params ...DepositRelationWith) depositTransactionToDepositFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindUnique) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindUnique) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindUnique) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindUnique) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindUnique) Update(params ...DepositTransactionSetParam) depositTransactionToDepositUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DepositTransaction"

	var v depositTransactionToDepositUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionToDepositUpdateUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositUpdateUnique) depositTransactionModel() {}

func (r depositTransactionToDepositUpdateUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositUpdateUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionToDepositFindUnique) Delete() depositTransactionToDepositDeleteUnique {
	var v depositTransactionToDepositDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DepositTransaction"

	return v
}

type depositTransactionToDepositDeleteUnique struct {
	query builder.Query
}

func (r depositTransactionToDepositDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionToDepositDeleteUnique) depositTransactionModel() {}

func (r depositTransactionToDepositDeleteUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositDeleteUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionToDepositFindFirst struct {
	query builder.Query
}

func (r depositTransactionToDepositFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindFirst) with()                       {}
func (r depositTransactionToDepositFindFirst) depositTransactionModel()    {}
func (r depositTransactionToDepositFindFirst) depositTransactionRelation() {}

func (r depositTransactionToDepositFindFirst) With(params ...DepositRelationWith) depositTransactionToDepositFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindFirst) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindFirst) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindFirst) OrderBy(params ...DepositOrderByParam) depositTransactionToDepositFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionToDepositFindFirst) Skip(count int) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Take(count int) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Cursor(cursor DepositTransactionCursorParam) depositTransactionToDepositFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionToDepositFindFirst) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionToDepositFindFirst) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositTransactionToDepositFindMany struct {
	query builder.Query
}

func (r depositTransactionToDepositFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositFindMany) with()                       {}
func (r depositTransactionToDepositFindMany) depositTransactionModel()    {}
func (r depositTransactionToDepositFindMany) depositTransactionRelation() {}

func (r depositTransactionToDepositFindMany) With(params ...DepositRelationWith) depositTransactionToDepositFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionToDepositFindMany) Select(params ...depositTransactionPrismaFields) depositTransactionToDepositFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindMany) Omit(params ...depositTransactionPrismaFields) depositTransactionToDepositFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionToDepositFindMany) OrderBy(params ...DepositOrderByParam) depositTransactionToDepositFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionToDepositFindMany) Skip(count int) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindMany) Take(count int) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionToDepositFindMany) Cursor(cursor DepositTransactionCursorParam) depositTransactionToDepositFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionToDepositFindMany) Exec(ctx context.Context) (
	[]DepositTransactionModel,
	error,
) {
	var v []DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionToDepositFindMany) ExecInner(ctx context.Context) (
	[]InnerDepositTransaction,
	error,
) {
	var v []InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionToDepositFindMany) Update(params ...DepositTransactionSetParam) depositTransactionToDepositUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DepositTransaction"

	r.query.Outputs = countOutput

	var v depositTransactionToDepositUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionToDepositUpdateMany struct {
	query builder.Query
}

func (r depositTransactionToDepositUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionToDepositUpdateMany) depositTransactionModel() {}

func (r depositTransactionToDepositUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositUpdateMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionToDepositFindMany) Delete() depositTransactionToDepositDeleteMany {
	var v depositTransactionToDepositDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DepositTransaction"

	v.query.Outputs = countOutput

	return v
}

type depositTransactionToDepositDeleteMany struct {
	query builder.Query
}

func (r depositTransactionToDepositDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionToDepositDeleteMany) depositTransactionModel() {}

func (r depositTransactionToDepositDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionToDepositDeleteMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionFindUnique struct {
	query builder.Query
}

func (r depositTransactionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindUnique) with()                       {}
func (r depositTransactionFindUnique) depositTransactionModel()    {}
func (r depositTransactionFindUnique) depositTransactionRelation() {}

func (r depositTransactionActions) FindUnique(
	params DepositTransactionEqualsUniqueWhereParam,
) depositTransactionFindUnique {
	var v depositTransactionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositTransactionFindUnique) With(params ...DepositTransactionRelationWith) depositTransactionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindUnique) Select(params ...depositTransactionPrismaFields) depositTransactionFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindUnique) Omit(params ...depositTransactionPrismaFields) depositTransactionFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindUnique) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindUnique) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindUnique) Update(params ...DepositTransactionSetParam) depositTransactionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "DepositTransaction"

	var v depositTransactionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionUpdateUnique struct {
	query builder.Query
}

func (r depositTransactionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpdateUnique) depositTransactionModel() {}

func (r depositTransactionUpdateUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpdateUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionFindUnique) Delete() depositTransactionDeleteUnique {
	var v depositTransactionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "DepositTransaction"

	return v
}

type depositTransactionDeleteUnique struct {
	query builder.Query
}

func (r depositTransactionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionDeleteUnique) depositTransactionModel() {}

func (r depositTransactionDeleteUnique) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionDeleteUnique) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionFindFirst struct {
	query builder.Query
}

func (r depositTransactionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindFirst) with()                       {}
func (r depositTransactionFindFirst) depositTransactionModel()    {}
func (r depositTransactionFindFirst) depositTransactionRelation() {}

func (r depositTransactionActions) FindFirst(
	params ...DepositTransactionWhereParam,
) depositTransactionFindFirst {
	var v depositTransactionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositTransactionFindFirst) With(params ...DepositTransactionRelationWith) depositTransactionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindFirst) Select(params ...depositTransactionPrismaFields) depositTransactionFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindFirst) Omit(params ...depositTransactionPrismaFields) depositTransactionFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindFirst) OrderBy(params ...DepositTransactionOrderByParam) depositTransactionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionFindFirst) Skip(count int) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionFindFirst) Take(count int) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionFindFirst) Cursor(cursor DepositTransactionCursorParam) depositTransactionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionFindFirst) Exec(ctx context.Context) (
	*DepositTransactionModel,
	error,
) {
	var v *DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r depositTransactionFindFirst) ExecInner(ctx context.Context) (
	*InnerDepositTransaction,
	error,
) {
	var v *InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type depositTransactionFindMany struct {
	query builder.Query
}

func (r depositTransactionFindMany) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionFindMany) with()                       {}
func (r depositTransactionFindMany) depositTransactionModel()    {}
func (r depositTransactionFindMany) depositTransactionRelation() {}

func (r depositTransactionActions) FindMany(
	params ...DepositTransactionWhereParam,
) depositTransactionFindMany {
	var v depositTransactionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r depositTransactionFindMany) With(params ...DepositTransactionRelationWith) depositTransactionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r depositTransactionFindMany) Select(params ...depositTransactionPrismaFields) depositTransactionFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindMany) Omit(params ...depositTransactionPrismaFields) depositTransactionFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range depositTransactionOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r depositTransactionFindMany) OrderBy(params ...DepositTransactionOrderByParam) depositTransactionFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r depositTransactionFindMany) Skip(count int) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r depositTransactionFindMany) Take(count int) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r depositTransactionFindMany) Cursor(cursor DepositTransactionCursorParam) depositTransactionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r depositTransactionFindMany) Exec(ctx context.Context) (
	[]DepositTransactionModel,
	error,
) {
	var v []DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionFindMany) ExecInner(ctx context.Context) (
	[]InnerDepositTransaction,
	error,
) {
	var v []InnerDepositTransaction
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r depositTransactionFindMany) Update(params ...DepositTransactionSetParam) depositTransactionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "DepositTransaction"

	r.query.Outputs = countOutput

	var v depositTransactionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type depositTransactionUpdateMany struct {
	query builder.Query
}

func (r depositTransactionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpdateMany) depositTransactionModel() {}

func (r depositTransactionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpdateMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r depositTransactionFindMany) Delete() depositTransactionDeleteMany {
	var v depositTransactionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "DepositTransaction"

	v.query.Outputs = countOutput

	return v
}

type depositTransactionDeleteMany struct {
	query builder.Query
}

func (r depositTransactionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p depositTransactionDeleteMany) depositTransactionModel() {}

func (r depositTransactionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionDeleteMany) Tx() DepositTransactionManyTxResult {
	v := newDepositTransactionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newTransactionUniqueTxResult() TransactionUniqueTxResult {
	return TransactionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TransactionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionUniqueTxResult) IsTx() {}

func (r TransactionUniqueTxResult) Result() (v *TransactionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionManyTxResult() TransactionManyTxResult {
	return TransactionManyTxResult{
		result: &transaction.Result{},
	}
}

type TransactionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionManyTxResult) IsTx() {}

func (r TransactionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionHistoryUniqueTxResult() TransactionHistoryUniqueTxResult {
	return TransactionHistoryUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TransactionHistoryUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionHistoryUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionHistoryUniqueTxResult) IsTx() {}

func (r TransactionHistoryUniqueTxResult) Result() (v *TransactionHistoryModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTransactionHistoryManyTxResult() TransactionHistoryManyTxResult {
	return TransactionHistoryManyTxResult{
		result: &transaction.Result{},
	}
}

type TransactionHistoryManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TransactionHistoryManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TransactionHistoryManyTxResult) IsTx() {}

func (r TransactionHistoryManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositUniqueTxResult() DepositUniqueTxResult {
	return DepositUniqueTxResult{
		result: &transaction.Result{},
	}
}

type DepositUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositUniqueTxResult) IsTx() {}

func (r DepositUniqueTxResult) Result() (v *DepositModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositManyTxResult() DepositManyTxResult {
	return DepositManyTxResult{
		result: &transaction.Result{},
	}
}

type DepositManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositManyTxResult) IsTx() {}

func (r DepositManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWithDrawUniqueTxResult() WithDrawUniqueTxResult {
	return WithDrawUniqueTxResult{
		result: &transaction.Result{},
	}
}

type WithDrawUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WithDrawUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WithDrawUniqueTxResult) IsTx() {}

func (r WithDrawUniqueTxResult) Result() (v *WithDrawModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWithDrawManyTxResult() WithDrawManyTxResult {
	return WithDrawManyTxResult{
		result: &transaction.Result{},
	}
}

type WithDrawManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WithDrawManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WithDrawManyTxResult) IsTx() {}

func (r WithDrawManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositTransactionUniqueTxResult() DepositTransactionUniqueTxResult {
	return DepositTransactionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type DepositTransactionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositTransactionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositTransactionUniqueTxResult) IsTx() {}

func (r DepositTransactionUniqueTxResult) Result() (v *DepositTransactionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDepositTransactionManyTxResult() DepositTransactionManyTxResult {
	return DepositTransactionManyTxResult{
		result: &transaction.Result{},
	}
}

type DepositTransactionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DepositTransactionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DepositTransactionManyTxResult) IsTx() {}

func (r DepositTransactionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type transactionUpsertOne struct {
	query builder.Query
}

func (r transactionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transactionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionUpsertOne) with()                {}
func (r transactionUpsertOne) transactionModel()    {}
func (r transactionUpsertOne) transactionRelation() {}

func (r transactionActions) UpsertOne(
	params TransactionEqualsUniqueWhereParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Transaction"
	v.query.Outputs = transactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionUpsertOne) Create(

	_userID TransactionWithPrismaUserIDSetParam,
	_amount TransactionWithPrismaAmountSetParam,
	_toAddress TransactionWithPrismaToAddressSetParam,
	_currency TransactionWithPrismaCurrencySetParam,

	optional ...TransactionSetParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _amount.field())
	fields = append(fields, _toAddress.field())
	fields = append(fields, _currency.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transactionUpsertOne) Update(
	params ...TransactionSetParam,
) transactionUpsertOne {
	var v transactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transactionUpsertOne) Exec(ctx context.Context) (*TransactionModel, error) {
	var v TransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionUpsertOne) Tx() TransactionUniqueTxResult {
	v := newTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type transactionHistoryUpsertOne struct {
	query builder.Query
}

func (r transactionHistoryUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r transactionHistoryUpsertOne) with()                       {}
func (r transactionHistoryUpsertOne) transactionHistoryModel()    {}
func (r transactionHistoryUpsertOne) transactionHistoryRelation() {}

func (r transactionHistoryActions) UpsertOne(
	params TransactionHistoryEqualsUniqueWhereParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "TransactionHistory"
	v.query.Outputs = transactionHistoryOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r transactionHistoryUpsertOne) Create(

	_transaction TransactionHistoryWithPrismaTransactionSetParam,
	_status TransactionHistoryWithPrismaStatusSetParam,

	optional ...TransactionHistorySetParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _transaction.field())
	fields = append(fields, _status.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r transactionHistoryUpsertOne) Update(
	params ...TransactionHistorySetParam,
) transactionHistoryUpsertOne {
	var v transactionHistoryUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r transactionHistoryUpsertOne) Exec(ctx context.Context) (*TransactionHistoryModel, error) {
	var v TransactionHistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r transactionHistoryUpsertOne) Tx() TransactionHistoryUniqueTxResult {
	v := newTransactionHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositUpsertOne struct {
	query builder.Query
}

func (r depositUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r depositUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r depositUpsertOne) with()            {}
func (r depositUpsertOne) depositModel()    {}
func (r depositUpsertOne) depositRelation() {}

func (r depositActions) UpsertOne(
	params DepositEqualsUniqueWhereParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Deposit"
	v.query.Outputs = depositOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositUpsertOne) Create(

	_userID DepositWithPrismaUserIDSetParam,
	_amount DepositWithPrismaAmountSetParam,

	optional ...DepositSetParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _amount.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r depositUpsertOne) Update(
	params ...DepositSetParam,
) depositUpsertOne {
	var v depositUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r depositUpsertOne) Exec(ctx context.Context) (*DepositModel, error) {
	var v DepositModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositUpsertOne) Tx() DepositUniqueTxResult {
	v := newDepositUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type withDrawUpsertOne struct {
	query builder.Query
}

func (r withDrawUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r withDrawUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r withDrawUpsertOne) with()             {}
func (r withDrawUpsertOne) withDrawModel()    {}
func (r withDrawUpsertOne) withDrawRelation() {}

func (r withDrawActions) UpsertOne(
	params WithDrawEqualsUniqueWhereParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "WithDraw"
	v.query.Outputs = withDrawOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r withDrawUpsertOne) Create(

	_charge WithDrawWithPrismaChargeSetParam,
	_userID WithDrawWithPrismaUserIDSetParam,
	_deposit WithDrawWithPrismaDepositSetParam,

	optional ...WithDrawSetParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _charge.field())
	fields = append(fields, _userID.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r withDrawUpsertOne) Update(
	params ...WithDrawSetParam,
) withDrawUpsertOne {
	var v withDrawUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r withDrawUpsertOne) Exec(ctx context.Context) (*WithDrawModel, error) {
	var v WithDrawModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r withDrawUpsertOne) Tx() WithDrawUniqueTxResult {
	v := newWithDrawUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type depositTransactionUpsertOne struct {
	query builder.Query
}

func (r depositTransactionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r depositTransactionUpsertOne) with()                       {}
func (r depositTransactionUpsertOne) depositTransactionModel()    {}
func (r depositTransactionUpsertOne) depositTransactionRelation() {}

func (r depositTransactionActions) UpsertOne(
	params DepositTransactionEqualsUniqueWhereParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "DepositTransaction"
	v.query.Outputs = depositTransactionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r depositTransactionUpsertOne) Create(

	_amount DepositTransactionWithPrismaAmountSetParam,
	_deposit DepositTransactionWithPrismaDepositSetParam,

	optional ...DepositTransactionSetParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _amount.field())
	fields = append(fields, _deposit.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r depositTransactionUpsertOne) Update(
	params ...DepositTransactionSetParam,
) depositTransactionUpsertOne {
	var v depositTransactionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r depositTransactionUpsertOne) Exec(ctx context.Context) (*DepositTransactionModel, error) {
	var v DepositTransactionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r depositTransactionUpsertOne) Tx() DepositTransactionUniqueTxResult {
	v := newDepositTransactionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}
